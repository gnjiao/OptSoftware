<?xml version="1.0" encoding="utf-8"?>
<examples xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="de_DE" xsi:noNamespaceSchemaLocation="../Manuals/xml/xsd/hdevelop_example_list.xsd">
   <example>
      <name>1394iidc.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_2cameras.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_camera_types.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (Abfragen und Verwenden aller unterstützter Kameratypen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>count_channels</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_strstr</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_crop.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_format7.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (Bildformat 7 mit unterschiedlichen Bildwiederholraten)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>disp_rectangle1</operator>
      <operator>draw_rectangle1</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_round</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_parameters.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_simple.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>1394iidc_software_trigger.hdev</name>
      <desc>Verwenden des 1394IIDC-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>25industrial.hdev</name>
      <desc>Lesen eines Barcodes vom Typ 2/5 industrial</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>25interleaved.hdev</name>
      <desc>Lesen eines Barcodes vom Typ 2/5 interleaved</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>2d_data_codes_arbitrary_distortions.hdev</name>
      <desc>Demonstrieren verschieden deformierter ECC200-Symbole</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_objects</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>read_image</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>2d_data_codes_data_access.hdev</name>
      <desc>Zugreifen auf Zwischenergebnisse beim Versuch, ECC200-Symbole zu lesen</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_objects</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>query_data_code_2d_params</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>2d_data_codes_default_settings.hdev</name>
      <desc>Lesen von Datacodes vom Type Aztec, ECC200, PDF417, QR und Micro QR im 'standard', 'enhanced' und 'maximum' Modus</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>2d_data_codes_minimize_module_gaps.hdev</name>
      <desc>Minimieren großer Lücken in einem ECC200-Symbol</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>gray_erosion_shape</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>2d_data_codes_minimize_noise.hdev</name>
      <desc>Minimieren von Rauschen in einem ECC200-Symbol</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>gray_opening_shape</operator>
      <operator>median_image</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>2d_data_codes_rectify_symbol.hdev</name>
      <desc>Entzerren eines verkippten ECC200-Symbols</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <method>method.trafo.rectif</method>
      <method>method.visual</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>hom_vector_to_proj_hom_mat2d</operator>
      <operator>projective_trans_image</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>3d_coordinates.hdev</name>
      <desc>Messen eines verkippten Objekts in Weltkoordinaten</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.blob</method>
      <method>method.functions</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.trafo.wcoord</method>
      <method>method.metrol</method>
      <method>method.tuple</method>
      <method>method.numeric</method>
      <operator>close_measure</operator>
      <operator>contour_to_world_plane_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>erosion_circle</operator>
      <operator>fill_up</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_contour_xld</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>measure_pos</operator>
      <operator>reduce_domain</operator>
      <operator>regress_contours_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>3d_information_for_selected_points.hdev</name>
      <desc>Berechnen der Weltkoordinaten eines Punktes in einem Stereobildpaar</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.roi</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.stereo</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>binocular_disparity</operator>
      <operator>create_calib_data</operator>
      <operator>disparity_to_distance</operator>
      <operator>disparity_to_point_3d</operator>
      <operator>find_calib_object</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>get_grayval</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_translate_local</operator>
      <operator>intersect_lines_of_sight</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>3d_matching_clamps.hdev</name>
      <desc>Erkennen von 3D-Objekten in Bildern anhand eines 3D-DXF-Modells</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.shape</method>
      <method>method.visual</method>
      <method>method.poseestim</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_point_3d</operator>
      <operator>axis_angle_to_quat</operator>
      <operator>break</operator>
      <operator>clear_object_model_3d</operator>
      <operator>clear_shape_model_3d</operator>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>compose3</operator>
      <operator>convert_point_3d_cart_to_spher</operator>
      <operator>convert_point_3d_spher_to_cart</operator>
      <operator>copy_rectangle</operator>
      <operator>count_seconds</operator>
      <operator>create_pose</operator>
      <operator>create_shape_model_3d</operator>
      <operator>dev_set_preferences</operator>
      <operator>disp_image</operator>
      <operator>disp_region</operator>
      <operator>disp_xld</operator>
      <operator>find_shape_model_3d</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_image_const</operator>
      <operator>gen_region_points</operator>
      <operator>get_draw</operator>
      <operator>get_line_style</operator>
      <operator>get_mposition</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_region_contour</operator>
      <operator>get_shape_model_3d_params</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>open_window</operator>
      <operator>paint_xld</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_3d_point</operator>
      <operator>project_object_model_3d</operator>
      <operator>project_shape_model_3d</operator>
      <operator>quat_compose</operator>
      <operator>quat_normalize</operator>
      <operator>quat_to_hom_mat3d</operator>
      <operator>read_shape_model_3d</operator>
      <operator>set_line_style</operator>
      <operator>set_line_width</operator>
      <operator>set_part</operator>
      <operator>test_region_point</operator>
      <operator>tuple_atan2</operator>
      <operator>tuple_chr</operator>
      <operator>wait_seconds</operator>
      <operator>write_shape_model_3d</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>3d_position_of_circles.hdev</name>
      <desc>Bestimmen der 3D-Pose von Kreisen aus ihren perspektivischen Projektionen</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.general</industry>
      <industry>industry.auto</industry>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.blob</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.numeric</method>
      <method>method.tuple</method>
      <method>method.functions</method>
      <method>method.poseestim</method>
      <operator>affine_trans_point_3d</operator>
      <operator>dev_display</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>erosion_circle</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_circle_pose</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>reduce_domain</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>threshold</operator>
      <operator>tuple_sort_index</operator>
      <operator>union1</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>3d_position_of_rectangle.hdev</name>
      <desc>Schätzen der 3D-Pose rechteckiger Objekte</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.poseestim</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.geom</method>
      <method>method.visual</method>
      <method>method.trafo.wcoord</method>
      <operator>affine_trans_point_3d</operator>
      <operator>area_center</operator>
      <operator>close_contours_xld</operator>
      <operator>complement</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>dilation_rectangle1</operator>
      <operator>dyn_threshold</operator>
      <operator>erosion_circle</operator>
      <operator>erosion_rectangle1</operator>
      <operator>fill_up</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>get_rectangle_pose</operator>
      <operator>get_system</operator>
      <operator>if</operator>
      <operator>intersection</operator>
      <operator>mean_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>reduce_domain</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>set_system</operator>
      <operator>tuple_find</operator>
      <operator>tuple_gen_const</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>abs.hdev</name>
      <desc>Verwenden des ABS-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>sobel_amp</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>abs_crop.hdev</name>
      <desc>Verwenden des ABS-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>abs_image.hdev</name>
      <desc>Berechnen absoluter Pixelwerte eines Bildes</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>abs_image</operator>
      <operator>convert_image_type</operator>
      <operator>sub_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>abs_multiple_cameras.hdev</name>
      <desc>Verwenden des ABS-Interfaces (gleichzeitiges Triggern mehrerer Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>abs_parameters.hdev</name>
      <desc>Verwenden des ABS-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>abs_simple.hdev</name>
      <desc>Verwenden des ABS-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>adapt_pattern.hdev</name>
      <desc>Ausführen einer Online-Mustererkennung mit einem adaptiven Grauwerttemplate</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.match.gray</method>
      <operator>adapt_template</operator>
      <operator>add_channels</operator>
      <operator>best_match</operator>
      <operator>clear_template</operator>
      <operator>close_framegrabber</operator>
      <operator>create_template</operator>
      <operator>draw_rectangle1</operator>
      <operator>fast_match_mg</operator>
      <operator>gen_rectangle1</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>adaption_ocv.hdev</name>
      <desc>Analysieren des Einflusses von Beleuchtungsänderungen auf die angezeigte Qualität der Schriftzeichen</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.ocv</method>
      <method>method.filter.general</method>
      <operator>close_ocv</operator>
      <operator>create_ocv_proj</operator>
      <operator>do_ocv_simple</operator>
      <operator>paint_region</operator>
      <operator>scale_image</operator>
      <operator>traind_ocv_proj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>add_image.hdev</name>
      <desc>Addieren zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>add_image</operator>
      <operator>crop_part</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>adjust_circle_matrix.hdev</name>
      <desc>Verwenden von Matrizen</desc>
      <path>hdevelop/Matrix/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.numeric</method>
      <method>method.tuple</method>
      <operator>add_matrix</operator>
      <operator>add_matrix_mod</operator>
      <operator>clear_matrix</operator>
      <operator>create_matrix</operator>
      <operator>get_full_matrix</operator>
      <operator>get_grayval_interpolated</operator>
      <operator>invert_matrix</operator>
      <operator>mean_matrix</operator>
      <operator>mult_element_matrix</operator>
      <operator>mult_matrix</operator>
      <operator>pow_scalar_element_matrix</operator>
      <operator>scale_matrix</operator>
      <operator>set_value_matrix</operator>
      <operator>sqrt_matrix_mod</operator>
      <operator>sub_matrix</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>adjust_mosaic_images.hdev</name>
      <desc>Erzeugen von sphärischen Mosaikbildern aus radiometrisch angepassten Bildern</desc>
      <path>hdevelop/Tools/Mosaicking/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.match.point</method>
      <method>method.filter.points</method>
      <method>method.mosaic</method>
      <method>method.filter.general</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.align</method>
      <operator>adjust_mosaic_images</operator>
      <operator>cam_mat_to_cam_par</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_radial_distortion_map</operator>
      <operator>gen_spherical_mosaic</operator>
      <operator>hom_mat2d_compose</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_transpose</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>map_image</operator>
      <operator>points_foerstner</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>read_image</operator>
      <operator>rgb1_to_gray</operator>
      <operator>stationary_camera_self_calibration</operator>
      <operator>tile_images_offset</operator>
      <newinversion>8.0.1</newinversion>
   </example>
   <example>
      <name>adlink.hdev</name>
      <desc>Verwenden des ADLINK-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>adlink_parameters.hdev</name>
      <desc>Verwenden des ADLINK-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>adlink_simple.hdev</name>
      <desc>Verwenden des ADLINK-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>advantech_digital_read.hdev</name>
      <desc>Verwenden des Advantech-Interfaces (einfaches Lesen der digitalen Eingänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>advantech_digital_write.hdev</name>
      <desc>Verwenden des Advantech-Interfaces (einfaches Schreiben der digitalen Ausgänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>write_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>affine_trans_region.hdev</name>
      <desc>Anwenden affiner Transformationen auf Regionen</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>affine_trans_region</operator>
      <operator>draw_region</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>affine_transform_image.hdev</name>
      <desc>Anwenden affiner Transformationen auf Bilder</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>dev_update_pc</operator>
      <operator>dev_update_time</operator>
      <operator>dev_update_var</operator>
      <operator>dev_update_window</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>opening_circle</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>affine_transform_image_size.hdev</name>
      <desc>Anwenden affiner Transformationen auf Bildausschnitte</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>affine_trans_image_size</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>align_measurements.hdev</name>
      <desc>Untersuchen einzelner Rasierklingen unter Verwendung formbasierten Matchings zur ROI Ausrichtung</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.metrol</method>
      <method>method.trafo.align</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_pixel</operator>
      <operator>affine_trans_region</operator>
      <operator>clear_shape_model</operator>
      <operator>close_measure</operator>
      <operator>create_shape_model</operator>
      <operator>disp_rectangle2</operator>
      <operator>find_shape_model</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_shape_model_contours</operator>
      <operator>inspect_shape_model</operator>
      <operator>measure_pairs</operator>
      <operator>move_region</operator>
      <operator>translate_measure</operator>
      <operator>union2</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>align_measurements_multithreading.hdev</name>
      <desc>Paralleles Untersuchen von Rasierklingen mit Hilfe von Multithreading</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.metrol</method>
      <method>method.trafo.align</method>
      <method>method.parall</method>
      <operator>affine_trans_pixel</operator>
      <operator>affine_trans_region</operator>
      <operator>clear_shape_model</operator>
      <operator>close_measure</operator>
      <operator>convert_vector_to_tuple</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_pairs</operator>
      <operator>move_region</operator>
      <operator>par_join</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>andor.hdev</name>
      <desc>Verwenden des Andor-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>andor_parameters.hdev</name>
      <desc>Verwenden des Andor-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>andor_simple.hdev</name>
      <desc>Verwenden des Andor-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>angio.hdev</name>
      <desc>Extrahieren von Blutgefäßen und ihrer Durchmesser aus einer Angiografie</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.health</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.numeric</method>
      <method>method.functions</method>
      <method>method.tuple</method>
      <operator>assign</operator>
      <operator>concat_obj</operator>
      <operator>count_obj</operator>
      <operator>gen_empty_obj</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>lines_gauss</operator>
      <operator>select_contours_xld</operator>
      <operator>select_obj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>angle_ll.hdev</name>
      <desc>Berechnen des Winkels zwischen zwei Linien</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>angle_ll</operator>
      <operator>disp_line</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>angle_lx.hdev</name>
      <desc>Berechnen des Winkels zwischen einer Linie und der vertikalen Achse</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>angle_lx</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>anisotropic_diffusion.hdev</name>
      <desc>Glätten eines Bildes mit kantenerhaltender anisotroper Diffusion</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>anisotropic_diffusion</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>apply_bead_inspection_model.hdev</name>
      <desc>Überprüfen der Position und Dicke von Kleberaupen mit dem Modell zur Inspektion von Kleberaupen</desc>
      <path>hdevelop/Inspection/Bead-Inspection/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <method>method.trafo.align</method>
      <operator>apply_bead_inspection_model</operator>
      <operator>clear_bead_inspection_model</operator>
      <operator>create_bead_inspection_model</operator>
      <operator>create_planar_uncalib_deformable_model</operator>
      <operator>find_planar_uncalib_deformable_model</operator>
      <operator>projective_trans_image</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>apply_distance_transform_xld.hdev</name>
      <desc>Vergleichen der Laufzeiten von apply_distance_transform und distance_contours_xld</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>apply_distance_transform_xld</operator>
      <operator>clear_distance_transform_xld</operator>
      <operator>distance_contours_xld</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>segment_contour_attrib_xld</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>apply_metrology_model.hdev</name>
      <desc>Messen von kreisförmigen und rechteckigen Pads mit Hilfe eines Messmodells</desc>
      <path>hdevelop/2D-Metrology/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>add_metrology_object_circle_measure</operator>
      <operator>add_metrology_object_rectangle2_measure</operator>
      <operator>apply_metrology_model</operator>
      <operator>clear_metrology_model</operator>
      <operator>create_metrology_model</operator>
      <operator>get_metrology_object_measures</operator>
      <operator>get_metrology_object_result</operator>
      <operator>get_metrology_object_result_contour</operator>
      <operator>set_metrology_model_image_size</operator>
      <operator>set_metrology_object_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>apply_metrology_model_diamond.hdev</name>
      <desc>Messen des Schliff-Winkels eines Diamanten mit Hilfe eines Messmodells</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.glass</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>add_metrology_object_line_measure</operator>
      <operator>align_metrology_model</operator>
      <operator>apply_metrology_model</operator>
      <operator>clear_metrology_model</operator>
      <operator>create_metrology_model</operator>
      <operator>get_metrology_object_measures</operator>
      <operator>get_metrology_object_result</operator>
      <operator>get_metrology_object_result_contour</operator>
      <operator>set_metrology_model_image_size</operator>
      <operator>set_metrology_model_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>apply_sample_identifier.hdev</name>
      <desc>Erkennen von Weinsorten mit Hilfe von samplebasierter Identifikation</desc>
      <path>hdevelop/Identification/Sample-Based/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <industry>industry.transp</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.sample</method>
      <operator>add_sample_identifier_preparation_data</operator>
      <operator>apply_sample_identifier</operator>
      <operator>clear_sample_identifier</operator>
      <operator>create_sample_identifier</operator>
      <operator>get_sample_identifier_object_info</operator>
      <operator>prepare_sample_identifier</operator>
      <operator>read_sample_identifier</operator>
      <operator>set_sample_identifier_object_info</operator>
      <operator>set_sample_identifier_param</operator>
      <operator>train_sample_identifier</operator>
      <operator>write_sample_identifier</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>area_center.hdev</name>
      <desc>Berechnen der Fläche und des Zentrums von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>area_center</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>area_center_gray.hdev</name>
      <desc>Analysieren der Genauigkeit der Ergebnisse von area_center_gray</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>area_center</operator>
      <operator>area_center_gray</operator>
      <operator>gen_circle</operator>
      <operator>gen_image_const</operator>
      <operator>paint_region</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>area_holes.hdev</name>
      <desc>Berechnen der Fläche der Löcher einer Region</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>area_holes</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>argos3d-p1xx_objectmodel3d.hdev</name>
      <desc>Verwenden des Argos3D-P1xx-Interfaces, um ein 3D-Objektmodell aus Argos3D-P1xx-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>open_framegrabber</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>argos3d-p1xx_simple.hdev</name>
      <desc>Verwenden des Argos3D-P1xx-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>arithmetic.hdev</name>
      <desc>Anwenden von Operationen auf Skalare, Tupel und Zeichenketten</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.tuple</method>
      <method>method.string</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>assign.hdev</name>
      <desc>Zuweisen von Werten zu Variablen und Tupelelementen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <method>method.functions</method>
      <method>method.controlstruct</method>
      <method>method.numeric</method>
      <operator>assign</operator>
      <operator>endfor</operator>
      <operator>for</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>atoms.hdev</name>
      <desc>Auffinden von Unregelmäßigkeiten in einer atomaren Gitterstruktur</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>crop_rectangle1</operator>
      <operator>gauss_filter</operator>
      <operator>select_shape</operator>
      <operator>watersheds</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>auto_select_region_features.hdev</name>
      <desc>Klassifizieren von Teilen mit automatisch ausgewählten Regionenmerkmalen und einem k-NN-Klassifikator</desc>
      <path>hdevelop/Classification/Feature-Selection/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <operator>add_sample_class_train_data</operator>
      <operator>classify_class_knn</operator>
      <operator>clear_class_knn</operator>
      <operator>clear_class_train_data</operator>
      <operator>create_class_train_data</operator>
      <operator>select_feature_set_knn</operator>
      <operator>set_feature_lengths_class_train_data</operator>
      <operator>set_params_class_knn</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>auto_threshold.hdev</name>
      <desc>Segmentieren eines Bildes mit einem automatisch bestimmten Schwellwert</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.funct1d</method>
      <operator>auto_threshold</operator>
      <operator>create_funct_1d_array</operator>
      <operator>funct_1d_to_pairs</operator>
      <operator>gen_region_histo</operator>
      <operator>gray_histo</operator>
      <operator>smooth_funct_1d_gauss</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>autobahn.hdev</name>
      <desc>Schnelles Erfassen von Fahrbahnmarkierungen</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.transp</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.filter.edge</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <operator>clip_region</operator>
      <operator>dev_display</operator>
      <operator>dilation_rectangle1</operator>
      <operator>fill_up</operator>
      <operator>gen_grid_region</operator>
      <operator>get_system</operator>
      <operator>read_image</operator>
      <operator>reduce_domain</operator>
      <operator>set_system</operator>
      <operator>sobel_amp</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>aztec_optimized_settings.hdev</name>
      <desc>Optimieren von Parametern zum Lesen von Datacodes vom Typ Aztec</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>aztec_simple.hdev</name>
      <desc>Lesen von Datacodes vom Typ Aztec</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>background_seg.hdev</name>
      <desc>Berechnen zusammenhängender Hintergrundkomponenten für vorgegebene Vordergrundregionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.segm</method>
      <method>method.regionproc</method>
      <operator>background_seg</operator>
      <operator>fill_up_shape</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>ball.hdev</name>
      <desc>Untersuchen von Ball-Bondierungen</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.functions</method>
      <method>method.filter.general</method>
      <operator>connection</operator>
      <operator>disp_circle</operator>
      <operator>fill_up_shape</operator>
      <operator>opening_circle</operator>
      <operator>reduce_domain</operator>
      <operator>smallest_circle</operator>
      <operator>sort_region</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>ball_seq.hdev</name>
      <desc>Untersuchen von Ball-Bondierungen (mehrere Bilder)</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.functions</method>
      <method>method.filter.general</method>
      <operator>difference</operator>
      <operator>expand_gray</operator>
      <operator>fill_up_shape</operator>
      <operator>gen_empty_region</operator>
      <operator>min_max_gray</operator>
      <operator>opening_circle</operator>
      <operator>read_image</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_std</operator>
      <operator>shape_trans</operator>
      <operator>smallest_circle</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>bandpass_image.hdev</name>
      <desc>Extrahieren von Linien unter Verwendung eines Bandpassfilters</desc>
      <path>hdevelop/Filters/Lines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>bandpass_image</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>barcode_autodiscrimination.hdev</name>
      <desc>Lesen eines Barcodes unter Verwendung von Autodiskriminierung</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <operator>get_param_info</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>barcode_orientation.hdev</name>
      <desc>Verwenden des Barcodeparameters 'orientation'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>dev_set_window_extents</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <operator>rotate_image</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>barcode_param_contrast_min.hdev</name>
      <desc>Verwenden des Barcodeparameters 'contrast_min'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_object</operator>
      <operator>get_bar_code_result</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>barcode_param_element_size_variable.hdev</name>
      <desc>Verwenden des Barcodeparameters 'element_size_variable'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>decode_bar_code_rectangle2</operator>
      <operator>get_bar_code_object</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>barcode_param_majority_voting.hdev</name>
      <desc>Verwenden des Barcodeparameters 'majority_voting'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>decode_bar_code_rectangle2</operator>
      <operator>get_bar_code_object</operator>
      <operator>get_bar_code_result</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>barcode_param_meas_param_estimation.hdev</name>
      <desc>Verwenden des Barcodeparameters 'meas_param_estimation'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>barcode_param_meas_thresh_abs.hdev</name>
      <desc>Verwenden des Barcodeparameters 'meas_thresh_abs'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>barcode_param_num_scanlines.hdev</name>
      <desc>Kontrollieren der Anzahl von Scanlinien für den Barcodeleser</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>barcode_param_orientation.hdev</name>
      <desc>Verwenden der Barcodeparameter 'orientation' und 'orientation_tol'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_param</operator>
      <operator>get_bar_code_result</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>barcode_param_scanning_control.hdev</name>
      <desc>Steuern des Scanverhaltens des Barcodelesers</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>barcode_param_stop_after_result_num.hdev</name>
      <desc>Verwenden des Barcodeparameters 'stop_after_result_num'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>get_bar_code_object</operator>
      <operator>get_image_size</operator>
      <operator>set_bar_code_param</operator>
      <operator>set_bar_code_param_specific</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>barcode_param_width_height.hdev</name>
      <desc>Verwenden der Barcodeparameter 'barcode_width_min' and 'barcode_height_min'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_object</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>barcode_quiet_zone.hdev</name>
      <desc>Verwenden des Barcodeparameters 'quiet_zone'</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>barcode_status.hdev</name>
      <desc>Zugreifen auf Statusmeldungen für den Barcodeleser</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>get_bar_code_result</operator>
      <operator>tuple_number</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>barcode_training.hdev</name>
      <desc>Trainieren der Parameter eines Barcodelesers</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_param</operator>
      <operator>get_bar_code_param_specific</operator>
      <operator>query_bar_code_params</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>barcode_typical_cases.hdev</name>
      <desc>Vorverarbeiten von schwierig zu lesenden Barcodes</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>create_bar_code_model</operator>
      <operator>emphasize</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_object</operator>
      <operator>get_bar_code_result</operator>
      <operator>gray_erosion_shape</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>best_match.hdev</name>
      <desc>Finden des besten Matches zu einem Grauwerttemplate</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <operator>best_match</operator>
      <operator>create_template</operator>
      <operator>disp_rectangle1</operator>
      <operator>fill_interlace</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>best_match_mg.hdev</name>
      <desc>Finden des besten Matches zu einem Grauwerttemplate in einer Pyramide</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <operator>adapt_template</operator>
      <operator>add_noise_white</operator>
      <operator>affine_trans_image</operator>
      <operator>best_match_mg</operator>
      <operator>create_template</operator>
      <operator>gen_rectangle1</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>best_match_rot_mg.hdev</name>
      <desc>Finden des besten Matches (mit Rotation) zu einem Grauwerttemplate in einer Pyramide</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template_rot</operator>
      <operator>disp_arrow</operator>
      <operator>fill_interlace</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>best_match_rot_mg_clip1.hdev</name>
      <desc>Bestimmen der Position und Orientierung von Büroklammern mit einem Grauwerttemplate</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template_rot</operator>
      <operator>difference</operator>
      <operator>disp_arrow</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_domain</operator>
      <operator>if</operator>
      <operator>union1</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>best_match_rot_mg_clip2.hdev</name>
      <desc>Bestimmen der Position und Orientierung von Büroklammern nur aufgrund der Klammerspitzen</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template_rot</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>disp_arrow</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_domain</operator>
      <operator>union1</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>binary_threshold.hdev</name>
      <desc>Segmentieren eines Bildes mit einem automatisch bestimmten Schwellwert</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>binary_threshold</operator>
      <operator>symm_difference</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>binocular_calibration.hdev</name>
      <desc>Kalibrieren eines Stereosystems und Rektifizieren von Bildpaaren</desc>
      <path>hdevelop/Calibration/Binocular/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.stereo</method>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.trafo.rectif</method>
      <operator>binocular_calibration</operator>
      <operator>caltab_points</operator>
      <operator>disp_caltab</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>map_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>binocular_disparity.hdev</name>
      <desc>Berechnen der Disparitäten aus epipolaren Bildpaaren</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>binocular_disparity_comparison.hdev</name>
      <desc>Vergleichen verschiedener Methoden zur Berechnung von Disparitäten aus epipolaren Bildpaaren</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity</operator>
      <operator>binocular_disparity_mg</operator>
      <operator>binocular_disparity_ms</operator>
      <operator>change_domain</operator>
      <operator>convert_image_type</operator>
      <operator>gray_features</operator>
      <operator>region_features</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>binocular_disparity_mg.hdev</name>
      <desc>Berechnen der Disparitäten aus epipolaren Bildpaaren mit Hilfe von Mehrgitter-Verfahren</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity_mg</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>map_image</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>binocular_disparity_ms.hdev</name>
      <desc>Berechnen der Disparitäten aus epipolaren Bildpaaren mit Hilfe von Multi-Scanline-Optimierung</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity_ms</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>map_image</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>binocular_disparity_segmentation.hdev</name>
      <desc>Demonstrieren von Ergebnissen aus Stereo mit einem künstlichen Bildpaar</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.stereo</method>
      <method>method.visual</method>
      <method>method.filter.general</method>
      <method>method.feat</method>
      <method>method.roi</method>
      <method>method.typeconv.ico</method>
      <method>method.trafo.geom</method>
      <operator>add_noise_white</operator>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>binary_threshold</operator>
      <operator>binocular_disparity</operator>
      <operator>convert_image_type</operator>
      <operator>gen_circle</operator>
      <operator>gen_image_const</operator>
      <operator>gen_image_proto</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>min_max_gray</operator>
      <operator>paint_gray</operator>
      <operator>scale_image</operator>
      <operator>smallest_circle</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>binocular_distance_mg.hdev</name>
      <desc>Berechnen der Tiefen von PCB Komponenten mit Hilfe von Mehrgitter-Verfahren</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_distance_mg</operator>
      <operator>gen_binocular_rectification_map</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>binocular_distance_ms.hdev</name>
      <desc>Berechnen der Tiefen von PCB Komponenten mit Hilfe von Multi-Scanline-Optimierung</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_distance_ms</operator>
      <operator>gen_binocular_rectification_map</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>binomial_filter.hdev</name>
      <desc>Vergleichen der Performance von binomialen Filtern und Gaußfiltern</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>binomial_filter</operator>
      <operator>count_seconds</operator>
      <operator>info_smooth</operator>
      <operator>smooth_image</operator>
      <operator>sub_image</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>bit.hdev</name>
      <desc>Ausführen von bitweisen Operationen auf Skalaren</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.functions</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>bitflow.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_2boards.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (zwei Boards)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_2ports.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (zwei Kameras, Anschlusswechsel)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_2simultaneous.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (simultaner Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_cont.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (Parametrisierung, kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_lut.hdev</name>
      <desc>Setzen einer Look-Up Tabelle für das BitFlow-Interface</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_lut</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_lut</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>bitflow_simple.hdev</name>
      <desc>Verwenden des BitFlow-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>5.2.4</newinversion>
   </example>
   <example>
      <name>blended_mosaic.hdev</name>
      <desc>Erzeugen eines überblendeten sphärischen Mosaikbildes und den entsprechenden Cube Maps</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.match.point</method>
      <method>method.filter.points</method>
      <method>method.mosaic</method>
      <method>method.filter.general</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.align</method>
      <operator>cam_mat_to_cam_par</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>gen_cube_map_mosaic</operator>
      <operator>gen_radial_distortion_map</operator>
      <operator>gen_spherical_mosaic</operator>
      <operator>hom_mat2d_compose</operator>
      <operator>points_foerstner</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>stationary_camera_self_calibration</operator>
      <operator>tile_images_offset</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>board.hdev</name>
      <desc>Erkennen fehlender Lötpunkte in Bildern mit unterschiedlichem Lichteinfall</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <method>method.functions</method>
      <operator>area_center</operator>
      <operator>channels_to_image</operator>
      <operator>complement</operator>
      <operator>dev_display</operator>
      <operator>difference</operator>
      <operator>expand_gray</operator>
      <operator>expand_region</operator>
      <operator>fill_up</operator>
      <operator>get_system</operator>
      <operator>intersection</operator>
      <operator>mean_n</operator>
      <operator>read_image</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>board_components.hdev</name>
      <desc>Extrahieren von Platinenkomponenten aufgrund ihrer Höhe mit binokularem Stereo</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.calib</method>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>binocular_distance</operator>
      <operator>calibrate_cameras</operator>
      <operator>create_calib_data</operator>
      <operator>disp_caltab</operator>
      <operator>emphasize</operator>
      <operator>find_calib_object</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>gen_circle</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>get_domain</operator>
      <operator>intersection</operator>
      <operator>invert_image</operator>
      <operator>map_image</operator>
      <operator>moments_gray_plane</operator>
      <operator>scale_image</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>sub_image</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>board_segmentation_uncalib.hdev</name>
      <desc>Extrahieren von Platinenkomponenten aufgrund ihrer Höhe mit unkalibriertem binokularem Stereo</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>binocular_disparity</operator>
      <operator>compose3</operator>
      <operator>gen_binocular_proj_rectification</operator>
      <operator>gen_circle</operator>
      <operator>map_image</operator>
      <operator>match_fundamental_matrix_ransac</operator>
      <operator>opening</operator>
      <operator>points_harris</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>projective_trans_image</operator>
      <operator>projective_trans_pixel</operator>
      <operator>scale_image_max</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>bottle.hdev</name>
      <desc>Lesen von Zahlen auf einer Bierflasche</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.food</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <method>method.blob</method>
      <operator>area_center</operator>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>get_text_object</operator>
      <operator>get_text_result</operator>
      <operator>set_text_model_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>bottlet.hdev</name>
      <desc>Trainieren von Zahlen auf einer Bierflasche</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.food</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.error</method>
      <operator>append_ocr_trainf</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>dev_set_check</operator>
      <operator>dev_set_shape</operator>
      <operator>fill_up</operator>
      <operator>fill_up_shape</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>bundle_adjusted_mosaicking.hdev</name>
      <desc>Verwenden von Mosaicking mit Bündelausgleichung zum Vereinen von Teilbildern eines BGAs zu einem großen Bild</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <method>method.filter.points</method>
      <method>method.mosaic</method>
      <method>method.match.point</method>
      <method>method.visual</method>
      <operator>bundle_adjust_mosaic</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_bundle_adjusted_mosaic</operator>
      <operator>gen_image_const</operator>
      <operator>paint_region</operator>
      <operator>points_harris</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>tile_images_offset</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>calibrate_cameras_monocular.hdev</name>
      <desc>Bestimmen der Kameraparameter mit einer HALCON-Kalibrierplatte</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.measure.3D</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>clear_object_model_3d</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_pose</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_cameras_multiple_camera_setup.hdev</name>
      <desc>Kalibrieren eines Multi-View Stereoaufbaus</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>clear_camera_setup_model</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_camera_setup_param</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_camera_setup_param</operator>
      <operator>set_origin_pose</operator>
      <operator>write_camera_setup_model</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>calibrate_cameras_precision.hdev</name>
      <desc>Vergleichen der Kameramodelle 'division' und 'polynomial'</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>disp_caltab</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>calibrate_cameras_telecentric_tilt.hdev</name>
      <desc>Kalibrieren eines Aufbaus mit telezentrischem Tilt-Objektiv (Scheimpflug)</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <applarea>applarea.measure.2D</applarea>
      <method>method.calib</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>close_measure</operator>
      <operator>create_calib_data</operator>
      <operator>distance_pp</operator>
      <operator>find_calib_object</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>measure_pairs</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_cameras_telecentric_tilt_stereo.hdev</name>
      <desc>Kalibrieren eines Stereo Kameraaufbaus mit telezentrischen Tilt-Objektiven (Scheimpflug)</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <operator>calibrate_cameras</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>fit_surface_first_order</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_hand_eye_scara_moving_cam.hdev</name>
      <desc>Hand-Auge-Kalibrierung eines SCARA-Roboters mit bewegter Kamera</desc>
      <path>hdevelop/Calibration/Hand-Eye/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>calibrate_hand_eye</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>disp_caltab</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_pose</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>read_pose</operator>
      <operator>set_calib_data</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_hand_eye_scara_stationary_cam.hdev</name>
      <desc>Hand-Auge-Kalibrierung eines SCARA-Roboters mit fester Kamera</desc>
      <path>hdevelop/Calibration/Hand-Eye/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>calibrate_hand_eye</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>disp_caltab</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_pose</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>set_calib_data</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_hand_eye_scara_stationary_cam_approx.hdev</name>
      <desc>Näherungsweise Hand-Auge-Kalibrierung eines SCARA-Roboters mit fester Kamera</desc>
      <path>hdevelop/Calibration/Hand-Eye/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>set_origin_pose</operator>
      <operator>vector_to_pose</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_hand_eye_stationary_3d_sensor.hdev</name>
      <desc>Ausführen einer Hand-Auge-Kalibrierung für ein System mit statischem 3D-Sensor</desc>
      <path>hdevelop/Calibration/Hand-Eye/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>calibrate_hand_eye</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_surface_model</operator>
      <operator>get_calib_data</operator>
      <operator>pose_compose</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>query_calib_data_observ_indices</operator>
      <operator>refine_surface_model_pose</operator>
      <operator>set_calib_data</operator>
      <operator>set_calib_data_observ_pose</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>calibrate_sheet_of_light_3d_calib_object.hdev</name>
      <desc>Kalibrieren eines Lichtschnittsystems mit Hilfe eine 3D-Kalibrierobjektes</desc>
      <path>hdevelop/3D-Reconstruction/Sheet-Of-Light/</path>
      <industry>industry.aero</industry>
      <industry>industry.auto</industry>
      <industry>industry.ceram</industry>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <operator>affine_trans_object_model_3d</operator>
      <operator>calibrate_sheet_of_light</operator>
      <operator>clear_sheet_of_light_model</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>create_surface_model</operator>
      <operator>find_surface_model</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>sample_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>set_profile_sheet_of_light</operator>
      <operator>set_sheet_of_light_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>calibrate_sheet_of_light_calplate.hdev</name>
      <desc>Kalibrieren eines Lichtschnittsystems mit einer HALCON-Kalibrierplatte</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <method>method.laser</method>
      <operator>apply_sheet_of_light_calibration</operator>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>clear_sheet_of_light_model</operator>
      <operator>create_calib_data</operator>
      <operator>create_matrix</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_sheet_of_light_result</operator>
      <operator>get_value_matrix</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>measure_profile_sheet_of_light</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <operator>set_sheet_of_light_param</operator>
      <operator>svd_matrix</operator>
      <operator>transpose_matrix</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>calibration_aimdpm_1_2006.hdev</name>
      <desc>Ausführen einer Reflexionskalibrierung vor der Druckqualitätsprüfung von Datacodes</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <method>method.acqu</method>
      <method>method.metrol</method>
      <method>method.calib.radiom</method>
      <method>method.geom</method>
      <method>method.tuple</method>
      <operator>clear_bar_code_model</operator>
      <operator>close_framegrabber</operator>
      <operator>close_measure</operator>
      <operator>continue</operator>
      <operator>create_bar_code_model</operator>
      <operator>erosion_rectangle1</operator>
      <operator>find_bar_code</operator>
      <operator>fwrite_string</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_bar_code_object</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>measure_pairs</operator>
      <operator>open_file</operator>
      <operator>open_framegrabber</operator>
      <operator>overpaint_region</operator>
      <operator>projection_pl</operator>
      <operator>set_bar_code_param</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>camera_calibration_external.hdev</name>
      <desc>Messen von Positionen auf einer Schieblehre unter Verwendung einer Kamerakalibrierung</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.metrol</method>
      <method>method.roi</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>break</operator>
      <operator>calibrate_cameras</operator>
      <operator>caltab_points</operator>
      <operator>close_measure</operator>
      <operator>contour_to_world_plane_xld</operator>
      <operator>create_calib_data</operator>
      <operator>create_pose</operator>
      <operator>dev_close_inspect_ctrl</operator>
      <operator>disp_polygon</operator>
      <operator>distance_pp</operator>
      <operator>find_calib_object</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_region_polygon_filled</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>get_contour_xld</operator>
      <operator>get_mbutton</operator>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>hom_mat3d_translate_local</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>image_to_world_plane</operator>
      <operator>lines_gauss</operator>
      <operator>map_image</operator>
      <operator>measure_pairs</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>read_cam_par</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <operator>smallest_rectangle2</operator>
      <operator>tuple_mean</operator>
      <operator>write_pose</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>camera_calibration_internal.hdev</name>
      <desc>Kalibrieren und Speichern interner Kameraparameter</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.visual</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>write_cam_par</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>camera_calibration_multi_image.hdev</name>
      <desc>Kalibrieren der Kamera und Messen von Positionen auf einer Schieblehre</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.metrol</method>
      <method>method.trafo.wcoord</method>
      <method>method.tuple</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>close_measure</operator>
      <operator>create_calib_data</operator>
      <operator>distance_pp</operator>
      <operator>find_calib_object</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>measure_pairs</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <operator>tuple_deviation</operator>
      <operator>tuple_mean</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cancel_draw_result.hdev</name>
      <desc>Ermöglichen von nutzerdefinierten Aktionen nach Abbrechen einer draw-Operation</desc>
      <path>hdevelop/Graphics/Parameters/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.visual</method>
      <operator>catch</operator>
      <operator>dev_set_preferences</operator>
      <operator>endtry</operator>
      <operator>get_system</operator>
      <operator>set_system</operator>
      <operator>throw</operator>
      <operator>try</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>cbm_bin_switch.hdev</name>
      <desc>Auffinden eines Schalters und Testen der Schalterstellung mit komponentenbasiertem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <method>method.functions</method>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>difference</operator>
      <operator>disp_polygon</operator>
      <operator>disp_rectangle1</operator>
      <operator>find_component_model</operator>
      <operator>get_component_model_tree</operator>
      <operator>get_component_relations</operator>
      <operator>get_found_component_model</operator>
      <operator>get_mposition</operator>
      <operator>get_training_components</operator>
      <operator>if</operator>
      <operator>modify_component_relations</operator>
      <operator>train_model_components</operator>
      <operator>wait_seconds</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_caliper.hdev</name>
      <desc>Messen einer Zangenöffnung mit komponentenbasiertem Matching in einem perspektivisch verzerrten Bild</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.functions</method>
      <operator>affine_trans_point_3d</operator>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>dev_set_window_extents</operator>
      <operator>find_component_model</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>get_component_model_params</operator>
      <operator>get_component_model_tree</operator>
      <operator>get_component_relations</operator>
      <operator>get_found_component_model</operator>
      <operator>get_mposition</operator>
      <operator>get_shape_model_contours</operator>
      <operator>get_training_components</operator>
      <operator>if</operator>
      <operator>insert</operator>
      <operator>map_image</operator>
      <operator>modify_component_relations</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>read_image</operator>
      <operator>set_origin_pose</operator>
      <operator>train_model_components</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_dip_switch.hdev</name>
      <desc>Auffinden von Kippschaltern und Bestimmen der Schalterstellungen mit komponentenbasiertem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.electr</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.comp</method>
      <method>method.error</method>
      <method>method.functions</method>
      <method>method.visual</method>
      <operator>affine_trans_point_2d</operator>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>find_component_model</operator>
      <operator>gen_region_points</operator>
      <operator>get_component_model_tree</operator>
      <operator>get_component_relations</operator>
      <operator>get_found_component_model</operator>
      <operator>get_mposition</operator>
      <operator>get_training_components</operator>
      <operator>insert</operator>
      <operator>modify_component_relations</operator>
      <operator>read_image</operator>
      <operator>read_training_components</operator>
      <operator>train_model_components</operator>
      <operator>wait_seconds</operator>
      <operator>write_training_components</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_label_simple.hdev</name>
      <desc>Auffinden eines Schriftzugs mit komponentenbasiertem Matching</desc>
      <path>hdevelop/Matching/Component-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.comp</method>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>find_component_model</operator>
      <operator>gen_initial_components</operator>
      <operator>get_found_component_model</operator>
      <operator>get_system</operator>
      <operator>modify_component_relations</operator>
      <operator>set_system</operator>
      <operator>train_model_components</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_modules_simple.hdev</name>
      <desc>Auffinden von Modulen einer Platine mit komponentenbasiertem Matching</desc>
      <path>hdevelop/Matching/Component-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <operator>clear_component_model</operator>
      <operator>create_component_model</operator>
      <operator>find_component_model</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_found_component_model</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_param_visual.hdev</name>
      <desc>Analysieren von Parametern des komponentenbasierten Matchings</desc>
      <path>hdevelop/Matching/Component-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <method>method.error</method>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>close_framegrabber</operator>
      <operator>create_trained_component_model</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>find_component_model</operator>
      <operator>gen_initial_components</operator>
      <operator>get_component_model_tree</operator>
      <operator>get_component_relations</operator>
      <operator>get_found_component_model</operator>
      <operator>get_system</operator>
      <operator>get_training_components</operator>
      <operator>grab_image</operator>
      <operator>inspect_clustered_components</operator>
      <operator>modify_component_relations</operator>
      <operator>open_framegrabber</operator>
      <operator>read_training_components</operator>
      <operator>set_system</operator>
      <operator>train_model_components</operator>
      <operator>write_training_components</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_pipe_wrench.hdev</name>
      <desc>Auffinden einer Rohrzange, die aus zwei Komponenten besteht</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <method>method.tuple</method>
      <method>method.numeric</method>
      <method>method.functions</method>
      <operator>affine_trans_point_2d</operator>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>find_component_model</operator>
      <operator>gen_circle</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_component_model_tree</operator>
      <operator>get_component_relations</operator>
      <operator>get_found_component_model</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>get_training_components</operator>
      <operator>read_image</operator>
      <operator>train_model_components</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>wait_seconds</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_pipe_wrench_simple.hdev</name>
      <desc>Auffinden eines zusammengesetzten Objekts mit komponentenbasiertem Matching</desc>
      <path>hdevelop/Matching/Component-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.comp</method>
      <operator>clear_component_model</operator>
      <operator>clear_training_components</operator>
      <operator>create_trained_component_model</operator>
      <operator>find_component_model</operator>
      <operator>get_found_component_model</operator>
      <operator>get_training_components</operator>
      <operator>train_model_components</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cbm_sbm.hdev</name>
      <desc>Vergleichen von komponentenbasiertem Matching mit formbasiertem Matching</desc>
      <path>hdevelop/Matching/Component-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <operator>affine_trans_region</operator>
      <operator>clear_component_model</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>create_component_model</operator>
      <operator>create_shape_model</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>find_component_model</operator>
      <operator>find_shape_models</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_found_component_model</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>grab_image</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>query_all_colors</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>cfa_to_rgb.hdev</name>
      <desc>Konvertieren eines Bayer-Bildes (Farbfilterarray) in ein RGB Bild</desc>
      <path>hdevelop/Filters/Color/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.color</method>
      <operator>cfa_to_rgb</operator>
      <operator>decompose3</operator>
      <operator>gen_checker_region</operator>
      <operator>gen_grid_region</operator>
      <operator>gen_image_const</operator>
      <operator>move_region</operator>
      <operator>paint_gray</operator>
      <operator>sub_image</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>change_radial_distortion_contours_xld.hdev</name>
      <desc>Eliminieren radialer Verzeichnungen aus extrahierten Konturen</desc>
      <path>hdevelop/Calibration/Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_contours_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>change_radial_distortion_image.hdev</name>
      <desc>Eliminieren radialer Verzeichnungen aus einem Bild</desc>
      <path>hdevelop/Calibration/Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>change_radial_distortion_points.hdev</name>
      <desc>Korrigieren eines radial verzerrten Bildes</desc>
      <path>hdevelop/Calibration/Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>change_radial_distortion_points</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>char_threshold.hdev</name>
      <desc>Extrahieren von Schriftzeichen mit einer schwellwertbasierten Segmentierung</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.segm</method>
      <operator>char_threshold</operator>
      <operator>gen_region_histo</operator>
      <operator>gray_histo</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>check_blister.hdev</name>
      <desc>Überprüfen des Inhalts automatisch befüllter Blister</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.pharm</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.trafo.align</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>area_center</operator>
      <operator>closing_rectangle1</operator>
      <operator>difference</operator>
      <operator>min_max_gray</operator>
      <operator>orientation_region</operator>
      <operator>select_shape</operator>
      <operator>shape_trans</operator>
      <operator>var_threshold</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>check_blister_mixed.hdev</name>
      <desc>Überprüfen des Inhalts manuell befüllter Blister</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.pharm</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.classif</method>
      <operator>add_samples_image_class_gmm</operator>
      <operator>classify_image_class_gmm</operator>
      <operator>clear_class_gmm</operator>
      <operator>create_class_gmm</operator>
      <operator>hysteresis_threshold</operator>
      <operator>invert_image</operator>
      <operator>train_class_gmm</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>check_bottle_crate.hdev</name>
      <desc>Zählen der Flaschen in Getränkekästen</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>difference</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>check_difference.hdev</name>
      <desc>Pixelweises Vergleichen zweier Bilder</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.segm</method>
      <operator>add_noise_white</operator>
      <operator>affine_trans_image</operator>
      <operator>check_difference</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>scale_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>check_fish_stick_dimension.hdev</name>
      <desc>Messen der Größe von Fischstäbchen</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.food</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.segm</method>
      <operator>select_shape</operator>
      <operator>tuple_find</operator>
      <operator>tuple_remove</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>check_for_holes_sheet_of_light.hdev</name>
      <desc>Verwenden eines kalibrierten Lichtschnitt-Aufbaus zum Testen ob Löcher in Werkstücken korrekt vorhanden sind</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.inspect.surface</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.object3d</method>
      <method>method.match3d.surface</method>
      <method>method.laser</method>
      <operator>add_sample_class_knn</operator>
      <operator>affine_trans_point_3d</operator>
      <operator>circularity</operator>
      <operator>classify_class_knn</operator>
      <operator>connection_object_model_3d</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>distance_object_model_3d</operator>
      <operator>find_surface_model</operator>
      <operator>gen_object_model_3d_from_points</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>reset_sheet_of_light_model</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>set_params_class_knn</operator>
      <operator>set_profile_sheet_of_light</operator>
      <operator>set_sheet_of_light_param</operator>
      <operator>train_class_knn</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>check_hazelnut_wafers.hdev</name>
      <desc>Überprüfen der Qualität von Haselnusswaffeln</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.feat</method>
      <operator>area_holes</operator>
      <operator>binary_threshold</operator>
      <operator>rectangularity</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>check_smd_tilt.hdev</name>
      <desc>Überprüfen, ob SMDs verkippt sind</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.metrol</method>
      <method>method.funct1d</method>
      <operator>create_funct_1d_pairs</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_projection</operator>
      <operator>var_threshold</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>check_soft_cheese.hdev</name>
      <desc>Überprüfen des Inhalts von Schmelzkäsepackungen</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.inspect.complete</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.shape</method>
      <method>method.geom</method>
      <method>method.tuple</method>
      <operator>angle_lx</operator>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_models</operator>
      <operator>gen_region_polygon_filled</operator>
      <operator>get_shape_model_contours</operator>
      <operator>rgb1_to_gray</operator>
      <operator>tuple_remove</operator>
      <operator>tuple_sort_index</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>circles.hdev</name>
      <desc>Anpassen von Kreisen an gekrümmte Kontursegmente</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.blob</method>
      <method>method.visual</method>
      <operator>boundary</operator>
      <operator>clip_region_rel</operator>
      <operator>dilation_circle</operator>
      <operator>edges_sub_pix</operator>
      <operator>fast_threshold</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>reduce_domain</operator>
      <operator>segment_contours_xld</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>circular_barcode.hdev</name>
      <desc>Lesen eines ringförmig auf eine CD gedruckten Barcodes</desc>
      <path>hdevelop/Applications/Bar-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.visual</method>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <method>method.trafo.geom</method>
      <method>method.barcode</method>
      <method>method.morphol</method>
      <operator>clear_bar_code_model</operator>
      <operator>complement</operator>
      <operator>connection</operator>
      <operator>create_bar_code_model</operator>
      <operator>dev_display</operator>
      <operator>dev_set_window_extents</operator>
      <operator>find_bar_code</operator>
      <operator>invert_image</operator>
      <operator>polar_trans_image_ext</operator>
      <operator>polar_trans_region_inv</operator>
      <operator>select_shape</operator>
      <operator>set_bar_code_param</operator>
      <operator>shape_trans</operator>
      <operator>smallest_circle</operator>
      <operator>zoom_image_factor</operator>
      <operator>zoom_region</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>circularity.hdev</name>
      <desc>Berechnen der Rundheit von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>circularity</operator>
      <operator>select_shape</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>class_2dim_sup.hdev</name>
      <desc>Segmentieren eines Farbbildes mit zweidimensionalen Pixelklassifikatoren</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <operator>class_2dim_sup</operator>
      <operator>closing_circle</operator>
      <operator>decompose3</operator>
      <operator>draw_region</operator>
      <operator>histo_2dim</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>class_2dim_unsup.hdev</name>
      <desc>Segmentieren eines Farbbildes durch Clustering</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <operator>class_2dim_unsup</operator>
      <operator>decompose3</operator>
      <operator>median_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>class_ndim_box.hdev</name>
      <desc>Klassifizieren von Pixeln mit Hyperquadern</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <operator>class_ndim_box</operator>
      <operator>close_class_box</operator>
      <operator>create_class_box</operator>
      <operator>learn_ndim_box</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>class_ndim_norm.hdev</name>
      <desc>Klassifizieren von Pixeln mit Hyperkugeln</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <operator>class_ndim_norm</operator>
      <operator>gen_empty_region</operator>
      <operator>learn_ndim_norm</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>class_overlap.hdev</name>
      <desc>Klassifizieren zweidimensionaler Daten mit MLP</desc>
      <path>hdevelop/Classification/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.visual</method>
      <method>method.classif</method>
      <operator>add_noise_white</operator>
      <operator>add_sample_class_mlp</operator>
      <operator>classify_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>compose3</operator>
      <operator>create_class_mlp</operator>
      <operator>evaluate_class_mlp</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>get_region_points</operator>
      <operator>get_sample_num_class_mlp</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>train_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>class_overlap_gmm.hdev</name>
      <desc>Klassifizieren zweidimensionaler Daten mit GMM</desc>
      <path>hdevelop/Classification/Gaussian-Mixture-Models/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.visual</method>
      <method>method.classif</method>
      <operator>add_noise_white</operator>
      <operator>add_sample_class_gmm</operator>
      <operator>classify_class_gmm</operator>
      <operator>clear_class_gmm</operator>
      <operator>compose3</operator>
      <operator>create_class_gmm</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>get_region_points</operator>
      <operator>get_sample_num_class_gmm</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>train_class_gmm</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>class_overlap_svm.hdev</name>
      <desc>Klassifizieren zweidimensionaler Daten mit SVM</desc>
      <path>hdevelop/Classification/Support-Vector-Machines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.visual</method>
      <method>method.classif</method>
      <operator>add_noise_white</operator>
      <operator>add_sample_class_svm</operator>
      <operator>classify_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>create_class_svm</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>get_region_points</operator>
      <operator>get_sample_num_class_svm</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>train_class_svm</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>classify_bottle_mouth.hdev</name>
      <desc>Detektieren von Defekten am Flaschenhals mit Hilfe von Polartransformation und einem k-NN-Klassifikator mit automatisch ausgewählten Merkmalen</desc>
      <path>hdevelop/Classification/Feature-Selection/</path>
      <industry>industry.food</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.classif</method>
      <operator>add_sample_class_train_data</operator>
      <operator>classify_class_knn</operator>
      <operator>create_class_train_data</operator>
      <operator>gray_projections</operator>
      <operator>polar_trans_image_ext</operator>
      <operator>select_feature_set_knn</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>classify_characters_ocr.hdev</name>
      <desc>Lesen der Zeichen eines vortrainierten Fonts</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.blob</method>
      <method>method.ocr</method>
      <method>method.classif</method>
      <operator>clear_ocr_class_svm</operator>
      <operator>do_ocr_multi_class_svm</operator>
      <operator>file_exists</operator>
      <operator>read_ocr_class_svm</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>classify_citrus_fruits.hdev</name>
      <desc>Unterscheiden von Orangen und Zitronen mit GMM-basierter Klassifikation</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.food</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <method>method.feat</method>
      <method>method.blob</method>
      <method>method.visual</method>
      <operator>add_sample_class_gmm</operator>
      <operator>classify_class_gmm</operator>
      <operator>clear_class_gmm</operator>
      <operator>create_class_gmm</operator>
      <operator>train_class_gmm</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>classify_fuses_gmm_based_lut.hdev</name>
      <desc>Segmentieren von farbigen Sicherungen mit einem LUT-Klassifikator</desc>
      <path>hdevelop/Applications/Color-Inspection/</path>
      <industry>industry.electr</industry>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.color</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <operator>classify_image_class_lut</operator>
      <operator>clear_class_gmm</operator>
      <operator>clear_class_lut</operator>
      <operator>create_class_gmm</operator>
      <operator>create_class_lut_gmm</operator>
      <operator>train_class_gmm</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>classify_halogen_bulbs.hdev</name>
      <desc>Überprüfen von Halogenlampen mit SVM-basierter Klassifikation</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.classif</method>
      <method>method.feat</method>
      <operator>add_sample_class_svm</operator>
      <operator>classify_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>create_class_svm</operator>
      <operator>list_files</operator>
      <operator>moments_region_central_invar</operator>
      <operator>train_class_svm</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>classify_image_class_gmm.hdev</name>
      <desc>Segmentieren eines RGB Bildes mit einem GMM-basierten Klassifikator</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_gmm</operator>
      <operator>classify_image_class_gmm</operator>
      <operator>clear_class_gmm</operator>
      <operator>clear_samples_class_gmm</operator>
      <operator>create_class_gmm</operator>
      <operator>gen_rectangle1</operator>
      <operator>gen_rectangle2</operator>
      <operator>region_to_mean</operator>
      <operator>train_class_gmm</operator>
      <operator>union1</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>classify_image_class_knn.hdev</name>
      <desc>Segmentieren eines RGB Bildes mit einem k-NN-Klassifikator</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_knn</operator>
      <operator>classify_image_class_knn</operator>
      <operator>clear_class_knn</operator>
      <operator>create_class_knn</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>classify_image_class_lut.hdev</name>
      <desc>Vergleichen der benötigten Laufzeit für LUT-Klassifikatoren und konventionelle Klassifikatoren</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_gmm</operator>
      <operator>add_samples_image_class_knn</operator>
      <operator>add_samples_image_class_mlp</operator>
      <operator>add_samples_image_class_svm</operator>
      <operator>classify_image_class_gmm</operator>
      <operator>classify_image_class_knn</operator>
      <operator>classify_image_class_lut</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>classify_image_class_svm</operator>
      <operator>clear_class_gmm</operator>
      <operator>clear_class_knn</operator>
      <operator>clear_class_lut</operator>
      <operator>clear_class_mlp</operator>
      <operator>clear_class_svm</operator>
      <operator>create_class_gmm</operator>
      <operator>create_class_knn</operator>
      <operator>create_class_lut_gmm</operator>
      <operator>create_class_lut_knn</operator>
      <operator>create_class_lut_mlp</operator>
      <operator>create_class_lut_svm</operator>
      <operator>create_class_mlp</operator>
      <operator>create_class_svm</operator>
      <operator>train_class_gmm</operator>
      <operator>train_class_knn</operator>
      <operator>train_class_mlp</operator>
      <operator>train_class_svm</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>classify_image_class_mlp.hdev</name>
      <desc>Segmentieren eines RGB Bildes mit einem MLP-basierten Klassifikator</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_mlp</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>copy_obj</operator>
      <operator>create_class_mlp</operator>
      <operator>gen_rectangle1</operator>
      <operator>gen_rectangle2</operator>
      <operator>region_to_mean</operator>
      <operator>train_class_mlp</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>classify_image_class_svm.hdev</name>
      <desc>Segmentieren eines RGB Bildes mit einem SVM-basierten Klassifikator</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_svm</operator>
      <operator>classify_image_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>clear_samples_class_svm</operator>
      <operator>create_class_svm</operator>
      <operator>gen_rectangle1</operator>
      <operator>gen_rectangle2</operator>
      <operator>region_to_mean</operator>
      <operator>train_class_svm</operator>
      <operator>union1</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>classify_metal_parts.hdev</name>
      <desc>Unterscheiden von Metallteilen mit MLP-basierter Klassifikation</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.blob</method>
      <method>method.classif</method>
      <operator>add_sample_class_mlp</operator>
      <operator>classify_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>clear_samples_class_mlp</operator>
      <operator>create_class_mlp</operator>
      <operator>moments_region_central_invar</operator>
      <operator>roundness</operator>
      <operator>train_class_mlp</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>classify_metal_parts_ocr.hdev</name>
      <desc>Unterscheiden von Metallteilen mit MLP-basierter OCR-Klassifikation</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.ident.ocr</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.blob</method>
      <method>method.classif</method>
      <operator>append_ocr_trainf</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>classify_pills_auto_select_features.hdev</name>
      <desc>Klassifizieren von verschiedenen Pillensorten mit Hilfe eines SVM-Klassifikators mit automatisch ausgewählten Merkmalen</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.health</industry>
      <industry>industry.pharm</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <operator>add_sample_class_train_data</operator>
      <operator>classify_class_svm</operator>
      <operator>create_class_train_data</operator>
      <operator>select_feature_set_svm</operator>
      <operator>set_feature_lengths_class_train_data</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>classify_wood.hdev</name>
      <desc>Klassifizieren unterschiedlicher Holzarten aufgrund ihrer Oberflächentextur</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.wood</industry>
      <applarea>applarea.inspect.texture</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <method>method.texture</method>
      <method>method.tuple</method>
      <operator>add_sample_class_mlp</operator>
      <operator>classify_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>cooc_feature_image</operator>
      <operator>create_class_mlp</operator>
      <operator>entropy_gray</operator>
      <operator>file_exists</operator>
      <operator>gray_histo_abs</operator>
      <operator>list_files</operator>
      <operator>read_class_mlp</operator>
      <operator>sobel_amp</operator>
      <operator>train_class_mlp</operator>
      <operator>write_class_mlp</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>clip.hdev</name>
      <desc>Bestimmen der Position und Orientierung von Büroklammern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.blob</method>
      <method>method.visual</method>
      <operator>area_center</operator>
      <operator>binary_threshold</operator>
      <operator>dev_display</operator>
      <operator>dev_set_color</operator>
      <operator>dev_set_draw</operator>
      <operator>dev_set_line_width</operator>
      <operator>dev_update_window</operator>
      <operator>disp_arrow</operator>
      <operator>for</operator>
      <operator>orientation_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>clip_contours_xld.hdev</name>
      <desc>Beschneiden einer XLD Kontur</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>clip_contours_xld</operator>
      <operator>dev_close_window</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_part</operator>
      <operator>disp_arrow</operator>
      <operator>lines_gauss</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>clip_end_points_contours_xld.hdev</name>
      <desc>Verwenden der zwei Modi von clip_end_points_contours_xld</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>clip_end_points_contours_xld</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>clip_region.hdev</name>
      <desc>Zuschneiden von Regionen zu Rechtecken</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>clip_region</operator>
      <operator>get_system</operator>
      <operator>set_system</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>clip_region_rel.hdev</name>
      <desc>Zuschneiden von Regionen zu Rechtecken relativ zu ihrer Größe</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>clip_region_rel</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>close_contour_gaps.hdev</name>
      <desc>Schließen von Lücken in extrahierten geraden Konturen</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.metrol</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>dev_set_color</operator>
      <operator>edges_sub_pix</operator>
      <operator>mean_image</operator>
      <operator>paint_gray</operator>
      <operator>rectangle1_domain</operator>
      <operator>region_to_bin</operator>
      <operator>regress_contours_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>sort_contours_xld</operator>
      <operator>union_collinear_contours_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>close_contours_xld.hdev</name>
      <desc>Schließen von XLD Konturen</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>close_contours_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>select_contours_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>close_edges.hdev</name>
      <desc>Schließen von Lücken in Kanten unter Verwendung von Kantenamplitudenbildern</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.regionproc</method>
      <operator>close_edges</operator>
      <operator>sobel_amp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>close_edgeslength.hdev</name>
      <desc>Schließen von Lücken in Kanten unter Verwendung von Kantenamplitudenbildern</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.regionproc</method>
      <operator>close_edges_length</operator>
      <operator>sobel_amp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>closest_point_transform.hdev</name>
      <desc>Berechnen der Nächste-Punkte-Transformation einer Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <method>method.regionproc</method>
      <operator>closest_point_transform</operator>
      <operator>gen_circle</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>codabar.hdev</name>
      <desc>Lesen eines Barcodes vom Typ Codabar</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>code128.hdev</name>
      <desc>Lesen eines Barcodes vom Typ Code 128</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <newinversion>6.0.1</newinversion>
   </example>
   <example>
      <name>code32.hdev</name>
      <desc>Lesen eines Barcodes vom Typ Code 32</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>code39.hdev</name>
      <desc>Lesen eines Barcodes vom Typ Code 39</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_object</operator>
      <operator>get_bar_code_result</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>coherence_enhancing_diff.hdev</name>
      <desc>Verbessern des Bildes eines Fingerabdrucks</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.secure</industry>
      <applarea>applarea.security</applarea>
      <method>method.filter.general</method>
      <operator>coherence_enhancing_diff</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>color_fuses.hdev</name>
      <desc>Sortieren von Sicherungen aufgrund ihrer Farbe</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.auto</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.inspect.color</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <operator>decompose3</operator>
      <operator>trans_from_rgb</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>color_fuses_lut_trans.hdev</name>
      <desc>Klassifizieren von Sicherungen mit einer Farbraumtransformation</desc>
      <path>hdevelop/Applications/Color-Inspection/</path>
      <industry>industry.electr</industry>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.color</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <operator>apply_color_trans_lut</operator>
      <operator>create_color_trans_lut</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>color_pieces.hdev</name>
      <desc>Überprüfen der Vollständigkeit von farbigen Spielsteinen mit MLP-basierter Klassifikation</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.color</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <method>method.classif</method>
      <operator>add_samples_image_class_mlp</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>compose3</operator>
      <operator>copy_obj</operator>
      <operator>create_class_mlp</operator>
      <operator>draw_rectangle1</operator>
      <operator>rgb1_to_gray</operator>
      <operator>train_class_mlp</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>color_pieces_euclid.hdev</name>
      <desc>Überprüfen der Vollständigkeit von farbigen Spielsteinen mit euklidischer Klassifikation</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.color</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <method>method.classif</method>
      <operator>class_ndim_norm</operator>
      <operator>compose3</operator>
      <operator>draw_rectangle1</operator>
      <operator>gen_empty_region</operator>
      <operator>learn_ndim_norm</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>color_segmentation_pizza.hdev</name>
      <desc>Segmentieren von Salamischeiben auf Pizza mit Farbverarbeitung</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>closing_circle</operator>
      <operator>connection</operator>
      <operator>decompose3</operator>
      <operator>opening_circle</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape</operator>
      <operator>select_shape_std</operator>
      <operator>shape_trans</operator>
      <operator>threshold</operator>
      <operator>trans_from_rgb</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>color_simple.hdev</name>
      <desc>Segmentieren eines Farbbildes im HSV Farbraum</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.inspect.color</applarea>
      <method>method.color</method>
      <method>method.blob</method>
      <operator>closing_circle</operator>
      <operator>decompose3</operator>
      <operator>read_image</operator>
      <operator>select_shape_std</operator>
      <operator>trans_from_rgb</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>color_trans_lut.hdev</name>
      <desc>Vergleichen der Laufzeiten für Farbraumtransformationen mit und ohne Look-Up Tabelle</desc>
      <path>hdevelop/Filters/Color/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <operator>apply_color_trans_lut</operator>
      <operator>clear_color_trans_lut</operator>
      <operator>count_seconds</operator>
      <operator>create_color_trans_lut</operator>
      <operator>get_param_info</operator>
      <operator>trans_from_rgb</operator>
      <operator>trans_to_rgb</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>comment.hdev</name>
      <desc>Verwenden von Kommentaren und Code-Export für beliebigen Text</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>comment</operator>
      <operator>stop</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>compactness.hdev</name>
      <desc>Berechnen der Kompaktheit von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>compactness</operator>
      <operator>regiongrowing</operator>
      <operator>select_shape</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>compare.hdev</name>
      <desc>Vergleichen von Skalaren, Tupeln und Zeichenketten</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.functions</method>
      <method>method.tuple</method>
      <method>method.string</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>compare_calibration_models.hdev</name>
      <desc>Vergleichen der Ergebnisse der Kamerakalibrierung mit verschiedenen Kameramodellen</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <operator>caltab_points</operator>
      <operator>find_calib_object</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>compare_gauss_filters.hdev</name>
      <desc>Vergleichen der Gauß-Glättungsfilter gauss_filter, binomial_filter, derivate_gauss und smooth_image</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>binomial_filter</operator>
      <operator>derivate_gauss</operator>
      <operator>gauss_filter</operator>
      <operator>get_operator_info</operator>
      <operator>get_param_info</operator>
      <operator>gray_projections</operator>
      <operator>smooth_image</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>compare_obj.hdev</name>
      <desc>Vergleichen von ikonischen Objekten mit compare_obj und test_equal_obj</desc>
      <path>hdevelop/Object/Information/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>compare_obj</operator>
      <operator>test_equal_obj</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>compare_ocr_svm_mlp.hdev</name>
      <desc>Vergleichen der Erkennungsrate und der Geschwindigkeit des Trainings und der Klassifikation mit SVM und MLP</desc>
      <path>hdevelop/OCR/Support-Vector-Machines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.classif</method>
      <operator>add_image</operator>
      <operator>add_noise_white</operator>
      <operator>affine_trans_image</operator>
      <operator>append_ocr_trainf</operator>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clear_ocr_class_svm</operator>
      <operator>count_seconds</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>create_ocr_class_svm</operator>
      <operator>delete_file</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>do_ocr_single_class_svm</operator>
      <operator>expand_domain_gray</operator>
      <operator>file_exists</operator>
      <operator>full_domain</operator>
      <operator>gen_image_proto</operator>
      <operator>get_support_vector_num_ocr_class_svm</operator>
      <operator>gray_dilation_shape</operator>
      <operator>gray_erosion_shape</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>intersection</operator>
      <operator>read_ocr_trainf</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>reduce_ocr_class_svm</operator>
      <operator>rotate_image</operator>
      <operator>scale_image</operator>
      <operator>smooth_image</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>trainf_ocr_class_svm</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>compare_surface_sheet_of_light.hdev</name>
      <desc>Verwenden eines unkalibrierten Lichtschnitt-Aufbaus zum 3D-Oberflächenvergleich</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.inspect.surface</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.object3d</method>
      <method>method.match3d.surface</method>
      <method>method.laser</method>
      <operator>clear_object_model_3d</operator>
      <operator>clear_sheet_of_light_model</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>create_surface_model</operator>
      <operator>distance_object_model_3d</operator>
      <operator>find_surface_model</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>reset_sheet_of_light_model</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>sample_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>set_profile_sheet_of_light</operator>
      <operator>set_sheet_of_light_param</operator>
      <operator>surface_normals_object_model_3d</operator>
      <operator>triangulate_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>compose_funct_1d.hdev</name>
      <desc>Zusammensetzen und Plotten von 1D Funktionen und Überprüfen der Ergebnisse</desc>
      <path>hdevelop/Tools/Function/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.numeric</method>
      <method>method.funct1d</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>compose_funct_1d</operator>
      <operator>create_funct_1d_pairs</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>composite_print_quality_isoiec15416.hdev</name>
      <desc>Überprüfen der Druckqualität von kompositen Barcodes (isoiec15416)</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <method>method.visual</method>
      <method>method.filter.general</method>
      <operator>add_image</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <operator>gray_dilation_shape</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>compute_devices.hdev</name>
      <desc>Verwenden von Compute Devices in HALCON</desc>
      <path>hdevelop/System/Compute-Devices/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.opsys</method>
      <method>method.trafo.geom</method>
      <operator>activate_compute_device</operator>
      <operator>deactivate_compute_device</operator>
      <operator>get_compute_device_info</operator>
      <operator>init_compute_device</operator>
      <operator>open_compute_device</operator>
      <operator>query_available_compute_devices</operator>
      <operator>set_compute_device_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>connect_and_holes.hdev</name>
      <desc>Berechnen der Anzahl von zusammenhängenden Komponenten und Löchern von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>complement</operator>
      <operator>connect_and_holes</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>connection.hdev</name>
      <desc>Berechnen der zusammenhängenden Komponenten von Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.feat</method>
      <operator>connection</operator>
      <operator>fill_up</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>connection_object_model_3d.hdev</name>
      <desc>Berechnen der zusammenhängenden Komponenten von 3D-Objektmodellen</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>connection_object_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>contec_digital_read.hdev</name>
      <desc>Verwenden des Contec-Interfaces (einfaches Lesen der digitalen Eingänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>contec_digital_write.hdev</name>
      <desc>Verwenden des Contec-Interfaces (einfaches Schreiben der digitalen Ausgänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>write_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>contlength.hdev</name>
      <desc>Berechnen der Konturlängen von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>contlength</operator>
      <operator>regiongrowing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>convert_map_type.hdev</name>
      <desc>Konvertieren eines Abbildungstyps</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <operator>convert_map_type</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>convexity.hdev</name>
      <desc>Berechnen der Konvexität von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>convexity</operator>
      <operator>regiongrowing</operator>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>cooc_feature_image.hdev</name>
      <desc>Berechnen von Texturmerkmalen, die auf einer Co-Occurence-Matrix basieren</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.feat</method>
      <method>method.texture</method>
      <operator>cooc_feature_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>cooc_feature_matrix.hdev</name>
      <desc>Berechnen einer Co-Occurence-Matrix und Ableiten von Texturmerkmalen</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.feat</method>
      <method>method.texture</method>
      <operator>cooc_feature_matrix</operator>
      <operator>dev_set_lut</operator>
      <operator>gen_cooc_matrix</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>corner_response.hdev</name>
      <desc>Extrahieren von Ecken aus Bildern</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.filter.points</method>
      <operator>corner_response</operator>
      <operator>sobel_amp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>correct_measure_direction.hdev</name>
      <desc>Automatisches Korrigieren der Orientierung eines Messobjekts</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.alignment</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>draw_rectangle2_mod</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_contour_angle_xld</operator>
      <operator>measure_pairs</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>count_fish_sticks.hdev</name>
      <desc>Überprüfen von Fischstäbchen auf Vollständigkeit</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.funct1d</method>
      <method>method.metrol</method>
      <operator>create_funct_1d_array</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_image_size</operator>
      <operator>local_min_max_funct_1d</operator>
      <operator>measure_projection</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>count_pellets.hdev</name>
      <desc>Erkennen von Pellets mit Morphologie</desc>
      <path>hdevelop/Morphology/Region/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.regionproc</method>
      <operator>binary_threshold</operator>
      <operator>dilation_circle</operator>
      <operator>erosion_circle</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_average_shape_model.hdev</name>
      <desc>Erzeugen eines Formmodells aus einem gemittelten Bild</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.trafo.geom</method>
      <method>method.image</method>
      <operator>channels_to_image</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>mean_n</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_drawing_object_circle_sector.hdev</name>
      <desc>Interaktives Erkennen von Kanten innerhalb eines Kreisausschnitts mit Hilfe eines Zeichenobjekts</desc>
      <path>hdevelop/Graphics/Object/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.xld</method>
      <method>method.filter.edge</method>
      <operator>attach_background_to_window</operator>
      <operator>attach_drawing_object_to_window</operator>
      <operator>clear_drawing_object</operator>
      <operator>create_drawing_object_circle_sector</operator>
      <operator>create_drawing_object_text</operator>
      <operator>detach_background_from_window</operator>
      <operator>detach_drawing_object_from_window</operator>
      <operator>get_drawing_object_iconic</operator>
      <operator>set_drawing_object_params</operator>
      <operator>sobel_amp</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>create_drawing_object_rectangle2.hdev</name>
      <desc>Interaktives Messen von geraden Kanten innerhalb eines Rechtecks mit Hilfe eines Zeichenobjekts</desc>
      <path>hdevelop/Graphics/Object/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.xld</method>
      <method>method.metrol</method>
      <operator>attach_background_to_window</operator>
      <operator>attach_drawing_object_to_window</operator>
      <operator>clear_drawing_object</operator>
      <operator>create_drawing_object_rectangle2</operator>
      <operator>create_drawing_object_text</operator>
      <operator>detach_background_from_window</operator>
      <operator>detach_drawing_object_from_window</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_drawing_object_params</operator>
      <operator>measure_pos</operator>
      <operator>set_drawing_object_params</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>create_high_dynamic_range_image.hdev</name>
      <desc>Erstellen von High-Dynamic-Range-Bildern (HDR) aus je zwei Byte-Bildern mit Hilfe von Gradient-Domain-Filterung</desc>
      <path>hdevelop/Applications/General/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>reconstruct_height_field_from_gradient</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>create_local_deformable_model_xld.hdev</name>
      <desc>Erzeugen eines lokal deformierbaren Modells aus XLD Konturen</desc>
      <path>hdevelop/Matching/Deformable/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.deform</method>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.morphol</method>
      <method>method.segm</method>
      <method>method.trafo.geom</method>
      <method>method.xld</method>
      <method>method.typeconv.ico</method>
      <operator>create_local_deformable_model_xld</operator>
      <operator>find_local_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>set_local_deformable_model_metric</operator>
      <operator>unwarp_image_vector_field</operator>
      <operator>vector_field_length</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_model_green_dot.hdev</name>
      <desc>Erzeugen eines Formmodells für das skalierbare formbasierte Matching</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <operator>clear_shape_model</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>inspect_shape_model</operator>
      <operator>write_shape_model</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>create_planar_calib_deformable_model_xld.hdev</name>
      <desc>Erzeugen eines kalibrierten, perspektivisch deformierbaren Modells aus Konturen einer DXF Datei</desc>
      <path>hdevelop/Matching/Deformable/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match.deform</method>
      <method>method.trafo.wcoord</method>
      <method>method.poseestim</method>
      <method>method.xld</method>
      <operator>clear_deformable_model</operator>
      <operator>create_planar_calib_deformable_model_xld</operator>
      <operator>find_planar_calib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>read_contour_xld_dxf</operator>
      <operator>set_deformable_model_origin</operator>
      <operator>set_planar_calib_deformable_model_metric</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_planar_uncalib_deformable_model_xld.hdev</name>
      <desc>Erzeugen eines unkalibrierten, perspektivisch deformierbaren Modells aus Konturen einer DXF Datei</desc>
      <path>hdevelop/Matching/Deformable/</path>
      <industry>industry.auto</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.deform</method>
      <operator>clear_deformable_model</operator>
      <operator>create_planar_uncalib_deformable_model_xld</operator>
      <operator>find_planar_uncalib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>get_deformable_model_params</operator>
      <operator>projective_trans_contour_xld</operator>
      <operator>read_contour_xld_dxf</operator>
      <operator>set_planar_uncalib_deformable_model_metric</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_roi_via_vision.hdev</name>
      <desc>Erzeugen einer Formmodell-ROI mittels Blob-Analyse</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.match.shape</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>connection</operator>
      <operator>create_shape_model</operator>
      <operator>dilation_circle</operator>
      <operator>fill_up</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>reduce_domain</operator>
      <operator>threshold</operator>
      <operator>union1</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>create_shape_model_3d_ignore_part_polarity.hdev</name>
      <desc>Beschleunigen des formbasierten 3D-Matchings vor texturiertem Hintergrund</desc>
      <path>hdevelop/3D-Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.shape</method>
      <method>method.poseestim</method>
      <operator>clear_object_model_3d</operator>
      <operator>clear_shape_model_3d</operator>
      <operator>create_shape_model_3d</operator>
      <operator>find_shape_model_3d</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_shape_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>read_shape_model_3d</operator>
      <operator>write_shape_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_shape_model_3d_lowest_model_level.hdev</name>
      <desc>Minimieren des Speicherbedarfs eines 3D-Formmodells</desc>
      <path>hdevelop/3D-Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.shape</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <operator>clear_object_model_3d</operator>
      <operator>clear_shape_model_3d</operator>
      <operator>create_shape_model_3d</operator>
      <operator>find_shape_model_3d</operator>
      <operator>get_shape_model_3d_params</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_shape_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>read_shape_model_3d</operator>
      <operator>write_shape_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>create_shape_model_xld.hdev</name>
      <desc>Erzeugen von Formmodellen aus XLD Konturen</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.functions</method>
      <operator>area_center_xld</operator>
      <operator>create_shape_model_xld</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_params</operator>
      <operator>line_orientation</operator>
      <operator>orientation_xld</operator>
      <operator>polar_trans_image_ext</operator>
      <operator>set_shape_model_metric</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>create_template_rot.hdev</name>
      <desc>Finden des besten Matches (mit Rotation) zu einem Grauwerttemplate</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_rot</operator>
      <operator>create_template_rot</operator>
      <operator>fill_interlace</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>set_reference_template</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>crevis.hdev</name>
      <desc>Verwenden des Crevis-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>crevis_binning.hdev</name>
      <desc>Verwenden des Crevis-Interfaces (HRS 1/4 binning mode)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>crevis_parameters.hdev</name>
      <desc>Verwenden des Crevis-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>crevis_simple.hdev</name>
      <desc>Verwenden des Crevis-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>crevis_trigger.hdev</name>
      <desc>Verwenden des Crevis-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.1</newinversion>
   </example>
   <example>
      <name>critical_points.hdev</name>
      <desc>Auffinden von Sattelpunkten in einem Bild</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.filter.general</method>
      <method>method.xld</method>
      <operator>critical_points_sub_pix</operator>
      <operator>draw_region</operator>
      <operator>gen_cross_contour_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>critical_points_sub_pix.hdev</name>
      <desc>Erkennen kritischer Punkte mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <method>method.visual</method>
      <operator>critical_points_sub_pix</operator>
      <operator>derivate_gauss</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_part</operator>
      <operator>disp_arrow</operator>
      <operator>disp_rectangle1</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>tuple_concat</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>crop_contours_xld.hdev</name>
      <desc>Beschneiden einer XLD Kontur</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>crop_contours_xld</operator>
      <operator>disp_arrow</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>lines_gauss</operator>
      <operator>union2</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>crystal.hdev</name>
      <desc>Extrahieren hexagonal geformter Kristalle mit lokalem Schwellwert und Regionennachbearbeitung</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <operator>connection</operator>
      <operator>dyn_threshold</operator>
      <operator>mean_image</operator>
      <operator>select_gray</operator>
      <operator>shape_trans</operator>
      <operator>stop</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>dahengcam.hdev</name>
      <desc>Verwenden des DahengCAM-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>gen_struct_elements</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>dahengcam_2cameras.hdev</name>
      <desc>Verwenden des DahengCAM-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>dahengcam_parameters.hdev</name>
      <desc>Verwenden des DahengCAM-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>dahengcam_simple.hdev</name>
      <desc>Verwenden des DahengCAM-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>decode_bar_code_rectangle2.hdev</name>
      <desc>Dekodieren eines Barcodes in einer rechteckigen Region</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>decode_bar_code_rectangle2</operator>
      <operator>get_bar_code_object</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>defect_barcode.hdev</name>
      <desc>Lesen von defekten Barcodes</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <method>method.error</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_bar_code_object</operator>
      <operator>paint_region</operator>
      <operator>set_bar_code_param</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.1.1</newinversion>
   </example>
   <example>
      <name>dem.hdev</name>
      <desc>Extrahieren hoher Objekte aus einem Digitalen Höhenmodell</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>crop_part</operator>
      <operator>dev_display</operator>
      <operator>dev_set_lut</operator>
      <operator>dev_set_paint</operator>
      <operator>dual_rank</operator>
      <operator>scale_image_max</operator>
      <operator>sub_image</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dem_trees.hdev</name>
      <desc>Extrahieren von Bäumen unter Verwendung von Textur und einem Digitalen Höhenmodell</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.texture</method>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>clip_region</operator>
      <operator>closing_circle</operator>
      <operator>dual_rank</operator>
      <operator>fill_up</operator>
      <operator>intersection</operator>
      <operator>median_separate</operator>
      <operator>move_region</operator>
      <operator>scale_image_max</operator>
      <operator>sub_image</operator>
      <operator>texture_laws</operator>
      <operator>threshold</operator>
      <operator>zoom_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>depth_from_focus.hdev</name>
      <desc>Extrahieren von Tiefendaten unter Verwendung von multiplen Fokusebenen</desc>
      <path>hdevelop/3D-Reconstruction/Depth-From-Focus/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.dff</method>
      <method>method.image</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>access_channel</operator>
      <operator>channels_to_image</operator>
      <operator>depth_from_focus</operator>
      <operator>dev_set_paint</operator>
      <operator>mean_image</operator>
      <operator>scale_image_max</operator>
      <operator>select_grayvalues_from_channels</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>derivate_gauss.hdev</name>
      <desc>Falten eines Bildes mit Ableitungen der Gaußfunktion (verschiedene Anwendungen)</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>convert_image_type</operator>
      <operator>derivate_gauss</operator>
      <operator>watersheds</operator>
      <operator>zero_crossing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>detect_brochure_pages.hdev</name>
      <desc>Finden von Artikelseiten in einer Bilderdatenbank</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.paper</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.descr</method>
      <method>method.geom</method>
      <operator>angle_ll</operator>
      <operator>clear_descriptor_model</operator>
      <operator>create_uncalib_descriptor_model</operator>
      <operator>find_uncalib_descriptor_model</operator>
      <operator>get_descriptor_model_points</operator>
      <operator>projective_trans_pixel</operator>
      <operator>projective_trans_region</operator>
      <operator>set_descriptor_model_origin</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>detect_indent_fft.hdev</name>
      <desc>Erkennen von Defekten auf der Oberfläche von Gegenständen aus Plastik</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.morphol</method>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <operator>convol_fft</operator>
      <operator>gen_gauss_filter</operator>
      <operator>gray_range_rect</operator>
      <operator>optimize_rft_speed</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>detect_mura_defects_blur.hdev</name>
      <desc>Erkennen von Mura-Defekten in unscharfen Bildern</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <method>method.trafo.geom</method>
      <operator>convol_fft</operator>
      <operator>gen_gauss_filter</operator>
      <operator>lines_gauss</operator>
      <operator>rft_generic</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>detect_mura_defects_texture.hdev</name>
      <desc>Erkennen von Mura-Defekten in stark texturierten Bildern</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.filter.general</method>
      <method>method.fft</method>
      <method>method.texture</method>
      <method>method.tuple</method>
      <operator>convol_fft</operator>
      <operator>cooc_feature_image</operator>
      <operator>gen_gauss_filter</operator>
      <operator>rft_generic</operator>
      <operator>tuple_find</operator>
      <operator>watersheds_threshold</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>detect_road_signs.hdev</name>
      <desc>Erkennen von Verkehrsschildern</desc>
      <path>hdevelop/Applications/Traffic-Monitoring/</path>
      <industry>industry.transp</industry>
      <applarea>applarea.traffic</applarea>
      <method>method.match.deform</method>
      <method>method.trafo.geom</method>
      <operator>access_channel</operator>
      <operator>clear_deformable_model</operator>
      <operator>create_planar_uncalib_deformable_model</operator>
      <operator>find_planar_uncalib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>get_deformable_model_params</operator>
      <operator>inspect_shape_model</operator>
      <operator>projective_trans_contour_xld</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>determine_die_pitch_fft_correlation.hdev</name>
      <desc>Auffinden von Dies auf einem Wafer</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.fft</method>
      <operator>correlation_fft</operator>
      <operator>local_max_sub_pix</operator>
      <operator>rft_generic</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>determine_grid_rotation_fft.hdev</name>
      <desc>Bestimmen des Rotationswinkels eines Gitters</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.fft</method>
      <method>method.funct1d</method>
      <method>method.visual</method>
      <operator>correlation_fft</operator>
      <operator>gen_region_polygon_filled</operator>
      <operator>get_y_value_funct_1d</operator>
      <operator>gray_histo_range</operator>
      <operator>local_min_max_funct_1d</operator>
      <operator>optimize_fft_speed</operator>
      <operator>rft_generic</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>determine_ncc_model_params.hdev</name>
      <desc>Bestimmen der Parameter für korrelationsbasiertes Matching</desc>
      <path>hdevelop/Matching/Correlation-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.correl</method>
      <operator>determine_ncc_model_params</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>determine_pose_square_tube.hdev</name>
      <desc>Schätzen der 3D-Pose eines rechteckigen Objekts</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.xld</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.wcoord</method>
      <operator>affine_trans_point_3d</operator>
      <operator>area_center_points_xld</operator>
      <operator>close_contours_xld</operator>
      <operator>get_rectangle_pose</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>tuple_atan2</operator>
      <operator>union_adjacent_contours_xld</operator>
      <operator>union_collinear_contours_xld</operator>
      <operator>vector_to_pose</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>determine_rotation_almost_rotationally_symmetric_objects.hdev</name>
      <desc>Bestimmen der Rotation eines fast rotationssymmetrischen Objektes mit formbasiertem Matching und Polartransformation</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.trafo.geom</method>
      <operator>angle_lx</operator>
      <operator>draw_polygon</operator>
      <operator>find_shape_model</operator>
      <operator>polar_trans_contour_xld_inv</operator>
      <operator>polar_trans_image_ext</operator>
      <operator>polar_trans_region</operator>
      <operator>set_shape_model_origin</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>determine_sharpness.hdev</name>
      <desc>Messen der Bildschärfe</desc>
      <path>hdevelop/Applications/General/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <method>method.funct1d</method>
      <operator>abs_image</operator>
      <operator>convert_image_type</operator>
      <operator>correlation_fft</operator>
      <operator>power_real</operator>
      <operator>rft_generic</operator>
      <operator>tile_images_offset</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>determine_tilt_slant_photometric_stereo.hdev</name>
      <desc>Bestimmen der Orientierung der Lichtquellen eines Photometric-Stereo-Aufbaus</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.stereo.phot</method>
      <method>method.numeric</method>
      <operator>clear_matrix</operator>
      <operator>create_matrix</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>gen_image_surface_second_order</operator>
      <operator>get_grayval</operator>
      <operator>get_region_points</operator>
      <operator>get_value_matrix</operator>
      <operator>mult_matrix</operator>
      <operator>svd_matrix</operator>
      <operator>transpose_matrix</operator>
      <operator>tuple_atan2</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>determine_wafer_rotation_angle.hdev</name>
      <desc>Bestimmen des Rotationswinkels eines Wafers mit text_line_orientation</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.general</method>
      <operator>text_line_orientation</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>dev_clear_window.hdev</name>
      <desc>Löschen eines Grafikfensters in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_clear_window</operator>
      <operator>dev_update_window</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_close_inspect_ctrl.hdev</name>
      <desc>Schließen eines Variableninspektionsfensters in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>dev_close_inspect_ctrl</operator>
      <operator>dev_inspect_ctrl</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_close_window.hdev</name>
      <desc>Schließen eines Grafikfensters in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_close_window</operator>
      <operator>dev_open_window</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_display.hdev</name>
      <desc>Anzeigen von Bildobjekten in Grafikfenstern in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_clear_window</operator>
      <operator>dev_display</operator>
      <operator>dev_set_colored</operator>
      <operator>dev_set_draw</operator>
      <operator>read_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_error_var.hdev</name>
      <desc>Abfangen von Fehlern in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.file</method>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_inspect_ctrl.hdev</name>
      <desc>Verwenden eines Variableninspektionsfensters in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>dev_inspect_ctrl</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_map_par.hdev</name>
      <desc>Öffnen des Fensters zur Parameteranpassung für die Anzeige in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_map_par</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_open_dialog.hdev</name>
      <desc>Öffnen von modalen Dialogen in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_open_dialog</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>dev_open_file_selection_dialog.hdev</name>
      <desc>Öffnen von modalen Dialogen zum Lesen und Schreiben von Dateien oder einem Verzeichnis in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_open_file_dialog</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>dev_open_tool.hdev</name>
      <desc>Öffnen und Anpassen von Tools in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_close_tool</operator>
      <operator>dev_open_tool</operator>
      <operator>dev_set_tool_geometry</operator>
      <operator>dev_show_tool</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>dev_open_window.hdev</name>
      <desc>Öffnen von Grafikfenstern in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_close_window</operator>
      <operator>dev_display</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_lut</operator>
      <operator>dev_set_part</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_set_check.hdev</name>
      <desc>An- und Abschalten der Möglichkeit zur Fehlerbehandlung in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.file</method>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_set_paint.hdev</name>
      <desc>Einzeichnen von Daten in ein Grafikfenster in HDevelop (verschiedene Repräsentationen)</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>dev_set_lut</operator>
      <operator>dev_set_paint</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_set_part.hdev</name>
      <desc>Setzen des in einem Grafikfenster in HDevelop anzuzeigenden Bildausschnitts</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_display</operator>
      <operator>dev_set_part</operator>
      <operator>dev_set_window_extents</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dev_set_window_extents.hdev</name>
      <desc>Setzen der Größe und Position eines Grafikfensters in HDevelop</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>dev_set_window_extents</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>diameter_region.hdev</name>
      <desc>Berechnen der Durchmesser von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>diameter_region</operator>
      <operator>disp_line</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>diff_of_gauss.hdev</name>
      <desc>Approximieren des LoG Operators (Laplace of Gaussian)</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>derivate_gauss</operator>
      <operator>diff_of_gauss</operator>
      <operator>laplace_of_gauss</operator>
      <operator>zero_crossing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>difference_closed_contours_xld.hdev</name>
      <desc>Verwenden von difference_closed_contours_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>difference_closed_contours_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>difference_closed_polygons_xld.hdev</name>
      <desc>Verwenden von difference_closed_polygons_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>difference_closed_polygons_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_polygons_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>directfile.hdev</name>
      <desc>Verwenden des File-Interfaces (Einzelbild)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>directshow.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_2cameras.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_camera_types.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (Abfragen und Verwenden aller unterstützter Kameratypen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_str_last_n</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_exposure.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (Verwenden von 'exposure')</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_frame_rates.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (frame rate)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_parameters.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>directshow_simple.hdev</name>
      <desc>Verwenden des DirectShow-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>disp_object_model_3d.hdev</name>
      <desc>Anzeigen von 3D-Objektmodellen</desc>
      <path>hdevelop/Graphics/Output/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>disp_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>render_object_model_3d</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>disp_xld.hdev</name>
      <desc>Anzeigen eines XLD-Objekts</desc>
      <path>hdevelop/Graphics/Output/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.edgeextr</method>
      <method>method.filter.edge</method>
      <method>method.xld</method>
      <operator>disp_xld</operator>
      <operator>edges_image</operator>
      <operator>edges_sub_pix</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>disparity.hdev</name>
      <desc>Anzeigen von Disparitätsbildern für unterschiedliche Stereobildpaare</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>disparity_image_to_xyz.hdev</name>
      <desc>Transformieren eines Disparitätsbildes in X, Y, und Z Bilder</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.stereo</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>binocular_disparity</operator>
      <operator>disparity_image_to_xyz</operator>
      <operator>full_domain</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>harmonic_interpolation</operator>
      <operator>map_image</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>disparity_to_point_3d.hdev</name>
      <desc>Rekonstruieren von 3D-Information aus Disparitäten</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.geom</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>caltab_points</operator>
      <operator>create_pose</operator>
      <operator>disparity_to_distance</operator>
      <operator>disparity_to_point_3d</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>sim_caltab</operator>
      <operator>tuple_sub</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>display_operators.hdev</name>
      <desc>Visualisieren von Ergebnissen</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>area_center</operator>
      <operator>dev_clear_window</operator>
      <operator>dev_close_window</operator>
      <operator>dev_display</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_color</operator>
      <operator>dev_set_colored</operator>
      <operator>dev_set_draw</operator>
      <operator>dev_set_line_width</operator>
      <operator>dev_set_lut</operator>
      <operator>dev_set_paint</operator>
      <operator>dev_set_part</operator>
      <operator>dev_set_shape</operator>
      <operator>dev_set_window</operator>
      <operator>dev_update_pc</operator>
      <operator>dev_update_var</operator>
      <operator>dev_update_window</operator>
      <operator>edges_sub_pix</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_contour_xld</operator>
      <operator>get_image_size</operator>
      <operator>get_mbutton</operator>
      <operator>read_image</operator>
      <operator>regiongrowing</operator>
      <operator>select_region_point</operator>
      <operator>select_shape_xld</operator>
      <operator>set_tposition</operator>
      <operator>stop</operator>
      <operator>write_string</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>display_scene_3d.hdev</name>
      <desc>Anzeigen von 3D-Objektmodellen mittels einer 3D-Szene</desc>
      <path>hdevelop/Graphics/Scene-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <operator>add_scene_3d_camera</operator>
      <operator>add_scene_3d_instance</operator>
      <operator>add_scene_3d_light</operator>
      <operator>clear_scene_3d</operator>
      <operator>create_scene_3d</operator>
      <operator>display_scene_3d</operator>
      <operator>pose_compose</operator>
      <operator>render_scene_3d</operator>
      <operator>set_scene_3d_camera_pose</operator>
      <operator>set_scene_3d_instance_param</operator>
      <operator>set_scene_3d_instance_pose</operator>
      <operator>set_scene_3d_light_param</operator>
      <operator>set_scene_3d_to_world_pose</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>distance_cc_min.hdev</name>
      <desc>Berechnen der Distanz zwischen zwei Konturen</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>distance_cc_min</operator>
      <operator>gen_contour_polygon_rounded_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>distance_lr.hdev</name>
      <desc>Berechnen der Distanz zwischen einer Linie und einer Region</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>disp_line</operator>
      <operator>distance_lr</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_pc.hdev</name>
      <desc>Bestimmen des minimalen und maximalen Radius von Bohrlöchern (Berechnen der Distanz zwischen einem Punkt und einer Kontur)</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.auto</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <method>method.visual</method>
      <method>method.string</method>
      <method>method.edgeextr</method>
      <operator>disp_cross</operator>
      <operator>distance_pc</operator>
      <operator>edges_sub_pix</operator>
      <operator>get_string_extents</operator>
      <operator>select_shape_xld</operator>
      <operator>smallest_circle_xld</operator>
      <operator>sort_contours_xld</operator>
      <operator>tuple_string</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>distance_pl.hdev</name>
      <desc>Berechnen der Distanz zwischen Punkten und einer Linie</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>disp_line</operator>
      <operator>distance_pl</operator>
      <operator>get_region_contour</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_pp.hdev</name>
      <desc>Berechnen der Distanz zwischen zwei Punkten</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_pp</operator>
      <operator>get_region_contour</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_pr.hdev</name>
      <desc>Berechnen der Distanz zwischen einem Punkt und einer Region</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_pr</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_ps.hdev</name>
      <desc>Berechnen der Distanz zwischen einem Punkt und einem Liniensegment</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_ps</operator>
      <operator>get_region_contour</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_sl.hdev</name>
      <desc>Berechnen der Distanz zwischen einem Liniensegment und einer Linie</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_sl</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_sr.hdev</name>
      <desc>Berechnen der Distanz zwischen einem Liniensegment und einer Region</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_sr</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_ss.hdev</name>
      <desc>Berechnen der Distanz zwischen Liniensegmenten</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>distance_ss</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>distance_transform.hdev</name>
      <desc>Überprüfen einer synthetischen Leiterplatte</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.visual</method>
      <method>method.regionproc</method>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>disp_circle</operator>
      <operator>distance_transform</operator>
      <operator>gen_circle</operator>
      <operator>gen_region_polygon</operator>
      <operator>skeleton</operator>
      <operator>union2</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>distance_transform_interactive.hdev</name>
      <desc>Berechnen der Distanztransformation einer Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <method>method.filter.general</method>
      <operator>distance_transform</operator>
      <operator>draw_region</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>distance_transform_metrics.hdev</name>
      <desc>Berechnen von Distanzen mit verschiedenen Metriken</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>boundary</operator>
      <operator>distance_transform</operator>
      <operator>gen_circle</operator>
      <operator>gen_region_points</operator>
      <operator>intensity</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>div_image.hdev</name>
      <desc>Dividieren zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>div_image</operator>
      <operator>gen_image_gray_ramp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dotprt.hdev</name>
      <desc>Lesen von Dot-Prints</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.trafo.align</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <method>method.blob</method>
      <method>method.tuple</method>
      <operator>affine_trans_image</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clip_region</operator>
      <operator>dev_set_shape</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>opening_rectangle1</operator>
      <operator>partition_rectangle</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>shape_trans</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sort_region</operator>
      <operator>text_line_orientation</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>dots_image.hdev</name>
      <desc>Segmentieren eines Dot-Prints mit dots_image</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.morphol</method>
      <method>method.segm</method>
      <method>method.ocr</method>
      <method>method.filter.points</method>
      <operator>closing</operator>
      <operator>closing_rectangle1</operator>
      <operator>crop_part</operator>
      <operator>dots_image</operator>
      <operator>gen_rectangle2</operator>
      <operator>intersection</operator>
      <operator>mult_image</operator>
      <operator>partition_dynamic</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>dual_threshold.hdev</name>
      <desc>Segmentieren von mit Vorzeichen versehenen Bildern in positive und negative Regionen</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.roi</method>
      <method>method.regionproc</method>
      <method>method.segm</method>
      <operator>binary_threshold</operator>
      <operator>convert_image_type</operator>
      <operator>dilation_circle</operator>
      <operator>dual_threshold</operator>
      <operator>select_gray</operator>
      <operator>shape_trans</operator>
      <operator>sub_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>dump_window_data.hdev</name>
      <desc>Ausgeben des Grafikfensterinhalts in ein Bildobjekt</desc>
      <path>hdevelop/Graphics/Window/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>area_center_xld</operator>
      <operator>dump_window_image</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>set_tposition</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>dxf_input_output.hdev</name>
      <desc>Schreiben und Lesen von DXF Dateien</desc>
      <path>hdevelop/File/XLD/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.file</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>edges_sub_pix</operator>
      <operator>gen_polygons_xld</operator>
      <operator>query_contour_attribs_xld</operator>
      <operator>query_contour_global_attribs_xld</operator>
      <operator>read_contour_xld_dxf</operator>
      <operator>read_polygon_xld_dxf</operator>
      <operator>regress_contours_xld</operator>
      <operator>write_contour_xld_dxf</operator>
      <operator>write_polygon_xld_dxf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>dyn_threshold.hdev</name>
      <desc>Segmentieren eines Bildes mit einem lokalen Schwellwert</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>closing_circle</operator>
      <operator>connection</operator>
      <operator>dyn_threshold</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>mean_image</operator>
      <operator>opening_circle</operator>
      <operator>smallest_circle</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ean13.hdev</name>
      <desc>Lesen eines Barcodes vom Typ EAN13</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <industry>industry.retail</industry>
      <industry>industry.transp</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>ean13addon5.hdev</name>
      <desc>Lesen eines Barcodes vom Typ EAN13 Add-On 5</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <industry>industry.pack</industry>
      <industry>industry.retail</industry>
      <industry>industry.transp</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>6.0.1</newinversion>
   </example>
   <example>
      <name>ean8.hdev</name>
      <desc>Lesen eines Barcodes vom Typ EAN 8</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <industry>industry.pack</industry>
      <industry>industry.retail</industry>
      <industry>industry.transp</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>ecc200_contrast_tolerance.hdev</name>
      <desc>Lesen eines Datacodes vom Typ ECC200 mit lokalen Kontraständerungen</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>ecc200_direct_mark_quality_semi_t10.hdev</name>
      <desc>Überprüfen der Direktmarkierungsqualität von Datacodes vom Typ ECC200 (SEMI T10)</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <applarea>applarea.inspect.print</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>ecc200_finder_pattern_tolerance.hdev</name>
      <desc>Lesen von ECC200-Symbolen mit gestörtem Suchmuster</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>ecc200_optimized_settings.hdev</name>
      <desc>Optimieren von Parametern zum Lesen von Datacodes vom Typ ECC200</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ecc200_print_quality.hdev</name>
      <desc>Überprüfen der Druckqualität von Datacodes vom Typ ECC200</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <applarea>applarea.inspect.print</applarea>
      <method>method.datacode</method>
      <operator>affine_trans_image</operator>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>gray_dilation_shape</operator>
      <operator>gray_erosion_shape</operator>
      <operator>paint_gray</operator>
      <operator>paint_region</operator>
      <operator>projective_trans_image</operator>
      <operator>scale_image</operator>
      <operator>set_data_code_2d_param</operator>
      <operator>vector_to_proj_hom_mat2d</operator>
      <operator>wait_seconds</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>ecc200_simple.hdev</name>
      <desc>Lesen von Datacodes vom Typ ECC200</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ecc200_small_modules_robustness.hdev</name>
      <desc>Lesen von ECC200-Symbolen mit sehr kleinen Modulen</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>ecc200_training.hdev</name>
      <desc>Trainieren eines Datacodemodells, Speichern des Modells in einer Datei und Lesen des Modells aus einer Datei</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>get_data_code_2d_param</operator>
      <operator>query_data_code_2d_params</operator>
      <operator>read_data_code_2d_model</operator>
      <operator>write_data_code_2d_model</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>eccentricity.hdev</name>
      <desc>Berechnen der Exzentrizität von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>eccentricity</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>edge_segments.hdev</name>
      <desc>Extrahieren zusammenhängender Kantensegmente</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.blob</method>
      <operator>edges_image</operator>
      <operator>split_skeleton_lines</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>edges_color.hdev</name>
      <desc>Extrahieren von Kanten unter Verwendung von Farbinformation</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.color</method>
      <operator>dev_set_part</operator>
      <operator>edges_color</operator>
      <operator>edges_image</operator>
      <operator>rgb1_to_gray</operator>
      <operator>skeleton</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>edges_color_sub_pix.hdev</name>
      <desc>Extrahieren von Kanten mit Subpixelgenauigkeit unter Verwendung von Farbinformation</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.color</method>
      <operator>dev_set_part</operator>
      <operator>edges_color_sub_pix</operator>
      <operator>edges_sub_pix</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>edges_image.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit Deriche-, Lanser-, Shen- oder Canny-Filtern</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>edges_image</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>edges_sub_pix.hdev</name>
      <desc>Extrahieren von Kanten mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <operator>edges_sub_pix</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>eliminate_runs.hdev</name>
      <desc>Eliminieren von Lauflängen vorgegebener Länge aus einer Region (Lauflängenkodierung)</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>eliminate_runs</operator>
      <operator>gen_circle</operator>
      <operator>opening</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>elliptic_axis.hdev</name>
      <desc>Berechnen der entsprechenden Ellipsen von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>disp_ellipse</operator>
      <operator>elliptic_axis</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>elliptic_axis_gray.hdev</name>
      <desc>Analysieren der Genauigkeit der Berechnung der Grauwertmomente (elliptic_axis_gray)</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.2D</applarea>
      <method>method.feat</method>
      <operator>affine_trans_region</operator>
      <operator>elliptic_axis</operator>
      <operator>elliptic_axis_gray</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>paint_region</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>emphasize.hdev</name>
      <desc>Verbessern des Kontrasts des Bildes</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>emphasize</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>engraved.hdev</name>
      <desc>Lesen von Schriftzeichen auf einer Metalloberfläche</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <method>method.blob</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>dev_set_shape</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>gray_range_rect</operator>
      <operator>invert_image</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>sort_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>engravedt.hdev</name>
      <desc>Trainieren von Schriftzeichen auf einer Metalloberfläche</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.error</method>
      <operator>append_ocr_trainf</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>dev_set_shape</operator>
      <operator>gray_range_rect</operator>
      <operator>invert_image</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ensenso-nxlib_2cameras.hdev</name>
      <desc>Verwenden des NxLib-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>ensenso-nxlib_objectmodel3d.hdev</name>
      <desc>Verwenden des NxLib-Interfaces, um ein 3D-Objektmodell zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>open_framegrabber</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>ensenso-nxlib_parameters.hdev</name>
      <desc>Verwenden des NxLib-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>ensenso-nxlib_simple.hdev</name>
      <desc>Verwenden des NxLib-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_data</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>ensenso-nxlib_surface_based_3d_matching.hdev</name>
      <desc>Verwenden des NxLib-Interfaces (oberflächenbasiertes 3D-Matching)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>create_surface_model</operator>
      <operator>find_surface_model</operator>
      <operator>grab_data</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_object_model_3d</operator>
      <operator>set_framegrabber_param</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>entropy_gray.hdev</name>
      <desc>Berechnen der Entropie und Anisometrie von Bildern</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.feat</method>
      <method>method.texture</method>
      <operator>entropy_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>entropy_image.hdev</name>
      <desc>Segmentieren eines Bildes aufgrund der Entropie von Grauwerten</desc>
      <path>hdevelop/Filters/Texture/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.texture</method>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.segm</method>
      <operator>entropy_image</operator>
      <operator>fill_up_shape</operator>
      <operator>opening_circle</operator>
      <operator>select_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>equ_histo_image.hdev</name>
      <desc>Linearisieren des Histogramms für Byte Bilder</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>equ_histo_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>error_handling_timeout.hdev</name>
      <desc>Umgehen mit Fehlern beim Bildeinzug</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.error</method>
      <operator>close_framegrabber</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>get_error_text</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>estimate_noise.hdev</name>
      <desc>Schätzen des Rauschens innerhalb eines Bildes</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>add_noise_distribution</operator>
      <operator>estimate_noise</operator>
      <operator>gauss_distribution</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>euclid_distance.hdev</name>
      <desc>Berechnen der euklidischen Distanz für ein Tupel von Koordinaten</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.functions</method>
      <method>method.tuple</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>euler_number.hdev</name>
      <desc>Berechnen der Euler-Zahl von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>complement</operator>
      <operator>euler_number</operator>
      <operator>get_system</operator>
      <operator>set_system</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>exhaustive_match.hdev</name>
      <desc>Ausführen eines Matchings zwischen einem Template und einem Bild (grauwertbasiertes Matching)</desc>
      <path>hdevelop/Filters/Match/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <operator>exhaustive_match</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>exit.hdev</name>
      <desc>Beenden von HDevelop nach Ausführung einer Anwendung</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>exit</operator>
      <operator>fwrite_string</operator>
      <operator>intensity</operator>
      <operator>open_file</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>expand_gray.hdev</name>
      <desc>Auffüllen von Lücken zwischen Regionen (abhängig vom Grauwert)</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>expand_gray</operator>
      <operator>gen_empty_region</operator>
      <operator>regiongrowing</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>expand_gray_ref.hdev</name>
      <desc>Auffüllen von Lücken zwischen Regionen (abhängig vom Grauwert)</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>expand_gray_ref</operator>
      <operator>gen_empty_region</operator>
      <operator>intensity</operator>
      <operator>regiongrowing</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>expand_line.hdev</name>
      <desc>Erzeugen einer Region durch Expansion, ausgehend von einer Linie</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>expand_line</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>expand_region.hdev</name>
      <desc>Auffüllen von Lücken zwischen Regionen oder Aufspalten von sich überlappenden Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <operator>dilation_circle</operator>
      <operator>expand_region</operator>
      <operator>gen_empty_region</operator>
      <operator>regiongrowing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>explain_poses.hdev</name>
      <desc>Darstellen von verschiedenen Posen im Kamera-Koordinatensystem</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.poseestim</method>
      <operator>create_pose</operator>
      <operator>pose_compose</operator>
      <operator>sim_caltab</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>explore_halcon.hdev</name>
      <desc>Explore the power of HALCON</desc>
      <path>hdevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.ident.barcode</applarea>
      <applarea>applarea.ident.datacode</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <applarea>applarea.inspect.color</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.inspect.surface</applarea>
      <applarea>applarea.inspect.texture</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.measure.3D</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.robotvis</applarea>
      <applarea>applarea.security</applarea>
      <applarea>applarea.traffic</applarea>
      <method>method.general</method>
      <operator>dev_display</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>extract_clips_xl.hdev</name>
      <desc>Verarbeiten von großen Bildern mit HALCON XL</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.visual</method>
      <method>method.feat</method>
      <operator>get_system</operator>
      <operator>tile_images</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>fast_match_mg.hdev</name>
      <desc>Finden von Matches zu einem Grauwerttemplate in einer Pyramide</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.gray</method>
      <operator>add_channels</operator>
      <operator>best_match</operator>
      <operator>create_template</operator>
      <operator>fast_match_mg</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>fast_threshold.hdev</name>
      <desc>Schnelles Auswählen von Grauwerten in einem Intervall</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>fast_threshold</operator>
      <operator>threshold</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>fast_threshold_vs_threshold.hdev</name>
      <desc>Vergleichen von fast_threshold und threshold</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>area_center</operator>
      <operator>count_seconds</operator>
      <operator>difference</operator>
      <operator>fast_threshold</operator>
      <operator>threshold</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>features_points_xld.hdev</name>
      <desc>Vergleichen von *_xld Operatoren mit den entsprechenden *_points_xld Operatoren</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>area_center_points_xld</operator>
      <operator>area_center_xld</operator>
      <operator>close_contours_xld</operator>
      <operator>elliptic_axis_points_xld</operator>
      <operator>elliptic_axis_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>lines_gauss</operator>
      <operator>select_shape_xld</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>file.hdev</name>
      <desc>Verwenden des File-Interfaces (Einzelbild)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>file_directory.hdev</name>
      <desc>Verwenden des File-Interfaces (Lesen aller Dateien eines Verzeichnisses)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_system</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>file_exists.hdev</name>
      <desc>Überprüfen der Existenz einer Datei</desc>
      <path>hdevelop/File/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.string</method>
      <method>method.error</method>
      <method>method.file</method>
      <method>method.opsys</method>
      <method>method.functions</method>
      <operator>close_file</operator>
      <operator>delete_file</operator>
      <operator>file_exists</operator>
      <operator>fread_string</operator>
      <operator>get_system</operator>
      <operator>open_file</operator>
      <operator>system_call</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>file_sequence.hdev</name>
      <desc>Verwenden des File-Interfaces (sequence grabbing)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>fill_interlace.hdev</name>
      <desc>Interpolieren von Halbbildern</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.filter.general</method>
      <operator>dev_set_part</operator>
      <operator>fill_interlace</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fill_up.hdev</name>
      <desc>Auffüllen von Löchern in Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>difference</operator>
      <operator>fill_up</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fill_up_shape.hdev</name>
      <desc>Auffüllen von Löchern in Regionen einer vorgegebenen Form</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <operator>difference</operator>
      <operator>fill_up_shape</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fin.hdev</name>
      <desc>Überprüfen einer Kontur auf Grate</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>area_center</operator>
      <operator>binary_threshold</operator>
      <operator>closing_circle</operator>
      <operator>difference</operator>
      <operator>opening_rectangle1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>find_aniso_shape_model.hdev</name>
      <desc>Auffinden von SMD Kondensatoren mit formbasiertem Matching (mit anisotroper Skalierung und Rotation)</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>count_seconds</operator>
      <operator>create_aniso_shape_model</operator>
      <operator>find_aniso_shape_model</operator>
      <operator>gen_contour_polygon_rounded_xld</operator>
      <operator>gen_image_const</operator>
      <operator>get_shape_model_contours</operator>
      <operator>get_string_extents</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>paint_xld</operator>
      <operator>set_system</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>find_cocoa_packages_local_deformable.hdev</name>
      <desc>Auffinden eines Kakaoschriftzugs mit lokal deformierbarem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.ldeform</method>
      <method>method.trafo.geom</method>
      <operator>clear_deformable_model</operator>
      <operator>create_local_deformable_model</operator>
      <operator>find_local_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_cocoa_packages_max_deformation.hdev</name>
      <desc>Auffinden eines Kakaoschriftzugs mit formbasiertem Matching mit 'max_deformation'</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.shape</method>
      <method>method.trafo.geom</method>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_deformable_surface_model.hdev</name>
      <desc>Auffinden eines Objekts in einer 3D-Szene mit deformierbarem oberflächenbasiertem 3D-Matching</desc>
      <path>hdevelop/3D-Matching/Deformable-Surface-Based/</path>
      <industry>industry.food</industry>
      <industry>industry.synth</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.surface</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <operator>add_deformable_surface_model_reference_point</operator>
      <operator>add_deformable_surface_model_sample</operator>
      <operator>clear_deformable_surface_matching_result</operator>
      <operator>clear_deformable_surface_model</operator>
      <operator>connection_object_model_3d</operator>
      <operator>copy_object_model_3d</operator>
      <operator>create_deformable_surface_model</operator>
      <operator>distance_object_model_3d</operator>
      <operator>find_deformable_surface_model</operator>
      <operator>gen_object_model_3d_from_points</operator>
      <operator>gen_plane_object_model_3d</operator>
      <operator>get_deformable_surface_matching_result</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>read_object_model_3d</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <operator>smooth_object_model_3d</operator>
      <operator>union_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>find_local_deformable_model.hdev</name>
      <desc>Auffinden eines Objekts trotz lokaler Deformationen mit lokal deformierbarem Matching</desc>
      <path>hdevelop/Matching/Deformable/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.deform</method>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.morphol</method>
      <method>method.segm</method>
      <method>method.trafo.geom</method>
      <method>method.xld</method>
      <method>method.typeconv.ico</method>
      <operator>clear_deformable_model</operator>
      <operator>create_local_deformable_model</operator>
      <operator>crop_domain</operator>
      <operator>find_local_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>get_grayval_interpolated</operator>
      <operator>optical_flow_mg</operator>
      <operator>real_to_vector_field</operator>
      <operator>unwarp_image_vector_field</operator>
      <operator>vector_field_length</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_mirror_dies.hdev</name>
      <desc>Auffinden von Spiegel-Dies auf einem Wafer</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.trafo.geom</method>
      <method>method.match.shape</method>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_ncc_model_defocused.hdev</name>
      <desc>Auffinden eines Objekts trotz Änderungen in Textur und Fokus mit korrelationsbasiertem Matching</desc>
      <path>hdevelop/Matching/Correlation-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.correl</method>
      <operator>affine_trans_region</operator>
      <operator>clear_ncc_model</operator>
      <operator>create_ncc_model</operator>
      <operator>find_ncc_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>find_ncc_model_defocused_precision.hdev</name>
      <desc>Untersuchen von NCC Matches in unterschiedlich fokussierten Bildern</desc>
      <path>hdevelop/Matching/Correlation-Based/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.match.correl</method>
      <method>method.xld</method>
      <method>method.geom</method>
      <method>method.tuple</method>
      <operator>clear_ncc_model</operator>
      <operator>create_ncc_model</operator>
      <operator>find_ncc_model</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>find_ncc_model_exposure.hdev</name>
      <desc>Auffinden eines Objekts trotz Änderungen in der Beleuchtung mit korrelationsbasiertem Matching</desc>
      <path>hdevelop/Matching/Correlation-Based/</path>
      <industry>industry.food</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.correl</method>
      <operator>affine_trans_region</operator>
      <operator>clear_ncc_model</operator>
      <operator>create_ncc_model</operator>
      <operator>find_ncc_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>find_neighbors.hdev</name>
      <desc>Testen der Nachbarschaftsbeziehungen von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <operator>disp_line</operator>
      <operator>expand_region</operator>
      <operator>find_neighbors</operator>
      <operator>gen_empty_region</operator>
      <operator>regiongrowing</operator>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>find_pads.hdev</name>
      <desc>Finden von Pads auf einem Die</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.blob</method>
      <method>method.roi</method>
      <operator>boundary</operator>
      <operator>connection</operator>
      <operator>dev_close_window</operator>
      <operator>dev_open_window</operator>
      <operator>dev_update_pc</operator>
      <operator>dev_update_var</operator>
      <operator>dev_update_window</operator>
      <operator>dilation_circle</operator>
      <operator>edges_sub_pix</operator>
      <operator>fast_threshold</operator>
      <operator>fill_up</operator>
      <operator>fit_rectangle2_contour_xld</operator>
      <operator>gen_rectangle2_contour_xld</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape</operator>
      <operator>select_shape_xld</operator>
      <operator>shape_trans</operator>
      <operator>union1</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>find_peanut_chocolate_candies_local_deformable.hdev</name>
      <desc>Auffinden des Schriftzugs einer Packung mit schokolierten Erdnüssen mit lokal deformierbarem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.shape</method>
      <method>method.trafo.geom</method>
      <operator>clear_deformable_model</operator>
      <operator>create_local_deformable_model</operator>
      <operator>find_local_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_scaled_shape_model.hdev</name>
      <desc>Auffinden von Objekten mit formbasiertem Matching (mit Skalierung und Rotation)</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>find_scratches_bandpass_fft.hdev</name>
      <desc>Erkennen von Defekten mit einem Bandpassfilter</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.fft</method>
      <method>method.morphol</method>
      <operator>gen_region_contour_xld</operator>
      <operator>gen_sin_bandpass</operator>
      <operator>optimize_rft_speed</operator>
      <operator>rft_generic</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_shape_model_3d_recompute_score.hdev</name>
      <desc>Neuberechnen des Scores nach der Poseverfeinerung eines formbasierten 3D-Matchings</desc>
      <path>hdevelop/3D-Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.shape</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <operator>clear_object_model_3d</operator>
      <operator>clear_shape_model_3d</operator>
      <operator>convert_point_3d_spher_to_cart</operator>
      <operator>create_cam_pose_look_at_point</operator>
      <operator>create_shape_model_3d</operator>
      <operator>find_shape_model_3d</operator>
      <operator>gen_object_model_3d_from_points</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_shape_model_3d</operator>
      <operator>read_shape_model_3d</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <operator>write_shape_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>find_shape_model_max_deformation.hdev</name>
      <desc>Auffinden leicht deformierter Objekte mit formbasiertem Matching</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.edgeextr</method>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.regionproc</method>
      <method>method.segm</method>
      <method>method.roi</method>
      <method>method.trafo.align</method>
      <method>method.xld</method>
      <operator>clear_shape_model</operator>
      <operator>close_contours_xld</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_smd_fast.hdev</name>
      <desc>Finden von SMDs auf einer von hinten beleuchteten Platte</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>gen_rectangle2_contour_xld</operator>
      <operator>select_shape_std</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_surface_model.hdev</name>
      <desc>Auffinden eines Objekts in einer 3D-Szene mit oberflächenbasiertem 3D-Matching</desc>
      <path>hdevelop/3D-Matching/Surface-Based/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.surface</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>clear_object_model_3d</operator>
      <operator>clear_surface_matching_result</operator>
      <operator>clear_surface_model</operator>
      <operator>create_surface_model</operator>
      <operator>find_surface_model</operator>
      <operator>get_surface_matching_result</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_surface_model_noisy_data.hdev</name>
      <desc>Auffinden eines Objekts mittels oberflächenbasiertem 3D-Matching in einer verrauschten 3D-Szene, die mit einer Time-of-Flight-Kamera (TOF) aufgenommen wurde</desc>
      <path>hdevelop/3D-Matching/Surface-Based/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.surface</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>connection_object_model_3d</operator>
      <operator>create_surface_model</operator>
      <operator>distance_object_model_3d</operator>
      <operator>find_surface_model</operator>
      <operator>get_surface_matching_result</operator>
      <operator>max_diameter_object_model_3d</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>select_shape</operator>
      <operator>surface_normals_object_model_3d</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>find_text.hdev</name>
      <desc>Segmentieren und Lesen von Text auf einer Arzneimittelpackung mit unterschiedlichen Parametern für die automatische Texterkennung</desc>
      <path>hdevelop/OCR/Segmentation/</path>
      <industry>industry.general</industry>
      <industry>industry.food</industry>
      <industry>industry.health</industry>
      <industry>industry.pack</industry>
      <industry>industry.pharm</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>find_text</operator>
      <operator>get_text_object</operator>
      <operator>get_text_result</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>set_text_model_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>find_text_bottle_label.hdev</name>
      <desc>Segmentieren von Text auf einem Flaschenetikett für eine OCR Anwendung</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.segm</method>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>find_text</operator>
      <operator>get_text_model_param</operator>
      <operator>get_text_object</operator>
      <operator>get_text_result</operator>
      <operator>set_text_model_param</operator>
      <operator>text_line_orientation</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_text_dongle.hdev</name>
      <desc>Segmentieren von Text auf einem Dongle für eine OCR Anwendung</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.segm</method>
      <method>method.ocr</method>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>do_ocr_word_mlp</operator>
      <operator>find_text</operator>
      <operator>set_text_model_param</operator>
      <operator>text_line_orientation</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>find_text_expiration_date.hdev</name>
      <desc>Segmentieren, Auswählen und Lesen von Text auf einer Arzneimittelpackung mit der automatischen Texterkennung</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <industry>industry.food</industry>
      <industry>industry.health</industry>
      <industry>industry.pack</industry>
      <industry>industry.pharm</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <operator>create_text_model_reader</operator>
      <operator>find_text</operator>
      <operator>gen_empty_object_model_3d</operator>
      <operator>get_text_object</operator>
      <operator>get_text_result</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>first_example_acquisition.hdev</name>
      <desc>Demonstrieren der wesentlichen Operatoren für den Bildeinzug</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.segm</method>
      <method>method.visual</method>
      <operator>auto_threshold</operator>
      <operator>close_framegrabber</operator>
      <operator>get_mposition</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_system</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>first_example_shape_matching.hdev</name>
      <desc>Vorstellen von HALCONs formbasiertem Matching</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.visual</method>
      <method>method.match.shape</method>
      <method>method.roi</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>fit_circle_contour_xld.hdev</name>
      <desc>Approximieren einer XLD Kontur durch einen Kreis</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fit_ellipse_contour_xld.hdev</name>
      <desc>Approximieren von XLD Konturen durch Ellipsen oder Ellipsenbögen</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <operator>complement</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_image_const</operator>
      <operator>get_contour_xld</operator>
      <operator>paint_region</operator>
      <operator>union2</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fit_ellipse_tooth_rim_xld.hdev</name>
      <desc>Approximieren der Kontur eines Zahnkranzes durch eine Ellipse zum Finden ihres Zentrums</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.funct1d</method>
      <method>method.feat</method>
      <operator>clip_contours_xld</operator>
      <operator>create_funct_1d_array</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_part</operator>
      <operator>dist_ellipse_contour_points_xld</operator>
      <operator>dist_ellipse_contour_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>length_xld</operator>
      <operator>local_min_max_funct_1d</operator>
      <operator>set_tposition</operator>
      <operator>tuple_max</operator>
      <operator>tuple_median</operator>
      <operator>tuple_sort_index</operator>
      <operator>write_string</operator>
      <operator>zero_crossings_funct_1d</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>fit_line_contour_xld.hdev</name>
      <desc>Approximieren von XLD Konturen durch Liniensegmente</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.io</method>
      <method>method.visual</method>
      <method>method.xld</method>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>get_mbutton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fit_primitives_object_model_3d.hdev</name>
      <desc>Anpassen eines Zylinders in 2.5D Daten</desc>
      <path>hdevelop/3D-Object-Model/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.fitting3d</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>fit_primitives_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>object_model_3d_to_xyz</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>fit_rectangle2_contour_xld.hdev</name>
      <desc>Erkennen von Fehlern in gestanzten rechteckigen Löchern</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.functions</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.feat</method>
      <method>method.visual</method>
      <method>method.tuple</method>
      <operator>boundary</operator>
      <operator>dilation_rectangle1</operator>
      <operator>dist_rectangle2_contour_points_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>fast_threshold</operator>
      <operator>fit_rectangle2_contour_xld</operator>
      <operator>gen_rectangle2_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>get_string_extents</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_xld</operator>
      <operator>set_tposition</operator>
      <operator>write_string</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>fnew_line.hdev</name>
      <desc>Schreiben von Zeilenvorschüben in eine Textdatei</desc>
      <path>hdevelop/File/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>fnew_line</operator>
      <operator>fwrite_string</operator>
      <operator>open_file</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>font.hdev</name>
      <desc>Lesen gedruckter Schriftzeichen mit interaktiver Auswahl</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.visual</method>
      <operator>char_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>dilation_rectangle1</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>get_params_ocr_class_mlp</operator>
      <operator>get_region_index</operator>
      <operator>min_max_gray</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>scale_image</operator>
      <operator>shape_trans</operator>
      <operator>sort_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fontt.hdev</name>
      <desc>Trainieren und Reklassifizieren von gedruckten Schriftzeichen</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.error</method>
      <operator>append_ocr_trainf</operator>
      <operator>char_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>copy_obj</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>min_max_gray</operator>
      <operator>reduce_domain</operator>
      <operator>scale_image</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>for.hdev</name>
      <desc>Verwenden einer Schleife zum Iterieren über extrahierte Regionen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>else</operator>
      <operator>endfor</operator>
      <operator>endif</operator>
      <operator>for</operator>
      <operator>stop</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>forest.hdev</name>
      <desc>Extrahieren von Bäumen und Wiesen aus Waldstücken</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.blob</method>
      <method>method.color</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <method>method.roi</method>
      <method>method.tuple</method>
      <operator>closing_circle</operator>
      <operator>complement</operator>
      <operator>connection</operator>
      <operator>decompose3</operator>
      <operator>difference</operator>
      <operator>invert_image</operator>
      <operator>min_max_gray</operator>
      <operator>opening_circle</operator>
      <operator>reduce_domain</operator>
      <operator>select_gray</operator>
      <operator>select_shape_std</operator>
      <operator>smooth_image</operator>
      <operator>threshold</operator>
      <operator>union1</operator>
      <operator>union2</operator>
      <operator>watersheds</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fread_char.hdev</name>
      <desc>Lesen von Schriftzeichen aus einer Textdatei</desc>
      <path>hdevelop/File/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>fnew_line</operator>
      <operator>fread_char</operator>
      <operator>fread_string</operator>
      <operator>fwrite_string</operator>
      <operator>open_file</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fread_line.hdev</name>
      <desc>Lesen von Zeilen aus einer Textdatei</desc>
      <path>hdevelop/File/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>fread_line</operator>
      <operator>fwrite_string</operator>
      <operator>open_file</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>fread_string.hdev</name>
      <desc>Lesen von Zeichenketten aus einer Textdatei</desc>
      <path>hdevelop/File/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>fread_string</operator>
      <operator>open_file</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>frei_amp.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude) mit dem Frei-Chen Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>frei_amp</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>frei_dir.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit dem Frei-Chen Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>frei_dir</operator>
      <operator>nonmax_suppression_dir</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fuse.hdev</name>
      <desc>Messen der Dicke eines Sicherungsdrahts</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>measure_pairs</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>fuzzy_entropy.hdev</name>
      <desc>Berechnen der Fuzzy-Entropie</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.feat</method>
      <method>method.texture</method>
      <operator>fuzzy_entropy</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>fuzzy_measure_pin.hdev</name>
      <desc>Vermessen von Kontakten auf einem IC mithilfe von Fuzzy-Regeln</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>for</operator>
      <operator>fuzzy_measure_pairs</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>set_fuzzy_measure_norm_pair</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>fuzzy_measure_switch.hdev</name>
      <desc>Ermitteln der Breite und der Distanz zwischen den Kontakten eines Schalters mithilfe von Fuzzy-Regeln</desc>
      <path>solution_guide/1d_measuring/</path>
      <industry>industry.general</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.funct1d</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>fuzzy_measure_pairs</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>measure_pairs</operator>
      <operator>set_fuzzy_measure</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>fuzzy_perimeter.hdev</name>
      <desc>Berechnen des Fuzzy-Umfangs</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.feat</method>
      <method>method.texture</method>
      <operator>fuzzy_perimeter</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_arbitrary_distortion_map.hdev</name>
      <desc>Entzerren eines beliebig verzerrten Bildes unter Verwendung eines regelmäßigen Gitters mit bekannten Korrespondenzen</desc>
      <path>hdevelop/Tools/Grid-Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.rectif</method>
      <method>method.visual</method>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_arbitrary_distortion_map</operator>
      <operator>map_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>gen_checker_region.hdev</name>
      <desc>Erzeugen einer Schachbrettregion</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>connection</operator>
      <operator>dev_set_colored</operator>
      <operator>gen_checker_region</operator>
      <operator>get_system</operator>
      <operator>set_system</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_circle.hdev</name>
      <desc>Erzeugen einer kreisförmigen Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.feat</method>
      <operator>gen_circle</operator>
      <operator>inner_circle</operator>
      <operator>regiongrowing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_contour_region_xld.hdev</name>
      <desc>Extrahieren der Konturen von Regionen als XLD Objekte</desc>
      <path>hdevelop/XLD/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>gen_contour_region_xld</operator>
      <operator>regiongrowing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_cooc_matrix.hdev</name>
      <desc>Berechnen einer Co-Occurence-Matrix</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.texture</method>
      <operator>dev_set_lut</operator>
      <operator>gen_cooc_matrix</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_ellipse.hdev</name>
      <desc>Erzeugen einer elliptischen Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.feat</method>
      <operator>elliptic_axis</operator>
      <operator>gen_ellipse</operator>
      <operator>regiongrowing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_empty_region.hdev</name>
      <desc>Erzeugen einer leeren Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_empty_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_filter_mask.hdev</name>
      <desc>Speichern einer Filtermaske im Ortsraum als Real Bild</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>fft_image</operator>
      <operator>gen_filter_mask</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_gauss_pyramid.hdev</name>
      <desc>Erzeugen einer Pyramide von verkleinerten Bildern</desc>
      <path>hdevelop/Filters/Match/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>count_obj</operator>
      <operator>gen_gauss_pyramid</operator>
      <operator>select_obj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_grid_region.hdev</name>
      <desc>Erzeugen einer Gitterregion, die aus Linien und Punkten besteht</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.segm</method>
      <operator>dilation_rectangle1</operator>
      <operator>gen_grid_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_image_interleaved.hdev</name>
      <desc>Erzeugen eines dreikanaligen HALCON Bildes aus einem Halbbild (verschiedene Ansätze)</desc>
      <path>hdevelop/Image/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>affine_trans_image_size</operator>
      <operator>clip_region</operator>
      <operator>convert_image_type</operator>
      <operator>decompose3</operator>
      <operator>gen_grid_region</operator>
      <operator>gen_image_const</operator>
      <operator>gen_image_interleaved</operator>
      <operator>get_image_pointer3</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>move_region</operator>
      <operator>overpaint_gray</operator>
      <operator>scale_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gen_mean_filter.hdev</name>
      <desc>Filtern eines Bildes mit kreisförmigem Mean Filter</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>convol_fft</operator>
      <operator>gen_mean_filter</operator>
      <operator>mean_image</operator>
      <operator>rft_generic</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>gen_measure_arc.hdev</name>
      <desc>Messen von Kanten rechtwinklig zu einem vorgegebenen Bogen</desc>
      <path>hdevelop/1D-Measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <operator>close_measure</operator>
      <operator>distance_pp</operator>
      <operator>gen_measure_arc</operator>
      <operator>measure_pos</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_measure_rectangle2.hdev</name>
      <desc>Messen von Kanten rechtwinklig zu einer vorgegebenen Linie</desc>
      <path>hdevelop/1D-Measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>measure_pairs</operator>
      <operator>measure_pos</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_nurbs_interp.hdev</name>
      <desc>Erzeugen einer NURBS Kurve, die eine Punktliste interpoliert</desc>
      <path>hdevelop/XLD/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_contour_nurbs_xld</operator>
      <operator>gen_nurbs_interp</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>gen_parallel_contour_xld.hdev</name>
      <desc>Berechnen der parallelen Kontur zu einer XLD Kontur</desc>
      <path>hdevelop/XLD/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>edges_sub_pix</operator>
      <operator>gen_image_const</operator>
      <operator>gen_parallel_contour_xld</operator>
      <operator>paint_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_primitives_object_model_3d.hdev</name>
      <desc>Erzeugen von 3D-Objektmodell-Primitiven wie Ebenen, Kugeln und Quadern</desc>
      <path>hdevelop/3D-Object-Model/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>gen_box_object_model_3d</operator>
      <operator>gen_cylinder_object_model_3d</operator>
      <operator>gen_plane_object_model_3d</operator>
      <operator>gen_sphere_object_model_3d</operator>
      <operator>gen_sphere_object_model_3d_center</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gen_principal_comp_trans.hdev</name>
      <desc>Extrahieren von Wald, Wasser und Bäumen aus einem mehrkanaligen Bild mit einer Hauptachsentransformation</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <operator>class_2dim_sup</operator>
      <operator>closing_circle</operator>
      <operator>convert_image_type</operator>
      <operator>decompose7</operator>
      <operator>dilation_circle</operator>
      <operator>gen_principal_comp_trans</operator>
      <operator>histo_2dim</operator>
      <operator>linear_trans_color</operator>
      <operator>scale_image</operator>
      <operator>select_shape_std</operator>
      <operator>threshold</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>gen_projective_mosaic.hdev</name>
      <desc>Kombinieren mehrerer Bilder eines PCBs zu einem großen Mosaikbild</desc>
      <path>hdevelop/Tools/Mosaicking/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.mosaic</method>
      <method>method.functions</method>
      <method>method.match.point</method>
      <method>method.filter.points</method>
      <method>method.visual</method>
      <operator>bundle_adjust_mosaic</operator>
      <operator>dev_set_window_extents</operator>
      <operator>gen_bundle_adjusted_mosaic</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_image_const</operator>
      <operator>gen_projective_mosaic</operator>
      <operator>paint_region</operator>
      <operator>points_foerstner</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>tile_images_offset</operator>
      <operator>wait_seconds</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>gen_random_region.hdev</name>
      <desc>Erzeugen einer zufälligen Region (Rauschen)</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_random_region</operator>
      <operator>remove_noise_region</operator>
      <operator>runlength_features</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_random_regions.hdev</name>
      <desc>Erzeugen einer Region mit zufälligen Parametern (circle, rectangle...)</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_random_regions</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_rectangle1.hdev</name>
      <desc>Erzeugen einer rechtwinkligen Region parallel zur Koordinatenachse</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>closing_rectangle1</operator>
      <operator>gen_rectangle1</operator>
      <operator>smallest_rectangle1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_rectangle2.hdev</name>
      <desc>Erzeugen einer rechtwinkligen Region mit beliebiger Orientierung</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_rectangle2</operator>
      <operator>smallest_rectangle2</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_histo.hdev</name>
      <desc>Erzeugen einer Region aufgrund eines Histogramms (256 Werte)</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.visual</method>
      <method>method.funct1d</method>
      <operator>create_funct_1d_array</operator>
      <operator>funct_1d_to_pairs</operator>
      <operator>gen_region_histo</operator>
      <operator>gray_histo</operator>
      <operator>smooth_funct_1d_gauss</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_hline.hdev</name>
      <desc>Erzeugen einer linienartigen Region aufgrund der Hesseschen Normalform</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_region_hline</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_line.hdev</name>
      <desc>Erzeugen einer linienartigen Region aufgrund von Start- und Endpunkt</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>gen_region_line</operator>
      <operator>intensity</operator>
      <operator>set_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_points.hdev</name>
      <desc>Erzeugen einer punktförmigen Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>gen_region_points</operator>
      <operator>get_mbutton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_polygon.hdev</name>
      <desc>Erzeugen einer polygonalen Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>gen_region_polygon</operator>
      <operator>get_mbutton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_polygon_filled.hdev</name>
      <desc>Erzeugen einer gefüllten polygonalen Region</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>gen_region_polygon_filled</operator>
      <operator>get_mbutton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_region_runs.hdev</name>
      <desc>Erzeugen einer Region aufgrund horizontaler Linien (Lauflängenkodierung)</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>gen_region_runs</operator>
      <operator>get_mbutton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gen_training_file.hdev</name>
      <desc>Generieren einer Trainingsdatei für OCR</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.file</method>
      <method>method.ocr</method>
      <operator>append_ocr_trainf</operator>
      <operator>delete_file</operator>
      <operator>intersection</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sort_region</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>generate_system_font.hdev</name>
      <desc>Erzeugen von OCR Trainingsmustern aus Systemfonts</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.segm</method>
      <method>method.trafo.geom</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>create_text_model_reader</operator>
      <operator>distance_transform</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>get_text_object</operator>
      <operator>query_font</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>read_ocr_trainf</operator>
      <operator>set_font</operator>
      <operator>set_text_model_param</operator>
      <operator>text_line_orientation</operator>
      <operator>tile_images_offset</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>unwarp_image_vector_field</operator>
      <operator>write_string</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>generic_socket_receive_data.hdev</name>
      <desc>Verwenden generischer Sockets zum Empfangen von Daten</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>get_socket_param</operator>
      <operator>open_socket_accept</operator>
      <operator>receive_data</operator>
      <operator>send_data</operator>
      <operator>set_socket_param</operator>
      <operator>socket_accept_connect</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>generic_socket_send_data.hdev</name>
      <desc>Verwenden generischer Sockets zum Senden von Daten</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>get_socket_param</operator>
      <operator>open_socket_connect</operator>
      <operator>receive_data</operator>
      <operator>send_data</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>genicamtl.hdev</name>
      <desc>Verwenden des GenICamTL-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>genicamtl_areascan3d_objectmodel3d.hdev</name>
      <desc>Verwenden des GenICamTL-Interfaces, um ein 3D-Objektmodell aus VRMagic-AreaScan3D-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>genicamtl_gocator_objectmodel3d.hdev</name>
      <desc>Verwenden des GenICamTL-Interfaces, um ein 3D-Objektmodell aus LMI-Technologies-Gocator-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>genicamtl_parameters.hdev</name>
      <desc>Verwenden des GenICamTL-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>genicamtl_simple.hdev</name>
      <desc>Verwenden des GenICamTL-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>get_circle_pose.hdev</name>
      <desc>Bestimmen der 3D-Pose von Kreisen aus ihren perspektivischen Projektionen</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.functions</method>
      <method>method.numeric</method>
      <method>method.poseestim</method>
      <method>method.tuple</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_point_3d</operator>
      <operator>assign</operator>
      <operator>binomial_filter</operator>
      <operator>concat_obj</operator>
      <operator>count_obj</operator>
      <operator>create_pose</operator>
      <operator>edges_sub_pix</operator>
      <operator>find_caltab</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>gen_empty_obj</operator>
      <operator>get_circle_pose</operator>
      <operator>get_contour_xld</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>select_contours_xld</operator>
      <operator>sim_caltab</operator>
      <operator>tuple_sort_index</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>get_grayval_contour_xld.hdev</name>
      <desc>Ermitteln von Grauwerten an den Positionen einer XLD Kontur</desc>
      <path>hdevelop/Image/Access/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.funct1d</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <operator>create_funct_1d_array</operator>
      <operator>get_grayval_contour_xld</operator>
      <operator>local_min_max_funct_1d</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>get_grayval_interpolated.hdev</name>
      <desc>Ermitteln von Grauwerten an bestimmten Zeilen- und Spaltenpositionen</desc>
      <path>hdevelop/Image/Access/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.funct1d</method>
      <method>method.feat</method>
      <method>method.tuple</method>
      <operator>create_funct_1d_array</operator>
      <operator>get_grayval_interpolated</operator>
      <operator>local_min_max_funct_1d</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>get_modules.hdev</name>
      <desc>Abfragen der benutzten Lizensierungsmodule und dem Modulschlüssel</desc>
      <path>hdevelop/System/Database/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>close_edges</operator>
      <operator>get_modules</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>get_mposition.hdev</name>
      <desc>Abfragen der Mausposition und dem Status der Maustasten</desc>
      <path>hdevelop/Graphics/Mouse/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.io</method>
      <method>method.error</method>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>dev_set_preferences</operator>
      <operator>disp_rectangle1</operator>
      <operator>get_grayval</operator>
      <operator>get_mposition</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>get_operator_info.hdev</name>
      <desc>Abfragen von Informationen über Operatoren</desc>
      <path>hdevelop/System/Information/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>continue</operator>
      <operator>get_extended_error_info</operator>
      <operator>get_operator_info</operator>
      <operator>get_operator_name</operator>
      <operator>get_param_info</operator>
      <operator>get_param_names</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>get_param_info.hdev</name>
      <desc>Abfragen von Informationen über Parameter von Operatoren</desc>
      <path>hdevelop/System/Information/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>get_operator_name</operator>
      <operator>get_param_info</operator>
      <operator>get_param_names</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>get_rectangle_pose_barcode.hdev</name>
      <desc>Schätzen der 3D-Pose von Barcodes</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.poseestim</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.geom</method>
      <method>method.visual</method>
      <method>method.trafo.wcoord</method>
      <operator>affine_trans_point_3d</operator>
      <operator>area_center</operator>
      <operator>clear_bar_code_model</operator>
      <operator>close_contours_xld</operator>
      <operator>complement</operator>
      <operator>connection</operator>
      <operator>contour_to_world_plane_xld</operator>
      <operator>create_bar_code_model</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>difference</operator>
      <operator>dilation_rectangle1</operator>
      <operator>distance_pp</operator>
      <operator>dyn_threshold</operator>
      <operator>edges_sub_pix</operator>
      <operator>erosion_rectangle1</operator>
      <operator>fill_up</operator>
      <operator>find_bar_code</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_rectangle_pose</operator>
      <operator>get_system</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>image_to_world_plane</operator>
      <operator>intersection</operator>
      <operator>mean_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_xld</operator>
      <operator>set_origin_pose</operator>
      <operator>set_system</operator>
      <operator>smallest_rectangle1_xld</operator>
      <operator>tuple_find</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>get_region_contour.hdev</name>
      <desc>Zugreifen auf die Kontur eines Objekts</desc>
      <path>hdevelop/Regions/Access/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>disp_line</operator>
      <operator>get_region_contour</operator>
      <operator>select_shape_std</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>get_region_index.hdev</name>
      <desc>Finden von Regionen, die ein vorgegebenes Pixel enthalten</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.io</method>
      <method>method.regionproc</method>
      <operator>get_mbutton</operator>
      <operator>get_region_index</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>get_region_thickness.hdev</name>
      <desc>Berechnen der Dicke von Regionen (entlang ihrer Hauptachse)</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>get_region_thickness</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>get_support_vector_class_svm.hdev</name>
      <desc>Auslesen der Support-Vektoren eines SVMs und Visualisieren dieser zusammen mit den Klassengrenzen</desc>
      <path>hdevelop/Classification/Support-Vector-Machines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <method>method.visual</method>
      <operator>add_sample_class_svm</operator>
      <operator>classify_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>create_class_svm</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>gen_region_points</operator>
      <operator>get_region_points</operator>
      <operator>get_sample_class_svm</operator>
      <operator>get_support_vector_class_svm</operator>
      <operator>get_support_vector_num_class_svm</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>train_class_svm</operator>
      <operator>union2</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>gigevision.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>gigevision_atc4_objectmodel3d.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces, um ein 3D-Objektmodell aus Automation-Technology-C4-GigE-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>apply_sheet_of_light_calibration</operator>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>set_sheet_of_light_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>gigevision_crop.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>gigevision_flir_ax5.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces um Wärmebilder mit dem FLIR-AX5-GigE-Sensor aufzunehmen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>gigevision_forceip.hdev</name>
      <desc>Verwenden von ForceIP zur korrekten Konfiguration eines fehlkonfigurierten GigEVision Geräts</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_regexp_match</operator>
      <operator>tuple_regexp_select</operator>
      <operator>tuple_str_first_n</operator>
      <operator>tuple_str_last_n</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>gigevision_frame_rate.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces (frame rate)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>gigevision_link_aggregation.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces zusammen mit statischer Link Aggregation (LAG)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gigevision_parameters.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_file</operator>
      <operator>close_framegrabber</operator>
      <operator>fwrite_string</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>gigevision_photonfocus3d_objectmodel3d.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces, um ein 3D-Objektmodell aus Photonfocus-3D02- und Photonfocus-3D03-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>apply_sheet_of_light_calibration</operator>
      <operator>close_framegrabber</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>set_sheet_of_light_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>gigevision_simple.hdev</name>
      <desc>Verwenden des GigEVision-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>ginga++.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_2cameras.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_capture_freq.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (capture frequency control)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>count_channels</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>ginga++_continuous.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_crop.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_external_drive.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (simultaner Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>ginga++_frame_exposure.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (frame exposure)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>ginga++_parameters.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_sequence.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (sequence grabbing)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>count_channels</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_simple.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_trigger.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>ginga++_walking.hdev</name>
      <desc>Verwenden des Ginga++-Interfaces (Parametrisierung, kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.4</newinversion>
   </example>
   <example>
      <name>gingadg_continuous_grabbing.hdev</name>
      <desc>Verwenden des GingaDG-Interfaces (kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gingadg_multi_woi_grabbing.hdev</name>
      <desc>Verwenden des GingaDG-Interfaces (Mehrfach WOI Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gingadg_sequence_grabbing.hdev</name>
      <desc>Verwenden des GingaDG-Interfaces (sequence grabbing)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gray_closing_rect.hdev</name>
      <desc>Ausführen eines Grauwert-Closings mit rechteckiger Maske</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_closing_rect</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_closing_shape.hdev</name>
      <desc>Ausführen eines Grauwert-Closings mit verschiedenen Maskenformen für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_closing_shape</operator>
      <operator>sub_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_dilation_rect.hdev</name>
      <desc>Bestimmen des maximalen Grauwerts in einem Rechteck für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_dilation_rect</operator>
      <operator>gray_erosion_rect</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gray_dilation_shape.hdev</name>
      <desc>Ausführen einer Grauwert-Dilatation mit verschiedenen Maskenformen für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_dilation_shape</operator>
      <operator>gray_erosion_shape</operator>
      <operator>sub_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_erosion_rect.hdev</name>
      <desc>Bestimmen des minimalen Grauwerts in einem Rechteck für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_dilation_rect</operator>
      <operator>gray_erosion_rect</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gray_erosion_shape.hdev</name>
      <desc>Ausführen einer Grauwert-Erosion mit verschiedenen Maskenformen für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_dilation_shape</operator>
      <operator>gray_erosion_shape</operator>
      <operator>sub_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_erosion_subpix.hdev</name>
      <desc>Verwenden von gray_erosion_shape mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <operator>gray_erosion_shape</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>gray_features.hdev</name>
      <desc>Berechnen von Standardgrauwertmerkmalen</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.feat</method>
      <operator>area_center</operator>
      <operator>area_center_gray</operator>
      <operator>connection</operator>
      <operator>elliptic_axis</operator>
      <operator>elliptic_axis_gray</operator>
      <operator>select_shape</operator>
      <operator>threshold</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>gray_histo.hdev</name>
      <desc>Berechnen der Grauwertverteilung einer Region</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.visual</method>
      <operator>gen_region_histo</operator>
      <operator>gray_histo</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gray_histo_range.hdev</name>
      <desc>Berechnen des Grauwerthistogramms eines Bildes in einem nutzerdefinierten Grauwertbereich</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>gray_histo_range</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>gray_moments.hdev</name>
      <desc>Berechnen der Grauwertmomente und Approximieren durch eine Ebene</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>dev_set_lut</operator>
      <operator>gen_image_gray_ramp</operator>
      <operator>moments_gray_plane</operator>
      <operator>sub_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>gray_opening.hdev</name>
      <desc>Segmentieren von Bohrlöchern mit Grauwertmorphologie</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.morphol</method>
      <method>method.segm</method>
      <operator>gray_closing</operator>
      <operator>gray_opening</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>gray_opening_rect.hdev</name>
      <desc>Ausführen eines Grauwert-Openings mit rechteckiger Maske</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_opening_rect</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_opening_shape.hdev</name>
      <desc>Ausführen eines Grauwert-Openings mit verschiedenen Maskenformen für jeden Punkt</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>gray_opening_shape</operator>
      <operator>sub_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>gray_projections.hdev</name>
      <desc>Berechnen von horizontalen und vertikalen Grauwertprojektionen einer Region</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>disp_line</operator>
      <operator>gray_projections</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>grid_rectification.hdev</name>
      <desc>Entzerren eines beliebig verzerrten Bildes unter Verwendung eines regelmäßigen Gitters</desc>
      <path>hdevelop/Tools/Grid-Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <applarea>applarea.general</applarea>
      <method>method.trafo.rectif</method>
      <method>method.barcode</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <method>method.error</method>
      <operator>connect_grid_points</operator>
      <operator>create_rectification_grid</operator>
      <operator>find_rectification_grid</operator>
      <operator>gen_grid_rectification_map</operator>
      <operator>map_image</operator>
      <operator>saddle_points_sub_pix</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>grid_rectification_arbitrary_distortion.hdev</name>
      <desc>Ermitteln von Unterschieden zwischen zwei gedruckten Seiten, auch bei Störungen in vertikaler Richtung</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.blob</method>
      <method>method.trafo.rectif</method>
      <method>method.funct1d</method>
      <method>method.match.comp</method>
      <method>method.visual</method>
      <operator>clear_component_model</operator>
      <operator>create_component_model</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>crop_part</operator>
      <operator>dyn_threshold</operator>
      <operator>elliptic_axis</operator>
      <operator>find_component_model</operator>
      <operator>funct_1d_to_pairs</operator>
      <operator>gen_arbitrary_distortion_map</operator>
      <operator>intersection</operator>
      <operator>map_image</operator>
      <operator>mean_image</operator>
      <operator>sample_funct_1d</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sub_image</operator>
      <operator>tuple_gen_const</operator>
      <operator>tuple_sort_index</operator>
      <newinversion>7.0.1</newinversion>
   </example>
   <example>
      <name>gs1_128.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1-128</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1_data_codes.hdev</name>
      <desc>Vergleichen der Dekodierergebnisse von GS1 Datacodes wenn diese als GS1 bzw. Nicht-GS1-Symbole dekodiert werden</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_composite.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1 DataBar Composite</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_result</operator>
      <operator>gray_erosion_shape</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_expanded.hdev</name>
      <desc>Lesen eines Barcodes vom Typ GS1 DataBar Expanded</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_expanded_stacked.hdev</name>
      <desc>Lesen eines Barcodes vom Typ GS1 DataBar Expanded Stacked</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_limited.hdev</name>
      <desc>Lesen eines Barcodes vom Typ GS1 DataBar Limited</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_omnidir.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1 DataBar Omnidirectional</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_stacked.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1 DataBar Stacked</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_stacked_omnidir.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1 DataBar Stacked Omnidirectional</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>gs1databar_truncated.hdev</name>
      <desc>Lesen von Barcodes vom Typ GS1 DataBara Truncated und Zeigen des Einflusses falscher Kandidaten</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>clear_bar_code_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>hamming_change_region.hdev</name>
      <desc>Erzeugen einer Region mit einer vorgegebenen Hamming-Distanz zu einer vorgegebenen Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>hamming_change_region</operator>
      <operator>hamming_distance</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>hamming_distance.hdev</name>
      <desc>Berechnen der Hamming-Distanz zwischen zwei Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>hamming_distance</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>handeye_create_robot_poses.hdev</name>
      <desc>Erlauben einer Nutzereingabe für die Roboterposen für die Hand-Auge-Kalibrierung und Speichern dieser in Dateien</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <method>method.visual</method>
      <method>method.file</method>
      <method>method.trafo.geom</method>
      <operator>clear_window</operator>
      <operator>create_pose</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>read_string</operator>
      <operator>write_pose</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>handeye_movingcam_calibration.hdev</name>
      <desc>Ausführen einer Hand-Auge-Kalibrierung für ein System mit bewegter Kamera</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.file</method>
      <method>method.trafo.geom</method>
      <operator>calibrate_hand_eye</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>query_calib_data_observ_indices</operator>
      <operator>read_cam_par</operator>
      <operator>read_pose</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>write_cam_par</operator>
      <operator>write_pose</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>handeye_movingcam_calibration_poses.hdev</name>
      <desc>Ausführen einer Hand-Auge-Kalibrierung für ein System mit bewegtem 3D-Sensor</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.file</method>
      <method>method.trafo.geom</method>
      <operator>calibrate_cameras</operator>
      <operator>calibrate_hand_eye</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>get_calib_data</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>query_calib_data_observ_indices</operator>
      <operator>read_cam_par</operator>
      <operator>set_calib_data</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_calib_data_observ_pose</operator>
      <operator>write_cam_par</operator>
      <operator>write_pose</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>handeye_stationarycam_calibration.hdev</name>
      <desc>Ausführen einer Hand-Auge-Kalibrierung für ein System mit statischer Kamera</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.file</method>
      <method>method.trafo.geom</method>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>read_cam_par</operator>
      <operator>read_pose</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>write_cam_par</operator>
      <operator>write_pose</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>handeye_stationarycam_grasp_nut.hdev</name>
      <desc>Berechnen der Pose zum Greifen einer Mutter über die Hand-Auge-Kalibrierung für ein System mit statischer Kamera</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.calib.handeye</method>
      <method>method.visual</method>
      <method>method.file</method>
      <method>method.trafo.geom</method>
      <method>method.poseestim</method>
      <method>method.xld</method>
      <method>method.blob</method>
      <method>method.trafo.wcoord</method>
      <operator>affine_trans_point_3d</operator>
      <operator>break</operator>
      <operator>caltab_points</operator>
      <operator>convert_pose_type</operator>
      <operator>dev_close_inspect_ctrl</operator>
      <operator>dev_inspect_ctrl</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_parallels_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>get_parallels_xld</operator>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>read_cam_par</operator>
      <operator>read_pose</operator>
      <operator>segment_contours_xld</operator>
      <operator>vector_to_pose</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>harmonic_interpolation.hdev</name>
      <desc>Auffüllen unrekonstruierter Flächen eines durch Stereorekonstruktion erzeugten Distanzbildes</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.semicon</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <operator>binocular_distance</operator>
      <operator>complement</operator>
      <operator>emphasize</operator>
      <operator>full_domain</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_domain</operator>
      <operator>harmonic_interpolation</operator>
      <operator>map_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>height_above_reference_plane_from_stereo.hdev</name>
      <desc>Extrahieren von Chips mit Höheninformationen aus binokularem Stereo</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.feat</method>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>binocular_distance</operator>
      <operator>binocular_disparity</operator>
      <operator>emphasize</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>get_domain</operator>
      <operator>intersection</operator>
      <operator>invert_image</operator>
      <operator>map_image</operator>
      <operator>moments_gray_plane</operator>
      <operator>scale_image</operator>
      <operator>sub_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>height_displacement.hdev</name>
      <desc>Berechnen des Messfehlers aufgrund der Abweichung des Objekts von der Messebene (für bekannte Höhen)</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.trafo.wcoord</method>
      <operator>affine_trans_point_3d</operator>
      <operator>distance_pp</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>read_cam_par</operator>
      <operator>read_pose</operator>
      <operator>set_origin_pose</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>high.hdev</name>
      <desc>Extrahieren hoher Objekte</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <operator>clip_region</operator>
      <operator>dual_rank</operator>
      <operator>dyn_threshold</operator>
      <operator>gen_disc_se</operator>
      <operator>get_system</operator>
      <operator>gray_tophat</operator>
      <operator>mean_image</operator>
      <operator>move_region</operator>
      <operator>scale_image_max</operator>
      <operator>set_system</operator>
      <operator>sub_image</operator>
      <operator>zoom_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>highpass_image.hdev</name>
      <desc>Extrahieren von hochfrequenten Komponenten aus einem Bild</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>highpass_image</operator>
      <operator>opening_circle</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>histo_2dim.hdev</name>
      <desc>Berechnen eines zweidimensionalen Histogramms (basierend auf zwei Grauwertkanälen)</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.texture</method>
      <method>method.feat</method>
      <operator>dev_set_lut</operator>
      <operator>histo_2dim</operator>
      <operator>texture_laws</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>histo_to_thresh.hdev</name>
      <desc>Bestimmen von Grauwertschwellwerten aus einem Histogramm</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>gray_histo</operator>
      <operator>histo_to_thresh</operator>
      <operator>threshold</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>holes.hdev</name>
      <desc>Extrahieren von Positionen und Radien von Löchern</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.visual</method>
      <method>method.numeric</method>
      <method>method.functions</method>
      <operator>elliptic_axis</operator>
      <operator>reduce_domain</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>hom_mat2d_reflect.hdev</name>
      <desc>Spiegeln eines Bildes um eine beliebige Achse</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>affine_trans_image</operator>
      <operator>compose3</operator>
      <operator>disp_line</operator>
      <operator>full_domain</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_reflect</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>hom_mat2d_rotate.hdev</name>
      <desc>Anwenden einer Rotation mittels einer homogenen 2D Transformationsmatrix</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>gen_image_gray_ramp</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>set_grayval</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>hom_mat2d_slant.hdev</name>
      <desc>Anwenden einer Verkippung mittels einer homogenen 2D Transformationsmatrix</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_slant</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>hom_mat2d_to_affine_par.hdev</name>
      <desc>Aufspalten einer Affintransformation in geometrische Parameter</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.io</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_pixel</operator>
      <operator>draw_point</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_to_affine_par</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>hom_mat2d_translate_local</operator>
      <operator>vector_to_hom_mat2d</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>hom_mat2d_translate.hdev</name>
      <desc>Anwenden einer Translation mittels einer homogenen 2D Transformationsmatrix</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>gen_image_gray_ramp</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>set_grayval</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>hom_mat_3d_from_3d_point_correspondences.hdev</name>
      <desc>Schätzen der 3D-Homographie aus gegebenen 3D-Punktkorrespondenzen</desc>
      <path>hdevelop/Matrix/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.numeric</method>
      <method>method.poseestim</method>
      <method>method.trafo.wcoord</method>
      <operator>add_matrix_mod</operator>
      <operator>clear_matrix</operator>
      <operator>create_matrix</operator>
      <operator>create_pose</operator>
      <operator>determinant_matrix</operator>
      <operator>get_full_matrix</operator>
      <operator>get_size_matrix</operator>
      <operator>get_sub_matrix</operator>
      <operator>get_value_matrix</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>mean_matrix</operator>
      <operator>mult_matrix</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>scale_matrix</operator>
      <operator>set_sub_matrix</operator>
      <operator>set_value_matrix</operator>
      <operator>sub_matrix</operator>
      <operator>sum_matrix</operator>
      <operator>svd_matrix</operator>
      <operator>transpose_matrix_mod</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>hom_vector_to_proj_hom_mat2d.hdev</name>
      <desc>Demonstrieren verschiedener 2D Transformationen, bei denen Punkte nach Unendlich verschoben werden</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <operator>hom_vector_to_proj_hom_mat2d</operator>
      <operator>projective_trans_image_size</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>hough_lines.hdev</name>
      <desc>Erkennen von Linien in einem Bild mittels Hough Transformation</desc>
      <path>hdevelop/Tools/Hough/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.regionproc</method>
      <method>method.hough</method>
      <method>method.roi</method>
      <operator>gen_region_hline</operator>
      <operator>hough_lines</operator>
      <operator>rectangle1_domain</operator>
      <operator>sobel_amp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>hough_lines_dir.hdev</name>
      <desc>Erkennen von Linien in einem Bild mittels Hough Transformation und der Richtungen der lokalen Gradienten</desc>
      <path>hdevelop/Tools/Hough/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <method>method.regionproc</method>
      <method>method.hough</method>
      <method>method.roi</method>
      <operator>gen_region_hline</operator>
      <operator>hough_lines_dir</operator>
      <operator>rectangle1_domain</operator>
      <operator>sobel_dir</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>hull.hdev</name>
      <desc>Untersuchen der Düse eines Spritzgussteils</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>closing_circle</operator>
      <operator>difference</operator>
      <operator>opening_circle</operator>
      <operator>select_shape</operator>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>hysteresis_threshold.hdev</name>
      <desc>Anwenden eines Hysterese-Schwellwertverfahrens auf ein Kantenbild</desc>
      <path>hdevelop/Segmentation/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.filter.edge</method>
      <operator>hysteresis_threshold</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ic.hdev</name>
      <desc>Extrahieren von Widerständen, Kondensatoren und ICs von einer Platine mittels Farbinformation</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.visual</method>
      <method>method.color</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>add_channels</operator>
      <operator>decompose3</operator>
      <operator>dilation_rectangle1</operator>
      <operator>dyn_threshold</operator>
      <operator>shape_trans</operator>
      <operator>trans_from_rgb</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>identify_vegetables.hdev</name>
      <desc>Erkennen von Gemüsesorten mit Hilfe von samplebasierter Identifikation</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.transp</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.sample</method>
      <operator>add_sample_identifier_preparation_data</operator>
      <operator>apply_sample_identifier</operator>
      <operator>clear_sample_identifier</operator>
      <operator>create_sample_identifier</operator>
      <operator>get_sample_identifier_object_info</operator>
      <operator>prepare_sample_identifier</operator>
      <operator>read_sample_identifier</operator>
      <operator>set_sample_identifier_object_info</operator>
      <operator>set_sample_identifier_param</operator>
      <operator>train_sample_identifier</operator>
      <operator>write_sample_identifier</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>illuminate.hdev</name>
      <desc>Verbessern der Detaildichte in hellen und dunklen Regionen</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>illuminate</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>image_to_world_plane.hdev</name>
      <desc>Rektifizieren eines Bildes in Bezug auf die Messebene</desc>
      <path>hdevelop/Calibration/Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>image_to_world_plane</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>import.hdev</name>
      <desc>Verwenden des import-Statements, um externe Prozeduren verfügbar zu machen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>import</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>info_edges.hdev</name>
      <desc>Schätzen der Weite eines Filters in edges_image</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>edges_image</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>info_edges</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>info_framegrabber.hdev</name>
      <desc>Abfragen von Informationen zu einem Bildeinzugs-Interface</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>info_framegrabber</operator>
      <operator>set_system</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>inner_circle.hdev</name>
      <desc>Berechnen des inneren Kreises von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>inner_circle</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>inner_rectangle1.hdev</name>
      <desc>Finden von rechteckigen Bereichen ohne Astlöchern in Holzstücken</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.wood</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.feat</method>
      <method>method.segm</method>
      <method>method.blob</method>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>dyn_threshold</operator>
      <operator>erosion_circle</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_domain</operator>
      <operator>inner_rectangle1</operator>
      <operator>mean_image</operator>
      <operator>union1</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>inpainting_aniso.hdev</name>
      <desc>Auffüllen unrekonstruierter Flächen eines durch Stereorekonstruktion erzeugten Distanzbildes</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.semicon</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <operator>binocular_distance</operator>
      <operator>clip_region</operator>
      <operator>complement</operator>
      <operator>emphasize</operator>
      <operator>full_domain</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_domain</operator>
      <operator>harmonic_interpolation</operator>
      <operator>inpainting_aniso</operator>
      <operator>map_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>inpainting_ced.hdev</name>
      <desc>Auffüllen unrekonstruierter Flächen eines durch Stereorekonstruktion erzeugten Distanzbildes</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.semicon</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <operator>binocular_distance</operator>
      <operator>clip_region</operator>
      <operator>complement</operator>
      <operator>emphasize</operator>
      <operator>full_domain</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_domain</operator>
      <operator>harmonic_interpolation</operator>
      <operator>inpainting_ced</operator>
      <operator>map_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>inpainting_ct.hdev</name>
      <desc>Entfernen eines Zauns in einem Bild von einem Luchs</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>inpainting_ct</operator>
      <operator>read_region</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>inpainting_mcf.hdev</name>
      <desc>Auffüllen unrekonstruierter Flächen eines durch Stereorekonstruktion erzeugten Distanzbildes</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.semicon</industry>
      <industry>industry.electr</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.filter.general</method>
      <operator>binocular_distance</operator>
      <operator>clip_region</operator>
      <operator>complement</operator>
      <operator>emphasize</operator>
      <operator>full_domain</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_domain</operator>
      <operator>harmonic_interpolation</operator>
      <operator>inpainting_mcf</operator>
      <operator>map_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>inpainting_texture.hdev</name>
      <desc>Entfernen ungewollter Objekte aus einem Bild durch Textur-Inpainting</desc>
      <path>hdevelop/Filters/Inpainting/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>decompose3</operator>
      <operator>dilation_circle</operator>
      <operator>inpainting_texture</operator>
      <operator>opening_circle</operator>
      <operator>trans_from_rgb</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>inspect_3d_surface_intersections.hdev</name>
      <desc>Überprüfen des Winkels und der Größe von Metalllaschen durch die Inspektion ebener Schnitte durch das 3D-Objekt</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.inspect.surface</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.geom</method>
      <method>method.laser</method>
      <method>method.match3d.surface</method>
      <method>method.object3d</method>
      <method>method.trafo.align</method>
      <method>method.xld</method>
      <method>method.laser</method>
      <operator>create_sheet_of_light_model</operator>
      <operator>create_surface_model</operator>
      <operator>disp_object_model_3d</operator>
      <operator>find_surface_model</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_plane_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>intersect_plane_object_model_3d</operator>
      <operator>reset_sheet_of_light_model</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>select_points_object_model_3d</operator>
      <operator>set_profile_sheet_of_light</operator>
      <operator>triangulate_object_model_3d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>inspect_bga.hdev</name>
      <desc>Überprüfen eines BGAs auf fehlende Balls</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.trafo.align</method>
      <operator>affine_trans_point_2d</operator>
      <operator>area_center_gray</operator>
      <operator>dilation_rectangle1</operator>
      <operator>disp_cross</operator>
      <operator>distance_pp</operator>
      <operator>elliptic_axis_gray</operator>
      <operator>fast_threshold</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_region_points</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>smallest_rectangle2</operator>
      <operator>vector_to_rigid</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>inspect_blister_photometric_stereo.hdev</name>
      <desc>Überprüfen der Rückseite eines Blisters mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.pharm</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.stereo.phot</method>
      <operator>derivate_vector_field</operator>
      <operator>photometric_stereo</operator>
      <operator>regiongrowing</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>inspect_bottle_label_360_degree.hdev</name>
      <desc>Kombinieren von vier Bildern einer Flasche zu einem Mosaikbild, das das abgewickelte Etikett der Flasche zeigt</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.food</industry>
      <industry>industry.health</industry>
      <industry>industry.pack</industry>
      <industry>industry.medsup</industry>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.calib</method>
      <method>method.geom</method>
      <method>method.match.correl</method>
      <method>method.metrol</method>
      <method>method.mosaic</method>
      <method>method.poseestim</method>
      <method>method.trafo.rectif</method>
      <operator>find_ncc_model</operator>
      <operator>fuzzy_measure_pairing</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_grayval</operator>
      <operator>get_grayval_interpolated</operator>
      <operator>get_line_of_sight</operator>
      <operator>set_camera_setup_param</operator>
      <operator>set_fuzzy_measure</operator>
      <operator>tile_images_offset</operator>
      <operator>unwarp_image_vector_field</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>inspect_bottle_mouth.hdev</name>
      <desc>Überpüfen von Flaschenköpfen auf Defekte</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.food</industry>
      <industry>industry.glass</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>auto_threshold</operator>
      <operator>boundary</operator>
      <operator>dyn_threshold</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>length_xld</operator>
      <operator>mirror_region</operator>
      <operator>polar_trans_region_inv</operator>
      <operator>union_cocircular_contours_xld</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>inspect_flooring_photometric_stereo.hdev</name>
      <desc>Überprüfen der Oberfläche von Bodenbelägen auf Defekte mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.wood</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.stereo.phot</method>
      <operator>derivate_vector_field</operator>
      <operator>photometric_stereo</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>inspect_frame_width.hdev</name>
      <desc>Überprüfen der Breite eines Handykamera-Rahmens durch Berechnung des punktweisen Abstands zwischen zwei XLD-Konturen</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.edgeextr</method>
      <method>method.geom</method>
      <method>method.xld</method>
      <operator>distance_contours_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>segment_contour_attrib_xld</operator>
      <operator>smooth_contours_xld</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>inspect_gasket_local_deformable.hdev</name>
      <desc>Finden und Inspizieren einer Dichtung</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.auto</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.inspect.complete</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.ldeform</method>
      <method>method.varmodel</method>
      <operator>clear_deformable_model</operator>
      <operator>clear_variation_model</operator>
      <operator>compare_variation_model</operator>
      <operator>create_local_deformable_model</operator>
      <operator>create_variation_model</operator>
      <operator>find_local_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>prepare_direct_variation_model</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>inspect_harddisk_temperature.hdev</name>
      <desc>Bestimmen der Wärmeabstrahlung einer Festplatte aus einem Infrarotbild</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>intensity</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>inspect_leather_photometric_stereo.hdev</name>
      <desc>Überprüfen von Lederstücken auf Defekte mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.synth</industry>
      <industry>industry.auto</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.stereo.phot</method>
      <operator>derivate_vector_field</operator>
      <operator>photometric_stereo</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>inspect_scanlines.hdev</name>
      <desc>Überprüfen der Scanlinien von Barcodes</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_object</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>inspect_shampoo_label.hdev</name>
      <desc>Überprüfen der Position eines Etiketts auf einer Haarwaschmittelflasche</desc>
      <path>hdevelop/Applications/Alignment/</path>
      <industry>industry.pack</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.regionproc</method>
      <method>method.match.shape</method>
      <operator>add_channels</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>find_shape_models</operator>
      <operator>inspect_shape_model</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>inspect_shampoo_label_photometric_stereo.hdev</name>
      <desc>Überprüfen des Etiketts auf einer Haarwaschmittelflasche auf Unebenheiten mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/Surface-Inspection/</path>
      <industry>industry.pack</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.stereo.phot</method>
      <operator>derivate_vector_field</operator>
      <operator>photometric_stereo</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>inspect_solar_fingers.hdev</name>
      <desc>Extrahieren von Kontaktstreifen auf Solarzellen</desc>
      <path>hdevelop/Applications/Completeness-Check/</path>
      <industry>industry.solar</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>erosion_rectangle1</operator>
      <operator>select_shape</operator>
      <operator>threshold</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>intensity.hdev</name>
      <desc>Berechnen des mittleren Grauwerts und der Abweichung innerhalb einer Region</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>intensity</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>interactive_intersection.hdev</name>
      <desc>Interaktives Berechnen des Schnitts zwischen einem 3D-Objektmodell und einer Ebene</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>affine_trans_object_model_3d</operator>
      <operator>axis_angle_to_quat</operator>
      <operator>clear_object_model_3d</operator>
      <operator>connection_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>intersect_plane_object_model_3d</operator>
      <operator>quat_to_hom_mat3d</operator>
      <operator>read_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>interest_points_comparison.hdev</name>
      <desc>Vergleichen der Ergebnisse aus verschiedenen Punktoperatoren</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>overpaint_region</operator>
      <operator>points_foerstner</operator>
      <operator>points_harris</operator>
      <operator>points_harris_binomial</operator>
      <operator>points_lepetit</operator>
      <operator>points_sojka</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>interface_digital_read.hdev</name>
      <desc>Verwenden des Interface-Interfaces (einfaches Lesen der digitalen Eingänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>interface_digital_write.hdev</name>
      <desc>Verwenden des Interface-Interfaces (einfaches Schreiben der digitalen Ausgänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>write_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>interjacent.hdev</name>
      <desc>Partitionieren der Bildebene durch vorgegebene Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.visual</method>
      <method>method.regionproc</method>
      <operator>interjacent</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>interpolate_scattered_data.hdev</name>
      <desc>Interpolation verstreuter Datenpunkte</desc>
      <path>hdevelop/Tools/Interpolation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>interpolate_scattered_data_image</operator>
      <operator>interpolate_scattered_data_points_to_image</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>intersect_lines_of_sight.hdev</name>
      <desc>Rekonstruieren von 3D-Information durch Verschneidung von Sichtlinien</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.geom</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>caltab_points</operator>
      <operator>create_pose</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>intersect_lines_of_sight</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>sim_caltab</operator>
      <operator>tuple_sub</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>intersect_lines_of_sight_targets.hdev</name>
      <desc>Messen der Höhe eines Werkstücks mittels eines Stereoaufbaus</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.edgeextr</method>
      <method>method.stereo</method>
      <operator>critical_points_sub_pix</operator>
      <operator>intersect_lines_of_sight</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>intersect_plane_object_model_3d.hdev</name>
      <desc>Berechnen des Schnitts zwischen einem 3D-Objektmodell und einer Ebene</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>connection_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>intersect_plane_object_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>intersection_closed_contours_xld.hdev</name>
      <desc>Verwenden von intersection_closed_contours_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>intersection_closed_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>intersection_closed_polygons_xld.hdev</name>
      <desc>Verwenden von intersection_closed_polygons_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>intersection_closed_polygons_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>intersection_contours.hdev</name>
      <desc>Berechnen der Schnittpunkte von Linien, Kreisen und XLD-Konturen</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.geom</method>
      <operator>intersection_circle_contour_xld</operator>
      <operator>intersection_circles</operator>
      <operator>intersection_contours_xld</operator>
      <operator>intersection_line_circle</operator>
      <operator>intersection_line_contour_xld</operator>
      <operator>intersection_lines</operator>
      <operator>intersection_segment_circle</operator>
      <operator>intersection_segment_contour_xld</operator>
      <operator>intersection_segment_line</operator>
      <operator>intersection_segments</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>invert_funct_1d.hdev</name>
      <desc>Invertieren und Plotten einer 1D Funktion und Vergleichen des Ergebnisses mit der analytischen Inversen</desc>
      <path>hdevelop/Tools/Function/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.funct1d</method>
      <method>method.tuple</method>
      <operator>create_funct_1d_pairs</operator>
      <operator>invert_funct_1d</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>isotropic_diffusion.hdev</name>
      <desc>Glätten eines Bildes mit isotroper Diffusion</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>isotropic_diffusion</operator>
      <operator>reduce_domain</operator>
      <operator>smooth_image</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>junction_skeleton.hdev</name>
      <desc>Berechnen und Aufspalten eines Skeletts an Knotenpunkten</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>dyn_threshold</operator>
      <operator>junctions_skeleton</operator>
      <operator>mean_image</operator>
      <operator>opening_rectangle1</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>kirsch_amp.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude) mit dem Kirsch Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>kirsch_amp</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>kirsch_dir.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit dem Kirsch Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>kirsch_dir</operator>
      <operator>nonmax_suppression_dir</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>label_to_region.hdev</name>
      <desc>Extrahieren von Regionen gleichen Grauwerts ('gelabelte' Region)</desc>
      <path>hdevelop/Regions/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.regionproc</method>
      <operator>label_to_region</operator>
      <operator>scale_image</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>label_word_process_mlp.hdev</name>
      <desc>Lesen des Mindesthaltbarkeitsdatums mit Ergebnisverfeinerung durch Verwendung eines Lexikons</desc>
      <path>hdevelop/OCR/Neural-Nets/</path>
      <industry>industry.food</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.blob</method>
      <method>method.trafo.align</method>
      <method>method.roi</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>area_center</operator>
      <operator>clear_lexicon</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>connection</operator>
      <operator>create_lexicon</operator>
      <operator>dev_set_color</operator>
      <operator>dev_set_colored</operator>
      <operator>do_ocr_word_mlp</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>move_region</operator>
      <operator>opening_circle</operator>
      <operator>partition_dynamic</operator>
      <operator>read_image</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape</operator>
      <operator>shape_trans</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sort_region</operator>
      <operator>text_line_orientation</operator>
      <operator>threshold</operator>
      <operator>var_threshold</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>laplace.hdev</name>
      <desc>Extrahieren von Kanten mit dem Laplace-Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>laplace</operator>
      <operator>laplace_of_gauss</operator>
      <operator>zero_crossing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>laplace_of_gauss.hdev</name>
      <desc>Extrahieren von Kanten mit dem LoG-Operator (Laplace of Gaussian)</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>derivate_gauss</operator>
      <operator>diff_of_gauss</operator>
      <operator>laplace_of_gauss</operator>
      <operator>zero_crossing</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>lens_distortions.hdev</name>
      <desc>Entzerren von Kanten, die aus einem verzerrten Bild extrahiert wurden</desc>
      <path>hdevelop/Calibration/Rectification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.rectif</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_contours_xld</operator>
      <operator>edges_sub_pix</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>6.1.3</newinversion>
   </example>
   <example>
      <name>letter.hdev</name>
      <desc>Lesen gedruckter Schriftzeichen mit interaktiver Auswahl</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.visual</method>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>dev_set_shape</operator>
      <operator>dilation_circle</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>get_mbutton</operator>
      <operator>get_region_index</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>sort_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>letters_knn.hdev</name>
      <desc>Trainieren eines k-NN-OCR-Klassifikators und Neuklassifizieren der Trainingsmuster</desc>
      <path>hdevelop/OCR/k-Nearest-Neighbor/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.classif</method>
      <method>method.segm</method>
      <operator>clear_ocr_class_knn</operator>
      <operator>create_ocr_class_knn</operator>
      <operator>delete_file</operator>
      <operator>do_ocr_multi_class_knn</operator>
      <operator>file_exists</operator>
      <operator>intersection</operator>
      <operator>read_ocr_trainf_names</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>letters_mlp.hdev</name>
      <desc>Trainieren eines MLP-basierten OCR-Klassifikators und Neuklassifizieren der Trainingsmuster</desc>
      <path>hdevelop/OCR/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.classif</method>
      <method>method.segm</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>file_exists</operator>
      <operator>intersection</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>letters_svm.hdev</name>
      <desc>Trainieren eines SVM-basierten OCR-Klassifikators und Neuklassifizieren der Trainingsmuster</desc>
      <path>hdevelop/OCR/Support-Vector-Machines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.classif</method>
      <method>method.blob</method>
      <operator>area_center</operator>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_svm</operator>
      <operator>connection</operator>
      <operator>create_ocr_class_svm</operator>
      <operator>delete_file</operator>
      <operator>dilation_circle</operator>
      <operator>do_ocr_multi_class_svm</operator>
      <operator>file_exists</operator>
      <operator>intersection</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_svm</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>lettert.hdev</name>
      <desc>Trainieren und Reklassifizieren von gedruckten Schriftzeichen</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.error</method>
      <operator>append_ocr_trainf</operator>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>copy_obj</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>dev_set_shape</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>lexicon.hdev</name>
      <desc>Verwenden eines Lexikons</desc>
      <path>hdevelop/OCR/Lexica/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.lexica</method>
      <operator>clear_lexicon</operator>
      <operator>create_lexicon</operator>
      <operator>inspect_lexicon</operator>
      <operator>lookup_lexicon</operator>
      <operator>suggest_lexicon</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>line_scan.hdev</name>
      <desc>Simulieren des Bildeinzugs einer Zeilenkamera und Vereinen von Bildern und extrahierten Regionen</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <operator>add_channels</operator>
      <operator>close_framegrabber</operator>
      <operator>copy_obj</operator>
      <operator>crop_part</operator>
      <operator>gen_empty_region</operator>
      <operator>gen_image_const</operator>
      <operator>grab_image</operator>
      <operator>merge_regions_line_scan</operator>
      <operator>move_region</operator>
      <operator>open_framegrabber</operator>
      <operator>orientation_region</operator>
      <operator>tile_images_offset</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>line_scan_calibration.hdev</name>
      <desc>Demonstrieren der Kamerakalibrierung mit Bildern von Zeilenkameras</desc>
      <path>hdevelop/Calibration/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.io</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>disp_caltab</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data_observ_points</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>lines_color.hdev</name>
      <desc>Extrahieren von Kanten unter Verwendung von Farbinformation</desc>
      <path>hdevelop/Filters/Lines/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.color</method>
      <method>method.visual</method>
      <operator>assign</operator>
      <operator>concat_obj</operator>
      <operator>count_obj</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_empty_obj</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>lines_color</operator>
      <operator>lines_gauss</operator>
      <operator>rgb1_to_gray</operator>
      <operator>select_contours_xld</operator>
      <operator>select_obj</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>lines_facet.hdev</name>
      <desc>Extrahieren von Linien unter Verwendung des Facetmodells</desc>
      <path>hdevelop/Filters/Lines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <operator>lines_facet</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>lines_gauss.hdev</name>
      <desc>Extrahieren von Linien und ihrer Breite</desc>
      <path>hdevelop/Filters/Lines/</path>
      <industry>industry.general</industry>
      <industry>industry.health</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>assign</operator>
      <operator>count_obj</operator>
      <operator>disp_polygon</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>lines_gauss</operator>
      <operator>select_obj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>linx.hdev</name>
      <desc>Verwenden des LinX-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>linx_2boards.hdev</name>
      <desc>Verwenden des LinX-Interfaces (zwei Boards)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>linx_2ports.hdev</name>
      <desc>Verwenden des LinX-Interfaces (zwei Kameras, Anschlusswechsel)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>linx_2simultaneous.hdev</name>
      <desc>Verwenden des LinX-Interfaces (simultaner Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>linx_cont.hdev</name>
      <desc>Verwenden des LinX-Interfaces (Parametrisierung, kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>linx_simple.hdev</name>
      <desc>Verwenden des LinX-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>list_files.hdev</name>
      <desc>Auflisten aller Dateien eines Verzeichnisses</desc>
      <path>hdevelop/File/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <method>method.opsys</method>
      <operator>get_system</operator>
      <operator>list_files</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>local_max.hdev</name>
      <desc>Erkennen lokaler Maxima in einem Bild</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>get_system</operator>
      <operator>local_max</operator>
      <operator>set_system</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>local_max_sub_pix.hdev</name>
      <desc>Erkennen lokaler Maxima mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <method>method.visual</method>
      <operator>corner_response</operator>
      <operator>local_max_sub_pix</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>local_min.hdev</name>
      <desc>Erkennen lokaler Minima und Maxima in einem Bild</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>get_system</operator>
      <operator>invert_image</operator>
      <operator>local_max</operator>
      <operator>local_min</operator>
      <operator>set_system</operator>
      <operator>symm_difference</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>local_threshold.hdev</name>
      <desc>Segmentieren eines Bildes mit einem lokalen Schwellwert</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>local_threshold</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>locate_car_door.hdev</name>
      <desc>Auffinden einer Autotür mit perspektivisch deformierbarem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.calib</method>
      <method>method.match.deform</method>
      <method>method.trafo.geom</method>
      <method>method.poseestim</method>
      <method>method.tuple</method>
      <operator>caltab_points</operator>
      <operator>clear_deformable_model</operator>
      <operator>create_planar_calib_deformable_model</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>find_planar_calib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>get_deformable_model_params</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>locate_cookie_box.hdev</name>
      <desc>Auffinden einer Keksschachtel mit deskriptorbasiertem Matching</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.descr</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <operator>clear_descriptor_model</operator>
      <operator>close_contours_xld</operator>
      <operator>create_calib_descriptor_model</operator>
      <operator>find_calib_descriptor_model</operator>
      <operator>get_descriptor_model_points</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>read_descriptor_model</operator>
      <operator>vector_to_pose</operator>
      <operator>write_descriptor_model</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>locate_cookie_box_multiple_models.hdev</name>
      <desc>Auffinden von Keksschachteln mit deskriptorbasiertem Matching</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.descr</method>
      <method>method.poseestim</method>
      <operator>clear_descriptor_model</operator>
      <operator>create_calib_descriptor_model</operator>
      <operator>find_calib_descriptor_model</operator>
      <operator>get_descriptor_model_points</operator>
      <operator>image_points_to_world_plane</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>locate_cylinder_3d.hdev</name>
      <desc>Auffinden des höchstliegenden Zylinders aus einer Menge von Zylindern durch Kombination von Stereo und 3D-Matching</desc>
      <path>hdevelop/Applications/Object-Recognition-3D/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object3d</applarea>
      <method>method.stereo</method>
      <method>method.match3d.shape</method>
      <method>method.tuple</method>
      <operator>binocular_disparity</operator>
      <operator>clear_object_model_3d</operator>
      <operator>clear_shape_model_3d</operator>
      <operator>create_shape_model_3d</operator>
      <operator>find_shape_model_3d</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_shape_model_3d_params</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_3d_point</operator>
      <operator>project_shape_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>read_shape_model_3d</operator>
      <operator>regiongrowing_n</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>locate_engine_parts.hdev</name>
      <desc>Auffinden eines Motorteils mit perspektivisch deformierbarem Matching</desc>
      <path>hdevelop/Applications/Position-Recognition-3D/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.blob</method>
      <method>method.match.deform</method>
      <method>method.poseestim</method>
      <method>method.trafo.geom</method>
      <method>method.tuple</method>
      <operator>clear_deformable_model</operator>
      <operator>contour_to_world_plane_xld</operator>
      <operator>create_planar_calib_deformable_model</operator>
      <operator>find_planar_calib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>get_deformable_model_params</operator>
      <operator>vector_to_pose</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>locate_pipe_joints_stereo.hdev</name>
      <desc>Auffinden von Rohrverbindungen durch Multi-View Stereo und oberflächenbasiertes 3D-Matching</desc>
      <path>hdevelop/Applications/Robot-Vision/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.robotvis</applarea>
      <method>method.match3d.surface</method>
      <method>method.poseestim</method>
      <method>method.stereo.multi</method>
      <operator>clear_camera_setup_model</operator>
      <operator>clear_object_model_3d</operator>
      <operator>clear_stereo_model</operator>
      <operator>clear_surface_model</operator>
      <operator>create_camera_setup_model</operator>
      <operator>create_stereo_model</operator>
      <operator>create_surface_model</operator>
      <operator>find_surface_model</operator>
      <operator>get_camera_setup_param</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>project_object_model_3d</operator>
      <operator>read_camera_setup_model</operator>
      <operator>read_object_model_3d</operator>
      <operator>reconstruct_surface_stereo</operator>
      <operator>set_camera_setup_cam_param</operator>
      <operator>set_stereo_model_image_pairs</operator>
      <operator>set_stereo_model_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>lowlands.hdev</name>
      <desc>Erkennen von Grauwert-Plateaus und Grauwert-Tiefebenen</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>invert_image</operator>
      <operator>lowlands</operator>
      <operator>plateaus</operator>
      <operator>smooth_image</operator>
      <operator>symm_difference</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>lowlands_center.hdev</name>
      <desc>Erkennen der Zentren von Grauwert-Plateaus und Grauwert-Tiefebenen</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>invert_image</operator>
      <operator>lowlands_center</operator>
      <operator>plateaus_center</operator>
      <operator>smooth_image</operator>
      <operator>symm_difference</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>lps36_objectmodel3d.hdev</name>
      <desc>Verwenden des LPS36-Interfaces, um ein 3D-Objektmodell aus Leuze-LPS36-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>overpaint_region</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>lps36_parameters.hdev</name>
      <desc>Verwenden des LPS36-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>lps36_simple.hdev</name>
      <desc>Verwenden des LPS36-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>lucam_2cameras.hdev</name>
      <desc>Verwenden des LuCam-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>lucam_crop.hdev</name>
      <desc>Verwenden des LuCam-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>lucam_parameters.hdev</name>
      <desc>Verwenden des LuCam-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>lucam_simple.hdev</name>
      <desc>Verwenden des LuCam-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>lut_trans.hdev</name>
      <desc>Transformieren von Grauwerten unter Verwendung einer Look-Up Tabelle</desc>
      <path>hdevelop/Filters/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>lut_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>make_and_remove_dir.hdev</name>
      <desc>Anlegen und Entfernen von Verzeichnissen</desc>
      <path>hdevelop/File/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>delete_file</operator>
      <operator>dev_close_inspect_ctrl</operator>
      <operator>dev_inspect_ctrl</operator>
      <operator>file_exists</operator>
      <operator>list_files</operator>
      <operator>make_dir</operator>
      <operator>open_file</operator>
      <operator>remove_dir</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>map_image.hdev</name>
      <desc>Anwenden einer allgemeinen Transformation auf ein Bild</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.error</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.rectif</method>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>map_image</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>match_function_trans.hdev</name>
      <desc>Berechnen der Transformationsparameter zwischen zwei Funktionen</desc>
      <path>hdevelop/Tools/Function/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.funct1d</method>
      <method>method.numeric</method>
      <method>method.tuple</method>
      <operator>create_funct_1d_array</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>for</operator>
      <operator>match_funct_1d_trans</operator>
      <operator>sample_funct_1d</operator>
      <operator>transform_funct_1d</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>match_function_trans_plot.hdev</name>
      <desc>Berechnen der Transformationsparameter zwischen zwei Funktionen und grafische Ausgabe der Ergebnisse (gnuplot)</desc>
      <path>hdevelop/Tools/Function/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.funct1d</method>
      <method>method.tuple</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>create_funct_1d_array</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>gnuplot_close</operator>
      <operator>gnuplot_open_file</operator>
      <operator>gnuplot_plot_funct_1d</operator>
      <operator>match_funct_1d_trans</operator>
      <operator>sample_funct_1d</operator>
      <operator>transform_funct_1d</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>match_function_trans_time.hdev</name>
      <desc>Messen der Zeit für das Berechnen von Transformationsparametern zwischen zwei Funktionen</desc>
      <path>hdevelop/Tools/Function/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.funct1d</method>
      <method>method.numeric</method>
      <method>method.tuple</method>
      <operator>count_seconds</operator>
      <operator>create_funct_1d_array</operator>
      <operator>create_funct_1d_pairs</operator>
      <operator>match_funct_1d_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>match_fundamental_matrix_distortion_ransac_general.hdev</name>
      <desc>Berechnen einer Fundamentalmatrix unter Beachtung radialer Verzeichnungen</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity_mg</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_binocular_proj_rectification</operator>
      <operator>match_fundamental_matrix_distortion_ransac</operator>
      <operator>projective_trans_image_size</operator>
      <operator>projective_trans_point_2d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>match_fundamental_matrix_distortion_ransac_trans.hdev</name>
      <desc>Berechnen einer Fundamentalmatrix unter Beachtung radialer Verzeichnungen (Translation)</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>binocular_disparity_mg</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_binocular_proj_rectification</operator>
      <operator>match_fundamental_matrix_distortion_ransac</operator>
      <operator>match_fundamental_matrix_ransac</operator>
      <operator>projective_trans_image_size</operator>
      <operator>projective_trans_point_2d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>matching_coins.hdev</name>
      <desc>Unterscheiden von Münzen mit formbasiertem Matching</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_models</operator>
      <operator>get_shape_model_contours</operator>
      <operator>select_shape_std</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>matching_defocused_pcb.hdev</name>
      <desc>Bestimmen der Position eines PCBs in defokussierten Bildern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>matching_deformed_bulb.hdev</name>
      <desc>Auffinden von Halogenstrahlerkontakten</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.tuple</method>
      <method>method.regexp</method>
      <operator>continue</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>tuple_regexp_select</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>matching_green_dot.hdev</name>
      <desc>Auffinden skalierter und rotierter Formmodelle</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>read_shape_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>matching_image_border.hdev</name>
      <desc>Auffinden mehrerer Dies, auch wenn diese über den Bildrand hinausgehen</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_models</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_shape_model_contours</operator>
      <operator>read_image</operator>
      <operator>set_system</operator>
      <operator>tuple_gen_const</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>matching_multi_channel_clamp.hdev</name>
      <desc>Auffinden der obersten Klammer aus einer Menge von Klammern mit formbasiertem Matching in Farbbildern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.color</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <operator>clear_shape_model</operator>
      <operator>copy_obj</operator>
      <operator>create_aniso_shape_model</operator>
      <operator>find_aniso_shape_models</operator>
      <operator>get_shape_model_contours</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>matching_multi_channel_yogurt.hdev</name>
      <desc>Auffinden von Joghurts verschiedener Geschmacksrichtungen mit formbasiertem Matching in Farbbildern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.color</method>
      <method>method.blob</method>
      <method>method.xld</method>
      <method>method.roi</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>fast_threshold</operator>
      <operator>fill_up</operator>
      <operator>find_shape_models</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>get_shape_model_contours</operator>
      <operator>opening_circle</operator>
      <operator>read_image</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>gen_struct_elements</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire_crop.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire_multiple_instances.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (zwei Handles für eine Kamera mit unterschiedlichen Parametersätzen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire_parameters.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire_properties.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (verschiedene Parametereinstellungen und Belichtungszeiten)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>matrixvisionacquire_simple.hdev</name>
      <desc>Verwenden des MatrixVisionAcquire-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>max_connection.hdev</name>
      <desc>Einschränken der durch den Operator connection zurückgegebenen Anzahl an Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.blob</method>
      <operator>connection</operator>
      <operator>get_system</operator>
      <operator>set_system</operator>
      <newinversion>6.0.1</newinversion>
   </example>
   <example>
      <name>max_image.hdev</name>
      <desc>Pixelweises Berechnen des Maximums zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>crop_part</operator>
      <operator>max_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>mean_curvature_flow.hdev</name>
      <desc>Verbessern eines Angiografiebildes unter Verwendung der Krümmungsflussgleichung</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>mean_curvature_flow</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>measure_arc.hdev</name>
      <desc>Messen der Breite eines Metallstücks entlang eines Kreisbogens</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>disp_arc</operator>
      <operator>disp_line</operator>
      <operator>distance_pp</operator>
      <operator>gen_measure_arc</operator>
      <operator>get_points_ellipse</operator>
      <operator>measure_pos</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>measure_ball_bond.hdev</name>
      <desc>Überprüfen der Positionen von Ball-Bondierungen auf einem Pad</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.segm</method>
      <method>method.xld</method>
      <operator>area_center_xld</operator>
      <operator>boundary</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_bga_dff.hdev</name>
      <desc>Rekonstruieren der Höhe einer Zinnkugel auf einem BGA mit Depth from Focus</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.dff</method>
      <method>method.image</method>
      <operator>channels_to_image</operator>
      <operator>depth_from_focus</operator>
      <operator>select_grayvalues_from_channels</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_caliper.hdev</name>
      <desc>Messen der Abstände zwischen den Teilstrichen einer Schieblehre</desc>
      <path>solution_guide/1d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.trafo.wcoord</method>
      <method>method.metrol</method>
      <method>method.funct1d</method>
      <operator>close_measure</operator>
      <operator>create_funct_1d_array</operator>
      <operator>derivate_funct_1d</operator>
      <operator>distance_pp</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_y_value_funct_1d</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>measure_projection</operator>
      <operator>rotate_image</operator>
      <operator>smooth_funct_1d_gauss</operator>
      <operator>zero_crossings_funct_1d</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>measure_chip.hdev</name>
      <desc>Ermitteln der Ausmaße und Positionen rechteckiger Chip-Komponenten</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>boundary</operator>
      <operator>dilation_rectangle1</operator>
      <operator>distance_pp</operator>
      <operator>edges_sub_pix</operator>
      <operator>fast_threshold</operator>
      <operator>fit_rectangle2_contour_xld</operator>
      <operator>gen_rectangle2</operator>
      <operator>gen_rectangle2_contour_xld</operator>
      <operator>opening_rectangle1</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>smallest_rectangle2</operator>
      <operator>threshold_sub_pix</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_circles.hdev</name>
      <desc>Ermitteln der Radien und Positionen kreisförmiger Formen</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.geom</method>
      <operator>boundary</operator>
      <operator>dilation_circle</operator>
      <operator>disp_arrow</operator>
      <operator>distance_pp</operator>
      <operator>edges_sub_pix</operator>
      <operator>fast_threshold</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>union1</operator>
      <operator>union_cocircular_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_circuit_width_lines_gauss.hdev</name>
      <desc>Messen der Breite von Leiterbahnen auf einer Platine</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.segm</method>
      <method>method.xld</method>
      <method>method.morphol</method>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>gen_region_points</operator>
      <operator>get_contour_attrib_xld</operator>
      <operator>lines_gauss</operator>
      <operator>select_shape_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_diamond.hdev</name>
      <desc>Untersuchen eines Diamants</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.glass</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.segm</method>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <method>method.morphol</method>
      <operator>clip_region_rel</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>shape_trans</operator>
      <operator>union_collinear_contours_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_fill_level.hdev</name>
      <desc>Überprüfen des Füllstands von Ampullen</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.pharm</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.alignment</applarea>
      <method>method.match.shape</method>
      <method>method.metrol</method>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_pos</operator>
      <operator>translate_measure</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_grid.hdev</name>
      <desc>Ermitteln von Knotenpunkten eines Gitters zwischen den Tasten einer Tastatur</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.geom</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.geom</method>
      <operator>assign</operator>
      <operator>closing_circle</operator>
      <operator>concat_obj</operator>
      <operator>count_obj</operator>
      <operator>distance_ps</operator>
      <operator>dyn_threshold</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>gen_empty_obj</operator>
      <operator>get_contour_xld</operator>
      <operator>get_region_points</operator>
      <operator>junctions_skeleton</operator>
      <operator>mean_image</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_obj</operator>
      <operator>select_shape</operator>
      <operator>skeleton</operator>
      <operator>union_collinear_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_ic_leads.hdev</name>
      <desc>Vermessen der Kontakte eines ICs</desc>
      <path>solution_guide/1d_measuring/</path>
      <industry>industry.general</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.visual</method>
      <method>method.metrol</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>measure_pairs</operator>
      <operator>measure_pos</operator>
      <operator>translate_measure</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>measure_lcd_cells.hdev</name>
      <desc>Messen der Ausmaße der Rahmen, die die Solarzellen eines LCD Displays voneinander trennen</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <method>method.geom</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_pairs</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>measure_metal_part.hdev</name>
      <desc>Untersuchen von Metallstücken durch Fitting von Linien und Kreisen</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>distance_pp</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>sort_contours_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>measure_metal_part_extended.hdev</name>
      <desc>Messen verschiedener Merkmale eines Metallstücks</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.geom</method>
      <method>method.filter.points</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.geom</method>
      <operator>angle_ll</operator>
      <operator>area_center</operator>
      <operator>area_center_xld</operator>
      <operator>assign</operator>
      <operator>boundary</operator>
      <operator>concat_obj</operator>
      <operator>count_obj</operator>
      <operator>disp_cross</operator>
      <operator>disp_line</operator>
      <operator>dist_ellipse_contour_xld</operator>
      <operator>distance_pp</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_empty_obj</operator>
      <operator>gen_parallels_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>get_parallels_xld</operator>
      <operator>orientation_region</operator>
      <operator>orientation_xld</operator>
      <operator>points_foerstner</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_obj</operator>
      <operator>smallest_rectangle2</operator>
      <operator>smallest_rectangle2_xld</operator>
      <operator>sort_contours_xld</operator>
      <operator>threshold</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_metal_part_first_example.hdev</name>
      <desc>Messen verschiedener Merkmale eines Metallstücks</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.geom</method>
      <operator>distance_pp</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>orientation_region</operator>
      <operator>segment_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_metal_part_id.hdev</name>
      <desc>Überprüfen eines Metallstücks auf fehlende oder abweichende kreisförmige Formen</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.trafo.align</method>
      <method>method.geom</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_pixel</operator>
      <operator>dilation_rectangle1</operator>
      <operator>distance_pp</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_circle</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_slant</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>orientation_region</operator>
      <operator>read_image</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>sort_contours_xld</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_pads_subpix.hdev</name>
      <desc>Messen der Ausmaße von Pads auf einem Die</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.regionproc</method>
      <method>method.trafo.geom</method>
      <method>method.segm</method>
      <method>method.xld</method>
      <operator>fit_rectangle2_contour_xld</operator>
      <operator>gen_rectangle2_contour_xld</operator>
      <operator>union_adjacent_contours_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_perspective_scratch.hdev</name>
      <desc>Messen der Länge eines Kratzers in Weltkoordinaten</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.calib</method>
      <method>method.xld</method>
      <operator>area_center_points_xld</operator>
      <operator>calibrate_cameras</operator>
      <operator>create_calib_data</operator>
      <operator>fast_threshold</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>get_calib_data</operator>
      <operator>length_xld</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_calib_data_observ_points</operator>
      <operator>set_origin_pose</operator>
      <operator>skeleton</operator>
      <operator>tuple_replace</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_pin.hdev</name>
      <desc>Messen der Kontakte eines ICs</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <method>method.numeric</method>
      <operator>close_measure</operator>
      <operator>disp_line</operator>
      <operator>disp_rectangle1</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>measure_pairs</operator>
      <operator>measure_pos</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>measure_pump.hdev</name>
      <desc>Messen der Positionen und Radien kreisförmiger Formen</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>dilation_circle</operator>
      <operator>dist_ellipse_contour_xld</operator>
      <operator>fast_threshold</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_circle_contour_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>select_shape_xld</operator>
      <operator>shape_trans</operator>
      <operator>sort_contours_xld</operator>
      <operator>threshold_sub_pix</operator>
      <operator>union1</operator>
      <operator>union_cocircular_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_ring.hdev</name>
      <desc>Bestimmen der Breite von Zahnrädern mit einem kreisförmigen Messobjekt</desc>
      <path>solution_guide/1d_measuring/</path>
      <industry>industry.machine</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.blob</method>
      <method>method.geom</method>
      <method>method.visual</method>
      <operator>binary_threshold</operator>
      <operator>close_measure</operator>
      <operator>compactness</operator>
      <operator>distance_pp</operator>
      <operator>gen_measure_arc</operator>
      <operator>get_region_polygon</operator>
      <operator>inner_circle</operator>
      <operator>line_orientation</operator>
      <operator>measure_pairs</operator>
      <operator>smallest_circle</operator>
      <operator>tuple_sort_index</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>measure_screw.hdev</name>
      <desc>Messen verschiedener Merkmale einer Schraube</desc>
      <path>solution_guide/2d_measuring/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <method>method.edgeextr</method>
      <method>method.roi</method>
      <method>method.geom</method>
      <method>method.trafo.align</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <method>method.geom</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_region</operator>
      <operator>boundary</operator>
      <operator>clip_contours_xld</operator>
      <operator>closing_circle</operator>
      <operator>derivate_gauss</operator>
      <operator>dev_close_window</operator>
      <operator>dev_open_window</operator>
      <operator>dev_set_part</operator>
      <operator>dev_set_window</operator>
      <operator>disp_cross</operator>
      <operator>distance_pc</operator>
      <operator>distance_pp</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_rectangle1</operator>
      <operator>gen_region_line</operator>
      <operator>get_contour_xld</operator>
      <operator>get_region_runs</operator>
      <operator>orientation_region</operator>
      <operator>projection_pl</operator>
      <operator>reduce_domain</operator>
      <operator>select_contours_xld</operator>
      <operator>smallest_rectangle1_xld</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>zero_crossing_sub_pix</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>measure_solder_paste_dff.hdev</name>
      <desc>Rekonstruieren der Lötpaste auf einem BGA-Pad mit Depth from Focus</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.dff</method>
      <method>method.image</method>
      <operator>channels_to_image</operator>
      <operator>depth_from_focus</operator>
      <operator>median_rect</operator>
      <operator>select_grayvalues_from_channels</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>measure_stamping_part.hdev</name>
      <desc>Messen von Kreisen, Rechtecken und Linien eines Stanzteils mit Hilfe eines ausgerichteten Messmodels (kalibriert)</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.auto</industry>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.measure.2D</applarea>
      <method>method.match.shape</method>
      <method>method.geom</method>
      <method>method.trafo.align</method>
      <method>method.metrol</method>
      <operator>add_metrology_object_generic</operator>
      <operator>affine_trans_point_3d</operator>
      <operator>align_metrology_model</operator>
      <operator>apply_metrology_model</operator>
      <operator>clear_metrology_model</operator>
      <operator>create_metrology_model</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>get_metrology_object_measures</operator>
      <operator>get_metrology_object_model_contour</operator>
      <operator>get_metrology_object_result</operator>
      <operator>get_metrology_object_result_contour</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>set_metrology_model_image_size</operator>
      <operator>set_metrology_model_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>measure_switch.hdev</name>
      <desc>Ermitteln der Breite und der Distanz zwischen den Kontakten eines Schalters</desc>
      <path>solution_guide/1d_measuring/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.visual</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_pairs</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>measure_tft_cells.hdev</name>
      <desc>Messen der Ausmaße von RGB Zellen eines TFT LCD Displays</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.electr</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.measure.2D</applarea>
      <method>method.metrol</method>
      <method>method.funct1d</method>
      <method>method.blob</method>
      <method>method.segm</method>
      <method>method.tuple</method>
      <method>method.trafo.geom</method>
      <operator>close_measure</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>measure_pairs</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>median_image.hdev</name>
      <desc>Anwenden des Median Filters mit verschiedenen Maskenregionen</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <operator>median_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>median_interactive.hdev</name>
      <desc>Interaktives Glätten eines Bildes</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.roi</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>boundary</operator>
      <operator>dev_set_preferences</operator>
      <operator>gen_circle</operator>
      <operator>get_mposition</operator>
      <operator>median_image</operator>
      <operator>overpaint_gray</operator>
      <operator>set_mshape</operator>
      <operator>set_system</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>median_rect.hdev</name>
      <desc>Verwenden eines Median Filters mit rechteckigen Masken für verschiedene Zwecke</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <method>method.segm</method>
      <operator>dyn_threshold</operator>
      <operator>median_rect</operator>
      <operator>min_max_gray</operator>
      <operator>sub_image</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>message_as_dictionary.hdev</name>
      <desc>Verwenden einer Message als Verzeichnis zum Speichern von Objekten und Tupeln</desc>
      <path>hdevelop/System/Multithreading/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>clear_message</operator>
      <operator>create_message</operator>
      <operator>get_message_obj</operator>
      <operator>get_message_param</operator>
      <operator>get_message_tuple</operator>
      <operator>set_message_obj</operator>
      <operator>set_message_param</operator>
      <operator>set_message_tuple</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>message_queue_as_container.hdev</name>
      <desc>Verwenden einer Message-Queue als Container zum Speichern von Messages</desc>
      <path>hdevelop/System/Multithreading/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>clear_message</operator>
      <operator>clear_message_queue</operator>
      <operator>create_message</operator>
      <operator>create_message_queue</operator>
      <operator>dequeue_message</operator>
      <operator>enqueue_message</operator>
      <operator>get_message_obj</operator>
      <operator>get_message_queue_param</operator>
      <operator>get_message_tuple</operator>
      <operator>set_message_obj</operator>
      <operator>set_message_tuple</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>message_queue_producer_consumer.hdev</name>
      <desc>Verwenden einer Message-Queue zum Austausch von Daten zwischen zwei Threads (Erzeuger-Verbraucher)</desc>
      <path>hdevelop/System/Multithreading/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.acqu</method>
      <method>method.controlstruct</method>
      <method>method.parall</method>
      <operator>clear_message</operator>
      <operator>clear_message_queue</operator>
      <operator>convert_vector_to_tuple</operator>
      <operator>create_message</operator>
      <operator>create_message_queue</operator>
      <operator>dequeue_message</operator>
      <operator>enqueue_message</operator>
      <operator>get_message_obj</operator>
      <operator>get_message_param</operator>
      <operator>get_message_tuple</operator>
      <operator>par_join</operator>
      <operator>set_message_obj</operator>
      <operator>set_message_param</operator>
      <operator>set_message_tuple</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>message_queue_producer_consumer_abort.hdev</name>
      <desc>Verwenden einer Message-Queue zum Austausch von Daten zwischen zwei Threads (Erzeuger-Verbraucher)</desc>
      <path>hdevelop/System/Multithreading/</path>
      <industry>industry.food</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.classif</method>
      <method>method.controlstruct</method>
      <method>method.parall</method>
      <operator>clear_event</operator>
      <operator>clear_message</operator>
      <operator>clear_message_queue</operator>
      <operator>create_event</operator>
      <operator>create_message</operator>
      <operator>create_message_queue</operator>
      <operator>dequeue_message</operator>
      <operator>enqueue_message</operator>
      <operator>get_message_obj</operator>
      <operator>get_message_tuple</operator>
      <operator>par_join</operator>
      <operator>set_message_obj</operator>
      <operator>set_message_queue_param</operator>
      <operator>set_message_tuple</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>micro_qr_optimized_settings.hdev</name>
      <desc>Optimieren von Parametern zum Lesen eines Datacodes vom Typ Micro QR</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>micro_qr_simple.hdev</name>
      <desc>Lesen von Datacodes vom Typ Micro QR</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>micro_qr_strict_quiet_zone.hdev</name>
      <desc>Verwenden des Datacodeparameters 'strict_quiet_zone'</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>millite.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>millite_1394_parameters.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>millite_2ports.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (zwei Kameras, Anschlusswechsel)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>millite_parameters.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>millite_simple.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>millite_trigger.hdev</name>
      <desc>Verwenden des MilLite-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>wait_seconds</operator>
      <newinversion>7.1.1</newinversion>
   </example>
   <example>
      <name>min_image.hdev</name>
      <desc>Pixelweises Berechnen des Maximums zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>crop_part</operator>
      <operator>min_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>min_max_gray.hdev</name>
      <desc>Berechnen der minimalen und maximalen Grauwerte innerhalb einer Region</desc>
      <path>hdevelop/Image/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>min_max_gray</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>mirror_region.hdev</name>
      <desc>Spiegeln von Regionen an der x- oder y-Achse</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>draw_region</operator>
      <operator>mirror_region</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>mlp_regularization.hdev</name>
      <desc>Demonstrieren der Auswirkung der Regularisierung eines MLP</desc>
      <path>hdevelop/Classification/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.visual</method>
      <method>method.classif</method>
      <operator>add_noise_white</operator>
      <operator>add_sample_class_mlp</operator>
      <operator>classify_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>compose3</operator>
      <operator>create_class_mlp</operator>
      <operator>evaluate_class_mlp</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>get_region_points</operator>
      <operator>get_sample_num_class_mlp</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>set_regularization_params_class_mlp</operator>
      <operator>train_class_mlp</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>moments_object_model_3d.hdev</name>
      <desc>Ausrichten eines 3D-Objektmodells mit Hilfe von geometrischen Momenten</desc>
      <path>hdevelop/3D-Object-Model/Features/</path>
      <industry>industry.auto</industry>
      <industry>industry.machine</industry>
      <industry>industry.metal</industry>
      <applarea>applarea.alignment</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.object3d</method>
      <operator>affine_trans_object_model_3d</operator>
      <operator>moments_object_model_3d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>moments_region_2nd.hdev</name>
      <desc>Berechnen geometrischer Momente von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>moments_region_2nd</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>moments_region_2nd_invar.hdev</name>
      <desc>Berechnen geometrischer Momente von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>disp_line</operator>
      <operator>gen_ellipse</operator>
      <operator>moments_region_2nd_invar</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>mosaicking.hdev</name>
      <desc>Verwenden von Mosaicking zum Vereinen von Teilbildern eines BGAs zu einem großen Bild</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <method>method.mosaic</method>
      <method>method.filter.points</method>
      <method>method.match.point</method>
      <method>method.visual</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_image_const</operator>
      <operator>gen_projective_mosaic</operator>
      <operator>paint_region</operator>
      <operator>points_harris</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>tile_images_offset</operator>
      <operator>vector_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>mosaicking_pyramid.hdev</name>
      <desc>Kombinieren von Bildern zu einem Mosaikbild</desc>
      <path>hdevelop/Tools/Mosaicking/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.mosaic</method>
      <method>method.filter.points</method>
      <method>method.match.point</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_gauss_pyramid</operator>
      <operator>gen_projective_mosaic</operator>
      <operator>points_harris</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>proj_match_points_ransac_guided</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>move_region.hdev</name>
      <desc>Verschieben von Regionen</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>draw_region</operator>
      <operator>get_mbutton</operator>
      <operator>move_region</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>msi.hdev</name>
      <desc>Lesen eines Barcodes vom Typ MSI</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>mult_image.hdev</name>
      <desc>Multiplizieren zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>gen_image_gray_ramp</operator>
      <operator>mult_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>multicam.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.2</newinversion>
   </example>
   <example>
      <name>multicam_2cameras.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.2</newinversion>
   </example>
   <example>
      <name>multicam_parameters.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_sort</operator>
      <newinversion>6.0.2</newinversion>
   </example>
   <example>
      <name>multicam_picolo.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces mit einem Euresys PICOLO Board</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_image_time</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>multicam_quickpack.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces mit einem Euresys QUICKPACK Board</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_image_pointer3</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_lut</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>multicam_simple.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0.2</newinversion>
   </example>
   <example>
      <name>multicam_split_cable.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces und eines Split-Kabels für ein Euresys DOMINO Board und drei Kameras</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>multicam_stereo.hdev</name>
      <desc>Verwenden des MultiCam-Interfaces für einen Stereoaufbau</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>decompose2</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>multiple_boards.hdev</name>
      <desc>Bild einziehen von mehreren Boards</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>multiple_models.hdev</name>
      <desc>Gleichzeitiges Suchen nach zwei Objekttypen</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.tuple</method>
      <operator>add_channels</operator>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>copy_obj</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>find_scaled_shape_models</operator>
      <operator>gen_circle</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>inspect_shape_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>multiple_objects.hdev</name>
      <desc>Suchen nach mehreren Instanzen eines Sicherungsrings</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_pixel</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>gen_circle</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>multiple_ports.hdev</name>
      <desc>Bild einziehen von mehreren Anschlüssen</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>multiple_scales.hdev</name>
      <desc>Suchen nach Muttern verschiedener Größen</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_pixel</operator>
      <operator>clear_shape_model</operator>
      <operator>copy_image</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>difference</operator>
      <operator>disp_arrow</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>gen_circle</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>inspect_shape_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>nearest_neighbors.hdev</name>
      <desc>Finden des nächsten Punktes in einem 3D-Objektmodell mit Hilfe von k-NN-Klassifikation</desc>
      <path>hdevelop/Classification/k-Nearest-Neighbor/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.classif</method>
      <operator>add_sample_class_knn</operator>
      <operator>classify_class_knn</operator>
      <operator>create_class_knn</operator>
      <operator>get_sample_class_knn</operator>
      <operator>set_params_class_knn</operator>
      <operator>train_class_knn</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>nidaqmx_counter.hdev</name>
      <desc>Verwenden des NIDAQmx-Interfaces (verwenden der Zähler-Funktionalität)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>set_io_channel_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>nidaqmx_digital_read.hdev</name>
      <desc>Verwenden des NIDAQmx-Interfaces (einfaches Lesen der digitalen Eingänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>nidaqmx_digital_write.hdev</name>
      <desc>Verwenden des NIDAQmx-Interfaces (einfaches Schreiben der digitalen Ausgänge)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>write_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>nonmax_suppression_amp.hdev</name>
      <desc>Unterdrücken von Punkten, die keinem lokalen Maximum entsprechen</desc>
      <path>hdevelop/Segmentation/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.filter.edge</method>
      <operator>nonmax_suppression_amp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>nonmax_suppression_dir.hdev</name>
      <desc>Unterdrücken von Kantenpunkten, die keinem lokalen Maximum entsprechen</desc>
      <path>hdevelop/Segmentation/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.filter.edge</method>
      <operator>frei_dir</operator>
      <operator>nonmax_suppression_dir</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>novelty_detection.hdev</name>
      <desc>Verwenden eines SVM-basierten Klassifikators im 'novelty-detection' Modus</desc>
      <path>hdevelop/Classification/Support-Vector-Machines/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <method>method.visual</method>
      <operator>add_sample_class_svm</operator>
      <operator>classify_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>create_class_svm</operator>
      <operator>evaluate_class_svm</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_image_const</operator>
      <operator>gen_region_points</operator>
      <operator>get_region_points</operator>
      <operator>intersection</operator>
      <operator>label_to_region</operator>
      <operator>set_grayval</operator>
      <operator>train_class_svm</operator>
      <operator>union2</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>novelty_detection_dyn_threshold.hdev</name>
      <desc>Überprüfen von Gewebe mittels dyn_threshold</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.texture</method>
      <method>method.blob</method>
      <operator>dyn_threshold</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>novelty_detection_gmm.hdev</name>
      <desc>Überprüfen von Gewebe mittels GMM-basierter Texturklassifikation</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.classif</method>
      <method>method.texture</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>add_samples_image_class_gmm</operator>
      <operator>classify_image_class_gmm</operator>
      <operator>clear_class_gmm</operator>
      <operator>compose5</operator>
      <operator>create_class_gmm</operator>
      <operator>difference</operator>
      <operator>read_class_gmm</operator>
      <operator>smooth_image</operator>
      <operator>texture_laws</operator>
      <operator>train_class_gmm</operator>
      <operator>write_class_gmm</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>novelty_detection_mlp.hdev</name>
      <desc>Überprüfen von Gewebe mittels MLP-basierter Texturklassifikation</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.classif</method>
      <method>method.texture</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>add_samples_image_class_mlp</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>compose5</operator>
      <operator>create_class_mlp</operator>
      <operator>read_class_mlp</operator>
      <operator>set_rejection_params_class_mlp</operator>
      <operator>smooth_image</operator>
      <operator>texture_laws</operator>
      <operator>train_class_mlp</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>novelty_detection_svm.hdev</name>
      <desc>Überprüfen von Gewebe mittels SVM-basierter Texturklassifikation</desc>
      <path>hdevelop/Segmentation/Classification/</path>
      <industry>industry.synth</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.classif</method>
      <method>method.texture</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>add_samples_image_class_svm</operator>
      <operator>classify_image_class_svm</operator>
      <operator>clear_class_svm</operator>
      <operator>compose5</operator>
      <operator>create_class_svm</operator>
      <operator>reduce_class_svm</operator>
      <operator>smooth_image</operator>
      <operator>texture_laws</operator>
      <operator>train_class_svm</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>obj_diff.hdev</name>
      <desc>Verwenden von obj_diff</desc>
      <path>hdevelop/Object/Manipulation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>obj_diff</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>ocr_cd_print_polar_trans.hdev</name>
      <desc>Lesen von Schriftzeichen auf einem nichtlinearen Muster</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.print</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.segm</method>
      <method>method.trafo.geom</method>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>polar_trans_image_ext</operator>
      <operator>read_ocr_class_mlp</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>ocr_dongle.hdev</name>
      <desc>Lesen einer Dongle-ID mit OCR und regulären Ausdrücken</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <applarea>applarea.inspect.print</applarea>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.ocr</method>
      <method>method.blob</method>
      <method>method.string</method>
      <method>method.tuple</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>dilation1</operator>
      <operator>dilation_rectangle1</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>dyn_threshold</operator>
      <operator>erosion_circle</operator>
      <operator>erosion_rectangle1</operator>
      <operator>gen_rectangle2</operator>
      <operator>mean_image</operator>
      <operator>median_image</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>shape_trans</operator>
      <operator>sort_region</operator>
      <operator>tuple_regexp_match</operator>
      <operator>tuple_strlen</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>ocr_embossed_photometric_stereo.hdev</name>
      <desc>Lesen der geprägten Losnummer einer Zahnpastatube mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.pack</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.stereo.phot</method>
      <method>method.ocr</method>
      <operator>derivate_vector_field</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>photometric_stereo</operator>
      <operator>read_ocr_class_mlp</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>ocr_gradient_feature.hdev</name>
      <desc>Vergleichen von OCR-Merkmalen</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.blob</method>
      <method>method.tuple</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.ocr</method>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clear_ocr_class_svm</operator>
      <operator>copy_rectangle</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>create_ocr_class_svm</operator>
      <operator>disp_image</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>do_ocr_multi_class_svm</operator>
      <operator>emphasize</operator>
      <operator>get_part</operator>
      <operator>gray_dilation_shape</operator>
      <operator>open_window</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>set_color</operator>
      <operator>set_insert</operator>
      <operator>set_part</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>trainf_ocr_class_svm</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>ocr_lot_number.hdev</name>
      <desc>Korrigieren von OCR-Ergebnissen mittels regulärer Ausdrücke</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.ocr</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>do_ocr_word_mlp</operator>
      <operator>find_text</operator>
      <operator>get_text_object</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>set_text_model_param</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>ocr_tire_photometric_stereo.hdev</name>
      <desc>Lesen von geprägter Schrift auf einem Autoreifen mit photometrischem Stereo und OCR</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.stereo.phot</method>
      <method>method.trafo.geom</method>
      <operator>derivate_vector_field</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>photometric_stereo</operator>
      <operator>polar_trans_region</operator>
      <operator>read_ocr_class_mlp</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>ocr_wafer_semi_font.hdev</name>
      <desc>Lesen der ID-Nummern von Wafern</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.segm</method>
      <method>method.morphol</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>read_ocr_class_mlp</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>ocr_yogurt.hdev</name>
      <desc>Segmentieren des Mindesthaltbarkeitsdatums auf Joghurtdeckeln für das Lesen mit OCR</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.food</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.segm</method>
      <operator>read_ocr_class_mlp</operator>
      <operator>segment_characters</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>ocrcolor.hdev</name>
      <desc>Lesen von Zahlen unter Verwendung von Farbinformation</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.filter.general</method>
      <method>method.color</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clip_region</operator>
      <operator>decompose3</operator>
      <operator>do_ocr_multi_class_mlp</operator>
      <operator>expand_gray_ref</operator>
      <operator>fill_up_shape</operator>
      <operator>get_image_pointer3</operator>
      <operator>mean_image</operator>
      <operator>paint_region</operator>
      <operator>read_image</operator>
      <operator>read_ocr_class_mlp</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sub_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>ocrcolort.hdev</name>
      <desc>Segmentieren von Zahlen unter Verwendung von Farbinformation und Trainieren der OCR</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.filter.general</method>
      <method>method.color</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.error</method>
      <operator>append_ocr_trainf</operator>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>clip_region</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>decompose3</operator>
      <operator>delete_file</operator>
      <operator>expand_gray_ref</operator>
      <operator>fill_up_shape</operator>
      <operator>get_image_pointer3</operator>
      <operator>mean_image</operator>
      <operator>rgb1_to_gray</operator>
      <operator>smallest_rectangle1</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>opc_classic_browse_variables.hdev</name>
      <desc>Verwenden des OPC-Classic-Interfaces (Auslesen der Servervariablen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_classic_channel_access.hdev</name>
      <desc>Verwenden des OPC-Classic-Interfaces (einfaches Lesen und Schreiben von Servervariablen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_classic_parameters.hdev</name>
      <desc>Verwenden des OPC-Classic-Interfaces (Server-Knotenparameter lesen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_interface</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_ua_browse_variables.hdev</name>
      <desc>Verwenden des OPC-UA-Interfaces (Auslesen der Servervariablen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_device</operator>
      <operator>control_io_device</operator>
      <operator>open_io_device</operator>
      <operator>query_io_device</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_ua_channel_access.hdev</name>
      <desc>Verwenden des OPC-UA-Interfaces (einfaches Lesen und Schreiben von Servervariablen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>control_io_device</operator>
      <operator>get_io_device_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <operator>set_io_channel_param</operator>
      <operator>write_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_ua_discovery.hdev</name>
      <desc>Verwenden des OPC-UA-Interfaces (mit einem Server verbinden)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_device</operator>
      <operator>control_io_device</operator>
      <operator>control_io_interface</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_interface</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_ua_parameters.hdev</name>
      <desc>Verwenden des OPC-UA-Interfaces (Server-Knotenparameter lesen)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_channel</operator>
      <operator>close_io_device</operator>
      <operator>get_io_channel_param</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>query_io_interface</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>opc_ua_security.hdev</name>
      <desc>Verwenden des OPC-UA-Interfaces (mit einem Server verbinden, der Sicherheitseinstellungen unterstützt)</desc>
      <path>hdevelop/System/IO-Devices/</path>
      <method>method.io</method>
      <operator>close_io_device</operator>
      <operator>control_io_device</operator>
      <operator>control_io_interface</operator>
      <operator>get_extended_error_info</operator>
      <operator>open_io_channel</operator>
      <operator>open_io_device</operator>
      <operator>read_io_channel</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>open_file.hdev</name>
      <desc>Schreiben eines beliebigen Textes in eine Datei</desc>
      <path>hdevelop/File/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>close_file</operator>
      <operator>fwrite_string</operator>
      <operator>open_file</operator>
      <operator>count_obj</operator>
      <operator>select_obj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>opening.hdev</name>
      <desc>Erkennen von Buchstaben durch Anwendung einer Opening-Operation</desc>
      <path>hdevelop/Morphology/Region/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.morphol</method>
      <operator>erosion_circle</operator>
      <operator>opening</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>opteon.hdev</name>
      <desc>Verwenden des Opteon-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>opteon_crop.hdev</name>
      <desc>Verwenden des Opteon-Interfaces (Bildteile der Größe 256x256 einziehen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>opteon_parameters.hdev</name>
      <desc>Verwenden des Opteon-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_sort</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>opteon_simple.hdev</name>
      <desc>Verwenden des Opteon-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>opteon_trigger.hdev</name>
      <desc>Verwenden des Opteon-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0.3</newinversion>
   </example>
   <example>
      <name>optical_flow.hdev</name>
      <desc>Überwachen von Verkehr mittels optischem Fluss</desc>
      <path>hdevelop/Applications/Security-Systems/</path>
      <industry>industry.secure</industry>
      <industry>industry.transp</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.security</applarea>
      <method>method.visual</method>
      <method>method.motion</method>
      <method>method.blob</method>
      <operator>copy_obj</operator>
      <operator>optical_flow_mg</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>optical_flow_bicycle.hdev</name>
      <desc>Überwachen eines sich bewegenden Fahrrads mittels optischem Fluss</desc>
      <path>hdevelop/Applications/Security-Systems/</path>
      <industry>industry.secure</industry>
      <industry>industry.transp</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.security</applarea>
      <method>method.visual</method>
      <method>method.motion</method>
      <method>method.blob</method>
      <method>method.functions</method>
      <operator>copy_obj</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_region_contour_xld</operator>
      <operator>intensity</operator>
      <operator>intersection</operator>
      <operator>min_max_gray</operator>
      <operator>optical_flow_mg</operator>
      <operator>select_shape_std</operator>
      <operator>shape_trans</operator>
      <operator>vector_field_length</operator>
      <operator>vector_field_to_real</operator>
      <operator>zoom_image_factor</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>optical_flow_hydraulic_engineering.hdev</name>
      <desc>Ermitteln von Position, Geschwindigkeit und Bewegungsrichtung von Partikeln mit optischem Fluss</desc>
      <path>hdevelop/Applications/Security-Systems/</path>
      <industry>industry.secure</industry>
      <industry>industry.chem</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.security</applarea>
      <method>method.acqu</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.motion</method>
      <operator>copy_obj</operator>
      <operator>dilation_circle</operator>
      <operator>gen_region_points</operator>
      <operator>intensity</operator>
      <operator>local_max_sub_pix</operator>
      <operator>min_max_gray</operator>
      <operator>optical_flow_mg</operator>
      <operator>reduce_domain</operator>
      <operator>vector_field_length</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>optimize_aop.hdev</name>
      <desc>Optimieren der automatischen Operatorparallelisierung (aop)</desc>
      <path>hdevelop/System/Parallelization/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>get_aop_info</operator>
      <operator>optimize_aop</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>optimize_fft_speed.hdev</name>
      <desc>Optimieren der Laufzeit der FFT Operatoren</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <operator>convert_image_type</operator>
      <operator>count_seconds</operator>
      <operator>fft_generic</operator>
      <operator>optimize_fft_speed</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>optimize_svm_parameter.hdev</name>
      <desc>Optimieren der Parametereinstellungen für SVM-Klassifikatoren für OCR</desc>
      <path>hdevelop/OCR/Feature-Selection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <operator>clear_ocr_class_svm</operator>
      <operator>create_ocr_class_svm</operator>
      <operator>do_ocr_single_class_svm</operator>
      <operator>get_params_ocr_class_svm</operator>
      <operator>read_ocr_trainf</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>select_feature_set_trainf_svm</operator>
      <operator>trainf_ocr_class_svm</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>orientation_region.hdev</name>
      <desc>Berechnen der Orientierung von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.blob</method>
      <operator>disp_arrow</operator>
      <operator>orientation_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>paint_xld.hdev</name>
      <desc>Einzeichnen eines XLD Objekts in ein Bild</desc>
      <path>hdevelop/Image/Manipulation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>compose3</operator>
      <operator>copy_image</operator>
      <operator>paint_xld</operator>
      <operator>select_shape_xld</operator>
      <operator>threshold_sub_pix</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>par_start.hdev</name>
      <desc>Paralleles Lesen von Barcodes und Datacodes mit Hilfe von Multithreading</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <industry>industry.health</industry>
      <industry>industry.pack</industry>
      <industry>industry.pharm</industry>
      <industry>industry.retail</industry>
      <applarea>applarea.ident.barcode</applarea>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.barcode</method>
      <method>method.datacode</method>
      <method>method.parall</method>
      <operator>clear_bar_code_model</operator>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_bar_code_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_bar_code</operator>
      <operator>find_data_code_2d</operator>
      <operator>par_join</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>particle.hdev</name>
      <desc>Extrahieren von Partikeln unterschiedlicher Größe</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.health</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.blob</method>
      <operator>area_center</operator>
      <operator>complement</operator>
      <operator>connection</operator>
      <operator>dilation_circle</operator>
      <operator>dyn_threshold</operator>
      <operator>get_mbutton</operator>
      <operator>intensity</operator>
      <operator>mean_image</operator>
      <operator>opening_circle</operator>
      <operator>select_region_point</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>partition_dynamic.hdev</name>
      <desc>Horizontales Partitionieren einer Region an 'dünnen' Stellen in Rechtecke verschiedener Breite</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.regionproc</method>
      <operator>partition_dynamic</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>partition_rectangle.hdev</name>
      <desc>Partitionieren einer Region in Rechtecke gleicher Größe</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.regionproc</method>
      <operator>partition_rectangle</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>pattern.hdev</name>
      <desc>Ausführen einer Online-Mustererkennung mit einem Grauwerttemplate</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.match.gray</method>
      <operator>add_channels</operator>
      <operator>best_match</operator>
      <operator>clear_template</operator>
      <operator>close_framegrabber</operator>
      <operator>create_template</operator>
      <operator>dilation_circle</operator>
      <operator>disp_rectangle1</operator>
      <operator>fast_match_mg</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>pcb_inspection.hdev</name>
      <desc>Finden von Defekten auf einem PCB mittels Grauwertmorphologie</desc>
      <path>hdevelop/Morphology/Gray-Values/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.blob</method>
      <operator>dyn_threshold</operator>
      <operator>gray_closing_shape</operator>
      <operator>gray_opening_shape</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>pdf417_bottle.hdev</name>
      <desc>Lesen von Datacodes vom Typ PDF417</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.food</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>pdf417_optimized_settings.hdev</name>
      <desc>Optimieren von Parametern zum Lesen verschiedener Datacodes vom Typ PDF417</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>pdf417_simple.hdev</name>
      <desc>Lesen von Datacodes vom Typ PDF417</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>phase_correlation_fft.hdev</name>
      <desc>Berechnen der Translation zwischen zwei Bildern mit Hilfe der Phasenkorrelation</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.alignment</applarea>
      <method>method.fft</method>
      <method>method.filter.points</method>
      <method>method.filter.general</method>
      <operator>local_max_sub_pix</operator>
      <operator>optimize_rft_speed</operator>
      <operator>phase_correlation_fft</operator>
      <operator>rft_generic</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>phot_stereo_braille.hdev</name>
      <desc>Ermitteln eines 3D-Modells für Braille-Schrift mit photometrischem Stereo</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.paper</industry>
      <industry>industry.print</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>closing_rectangle1</operator>
      <operator>connection</operator>
      <operator>dev_display</operator>
      <operator>intersection</operator>
      <operator>mean_image</operator>
      <operator>partition_dynamic</operator>
      <operator>shade_height_field</operator>
      <operator>sub_image</operator>
      <operator>threshold</operator>
      <operator>wait_seconds</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>pick_and_place_scara_stationary_cam.hdev</name>
      <desc>Ausführen einer Pick-and-Place-Anwendung mit einem SCARA-Roboter</desc>
      <path>hdevelop/Calibration/Hand-Eye/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>affine_trans_point_3d</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_model</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>map_image</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>set_origin_pose</operator>
      <operator>set_shape_model_origin</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>pixelink.hdev</name>
      <desc>Verwenden des PixeLink-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>pixelink_2cameras.hdev</name>
      <desc>Verwenden des PixeLink-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>pixelink_parameters.hdev</name>
      <desc>Verwenden des PixeLink-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>pixelink_simple.hdev</name>
      <desc>Verwenden des PixeLink-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>plateaus.hdev</name>
      <desc>Erkennen von Grauwert-Plateaus</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>plateaus</operator>
      <operator>smooth_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>plateaus_center.hdev</name>
      <desc>Erkennen der Zentren von Grauwert-Plateaus</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>plateaus_center</operator>
      <operator>smooth_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>plot_tuple.hdev</name>
      <desc>Plotten von Tupeln, die Funktionen darstellen, in einem Koordinatensystem</desc>
      <path>hdevelop/Graphics/Output/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <method>method.funct1d</method>
      <method>method.visual</method>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>pm_illu.hdev</name>
      <desc>Ausführen einer Online-Mustererkennung mit einem sich an ändernde Beleuchtungen anpassenden Grauwerttemplate</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.match.gray</method>
      <method>method.visual</method>
      <operator>clear_template</operator>
      <operator>count_seconds</operator>
      <operator>create_template</operator>
      <operator>dev_close_window</operator>
      <operator>dev_display</operator>
      <operator>dev_set_color</operator>
      <operator>dev_set_draw</operator>
      <operator>dev_set_line_width</operator>
      <operator>dev_set_window</operator>
      <operator>endif</operator>
      <operator>gen_rectangle2</operator>
      <operator>if</operator>
      <operator>intensity</operator>
      <operator>reduce_domain</operator>
      <operator>set_offset_template</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>pm_illu_rectify.hdev</name>
      <desc>Finden eines rotierten Musters mit einem Grauwerttemplate und Ausrichten des Bildes zu dem Muster</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.match.gray</method>
      <method>method.visual</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.error</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>close_framegrabber</operator>
      <operator>copy_obj</operator>
      <operator>count_seconds</operator>
      <operator>create_template_rot</operator>
      <operator>dev_open_window</operator>
      <operator>full_domain</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>grab_image</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>intensity</operator>
      <operator>open_framegrabber</operator>
      <operator>set_offset_template</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>pm_illu_rot.hdev</name>
      <desc>Finden eines rotierten Musters mit einem Grauwerttemplate</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.acqu</method>
      <method>method.match.gray</method>
      <method>method.visual</method>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>close_framegrabber</operator>
      <operator>create_template_rot</operator>
      <operator>gen_rectangle2</operator>
      <operator>grab_image</operator>
      <operator>intensity</operator>
      <operator>open_framegrabber</operator>
      <operator>set_offset_template</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>pm_measure_board.hdev</name>
      <desc>Auffinden eines ICs auf einer Platine und Messen der Abstände zwischen den Kontakten</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.inspect.complete</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.metrol</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.error</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_pixel</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>close_measure</operator>
      <operator>create_shape_model</operator>
      <operator>dev_set_part</operator>
      <operator>dev_set_window</operator>
      <operator>disp_line</operator>
      <operator>find_shape_model</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle1</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_mposition</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>measure_pairs</operator>
      <operator>open_framegrabber</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>pm_multiple_dxf_models.hdev</name>
      <desc>Finden mehrerer unterschiedlicher aus DXF Dateien abgeleiteter Formmodelle in einem einzelnen Durchlauf</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.file</method>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.tuple</method>
      <method>method.error</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>area_center_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>copy_obj</operator>
      <operator>count_seconds</operator>
      <operator>create_shape_model</operator>
      <operator>difference_closed_contours_xld</operator>
      <operator>find_shape_models</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>gen_image_const</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>get_domain</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>inspect_shape_model</operator>
      <operator>paint_xld</operator>
      <operator>read_contour_xld_dxf</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_xld</operator>
      <operator>union1</operator>
      <operator>union_adjacent_contours_xld</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>wait_seconds</operator>
      <operator>write_string</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>pm_multiple_models.hdev</name>
      <desc>Finden mehrerer unterschiedlicher Formmodelle in einem einzelnen Durchlauf</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.error</method>
      <method>method.tuple</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>copy_obj</operator>
      <operator>create_shape_model</operator>
      <operator>find_shape_models</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>get_shape_model_contours</operator>
      <operator>inspect_shape_model</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_xld</operator>
      <operator>union1</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>pm_world_plane.hdev</name>
      <desc>Erkennen ebener Objekte mit formbasiertem Matching in perspektivisch verzerrten Bildern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.trafo.rectif</method>
      <method>method.calib</method>
      <method>method.visual</method>
      <method>method.match.shape</method>
      <method>method.trafo.wcoord</method>
      <method>method.trafo.geom</method>
      <method>method.xld</method>
      <method>method.error</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_point_3d</operator>
      <operator>clear_shape_model</operator>
      <operator>count_seconds</operator>
      <operator>create_shape_model</operator>
      <operator>disp_arrow</operator>
      <operator>disp_circle</operator>
      <operator>find_shape_model</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>get_contour_xld</operator>
      <operator>get_mposition</operator>
      <operator>get_shape_model_contours</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>select_shape_xld</operator>
      <operator>set_origin_pose</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>point_line_to_hom_mat2d.hdev</name>
      <desc>Ausrichten eines Bildes unter Verwendung von Punkt-zu-Linie-Korrespondenzen für eine Druckqualitätsprüfung mit einem Variationsmodell</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.varmodel</method>
      <method>method.ocv</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.blob</method>
      <operator>add_metrology_object_line_measure</operator>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_image</operator>
      <operator>apply_metrology_model</operator>
      <operator>clear_metrology_model</operator>
      <operator>clear_train_data_variation_model</operator>
      <operator>clear_variation_model</operator>
      <operator>compare_variation_model</operator>
      <operator>create_metrology_model</operator>
      <operator>create_variation_model</operator>
      <operator>erosion_rectangle1</operator>
      <operator>fill_up</operator>
      <operator>get_metrology_object_measures</operator>
      <operator>get_metrology_object_result</operator>
      <operator>get_metrology_object_result_contour</operator>
      <operator>get_variation_model</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>if</operator>
      <operator>point_line_to_hom_mat2d</operator>
      <operator>prepare_variation_model</operator>
      <operator>set_metrology_model_image_size</operator>
      <operator>train_variation_model</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>points_foerstner.hdev</name>
      <desc>Extrahieren von markanten Punkten mit dem Foerstner Punktoperator</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>gen_cross_contour_xld</operator>
      <operator>points_foerstner</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>points_foerstner_ellipses.hdev</name>
      <desc>Analysieren der Präzision extrahierter Punkte mittels Kovarianzmatrizen</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>add_noise_white</operator>
      <operator>gen_image_const</operator>
      <operator>gen_image_proto</operator>
      <operator>intensity</operator>
      <operator>paint_xld</operator>
      <operator>points_foerstner</operator>
      <operator>tuple_concat</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>points_foerstner_rotation.hdev</name>
      <desc>Demonstrieren der Robustheit des Foerstner Punktoperators und seiner Invarianz gegenüber Rotationen</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_image</operator>
      <operator>gen_circle</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>points_foerstner</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>points_harris.hdev</name>
      <desc>Extrahieren von markanten Punkten mit dem Harris Punktoperator</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>points_harris</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>points_harris_binomial.hdev</name>
      <desc>Extrahieren von markanten Punkten mit dem Harris Binomial Punktoperator</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>points_harris_binomial</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>points_harris_rotation.hdev</name>
      <desc>Demonstrieren der Robustheit des Harris Punktoperators und seiner Invarianz gegenüber Rotationen</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>gen_circle</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>points_harris</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>points_lepetit.hdev</name>
      <desc>Extrahieren von markanten Punkten mit dem Lepetit Punktoperator</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>points_lepetit</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>points_sojka.hdev</name>
      <desc>Extrahieren von markanten Punkten (Ecken) mit dem Sojka Operator</desc>
      <path>hdevelop/Filters/Points/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.points</method>
      <operator>points_sojka</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>port_switching.hdev</name>
      <desc>Dynamischer Wechsel zwischen Anschlüssen</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>pose_average.hdev</name>
      <desc>Mittelung von Posen, die mit oberflächenbasiertem 3D-Matching aus verrauschten 3D-Szenen ermittelt wurden</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.poseestim</method>
      <operator>pose_average</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>pose_compose.hdev</name>
      <desc>Verknüpfung von mehreren Posen</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.poseestim</method>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>pose_compose</operator>
      <operator>pose_to_hom_mat3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>pose_from_point_correspondences.hdev</name>
      <desc>Vergleichen dreier Methoden zum Schätzen einer Pose aus Korrespondenzen</desc>
      <path>hdevelop/Matching/Descriptor-Based/</path>
      <industry>industry.pack</industry>
      <industry>industry.food</industry>
      <applarea>applarea.recog.pos3d</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.match.descr</method>
      <method>method.poseestim</method>
      <operator>cam_par_to_cam_mat</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>clear_descriptor_model</operator>
      <operator>create_calib_descriptor_model</operator>
      <operator>find_calib_descriptor_model</operator>
      <operator>get_descriptor_model_points</operator>
      <operator>hom_vector_to_proj_hom_mat2d</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>proj_hom_mat2d_to_pose</operator>
      <operator>project_3d_point</operator>
      <operator>vector_to_pose</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>pose_invert.hdev</name>
      <desc>Invertieren von Posen</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.poseestim</method>
      <operator>hom_mat3d_invert</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>pose_invert</operator>
      <operator>pose_to_hom_mat3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>pose_of_known_3d_object.hdev</name>
      <desc>Bestimmen der Pose von Objekten durch das Extrahieren von drei oder mehr Referenzpunkten</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.tuple</method>
      <method>method.calib</method>
      <method>method.geom</method>
      <method>method.poseestim</method>
      <method>method.trafo.wcoord</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>area_center_xld</operator>
      <operator>difference</operator>
      <operator>find_caltab</operator>
      <operator>find_marks_and_pose</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>length_xld</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape_std</operator>
      <operator>set_origin_pose</operator>
      <operator>vector_to_pose</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>pouring.hdev</name>
      <desc>Segmentieren eines Bildes durch das 'Gießkannen'-Prinzip</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.classif</method>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>class_2dim_sup</operator>
      <operator>decompose3</operator>
      <operator>histo_2dim</operator>
      <operator>pouring</operator>
      <operator>scale_image_max</operator>
      <operator>smooth_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>prewitt_amp.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude) mit dem Prewitt Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>prewitt_amp</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>prewitt_dir.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit dem Prewitt Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>nonmax_suppression_dir</operator>
      <operator>prewitt_dir</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>print_check.hdev</name>
      <desc>Ausführen einer typischen Druckqualitätsprüfung mit einem Variationsmodell</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.varmodel</method>
      <method>method.ocv</method>
      <method>method.visual</method>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.blob</method>
      <operator>affine_trans_image</operator>
      <operator>clear_shape_model</operator>
      <operator>clear_train_data_variation_model</operator>
      <operator>clear_variation_model</operator>
      <operator>compare_variation_model</operator>
      <operator>create_shape_model</operator>
      <operator>create_variation_model</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>erosion_rectangle1</operator>
      <operator>fill_up</operator>
      <operator>find_shape_model</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>get_variation_model</operator>
      <operator>if</operator>
      <operator>inspect_shape_model</operator>
      <operator>prepare_variation_model</operator>
      <operator>shape_trans</operator>
      <operator>train_variation_model</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>print_check_single_chars.hdev</name>
      <desc>Ausführen einer typischen Druckqualitätsprüfung mit einem Variationsmodell für jedes Zeichen</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.varmodel</method>
      <method>method.ocv</method>
      <method>method.visual</method>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.blob</method>
      <method>method.tuple</method>
      <operator>affine_trans_image_size</operator>
      <operator>affine_trans_region</operator>
      <operator>clear_shape_model</operator>
      <operator>clear_train_data_variation_model</operator>
      <operator>clear_variation_model</operator>
      <operator>compare_variation_model</operator>
      <operator>create_shape_model</operator>
      <operator>create_variation_model</operator>
      <operator>crop_part</operator>
      <operator>find_shape_models</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>get_domain</operator>
      <operator>get_variation_model</operator>
      <operator>inspect_shape_model</operator>
      <operator>move_region</operator>
      <operator>prepare_variation_model</operator>
      <operator>shape_trans</operator>
      <operator>smallest_rectangle1</operator>
      <operator>tile_images_offset</operator>
      <operator>train_variation_model</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>print_quality.hdev</name>
      <desc>Überprüfen der Qualität des Buchstabens 'A' in verschiedenen Bildern</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.roi</method>
      <method>method.ocv</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>binary_threshold</operator>
      <operator>close_ocv</operator>
      <operator>create_ocv_proj</operator>
      <operator>do_ocv_simple</operator>
      <operator>traind_ocv_proj</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>print_quality_aimdpm_1_2006.hdev</name>
      <desc>Überprüfen der Druckqualität von Datacodes (AIM DPM-1-2006 Standard)</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <method>method.acqu</method>
      <method>method.tuple</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>close_framegrabber</operator>
      <operator>continue</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>fread_line</operator>
      <operator>get_data_code_2d_results</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_file</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>print_quality_isoiec15416.hdev</name>
      <desc>Überprüfen der Druckqualität von Barcodes (isoiec15416)</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.print</applarea>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <method>method.visual</method>
      <method>method.filter.general</method>
      <operator>create_bar_code_model</operator>
      <operator>find_bar_code</operator>
      <operator>get_bar_code_param</operator>
      <operator>get_bar_code_result</operator>
      <operator>paint_gray</operator>
      <operator>set_bar_code_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>process_shape_model.hdev</name>
      <desc>Erzeugen einer Modell-ROI durch Modifizieren des Ergebnisses aus inspect_shape_model</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <method>method.roi</method>
      <method>method.morphol</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>create_shape_model</operator>
      <operator>fill_up</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>opening_circle</operator>
      <operator>smallest_rectangle1</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>proj_match_points_distortion_ransac.hdev</name>
      <desc>Erzeugen eine Mosaikbildes mit proj_match_points_distortion_ransac</desc>
      <path>hdevelop/Tools/Mosaicking/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.mosaic</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_projective_mosaic</operator>
      <operator>proj_match_points_distortion_ransac</operator>
      <operator>proj_match_points_ransac</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>proj_match_points_distortion_ransac_guided.hdev</name>
      <desc>Erzeugen eine Mosaikbildes mit proj_match_points_distortion_ransac_guided</desc>
      <path>hdevelop/Tools/Mosaicking/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.mosaic</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_projective_mosaic</operator>
      <operator>proj_match_points_distortion_ransac</operator>
      <operator>proj_match_points_distortion_ransac_guided</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>projection_pl.hdev</name>
      <desc>Projizieren eines Punkts auf eine Linie</desc>
      <path>hdevelop/Tools/Geometry/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.geom</method>
      <operator>disp_circle</operator>
      <operator>disp_line</operator>
      <operator>distance_ss</operator>
      <operator>projection_pl</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>projective_trans_contour_xld.hdev</name>
      <desc>Rotieren einer XLD Kontur in 3D mit hom_mat3d_project und projective_trans_region</desc>
      <path>hdevelop/XLD/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>disp_obj</operator>
      <operator>edges_sub_pix</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>projective_trans_contour_xld</operator>
      <operator>set_color</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>projective_trans_image.hdev</name>
      <desc>Anwenden projektiver Transformationen auf ein Bild</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <method>method.error</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>disp_obj</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>projective_trans_image</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>projective_trans_image_reduced.hdev</name>
      <desc>Anwenden projektiver Transformationen auf ein Bild und seine Domäne</desc>
      <path>hdevelop/Filters/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>disp_obj</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>projective_trans_image</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>projective_trans_object_model_3d.hdev</name>
      <desc>Anwenden projektiver Transformationen auf 3D-Objektmodelle</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.general</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>gen_box_object_model_3d</operator>
      <operator>projective_trans_object_model_3d</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <operator>sample_object_model_3d</operator>
      <operator>set_object_model_3d_attrib</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>projective_trans_pixel.hdev</name>
      <desc>Anwenden einer projektiven Transformation zum Rotieren eines Bildes in 3D</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.filter.points</method>
      <method>method.trafo.geom</method>
      <method>method.functions</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>disp_cross</operator>
      <operator>disp_obj</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>points_foerstner</operator>
      <operator>projective_trans_image</operator>
      <operator>projective_trans_pixel</operator>
      <operator>set_color</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>projective_trans_point_2d.hdev</name>
      <desc>Anwenden einer projektiven Transformation zum Rotieren von Bildern und Punkten in 3D</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>disp_obj</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>projective_trans_image</operator>
      <operator>projective_trans_point_2d</operator>
      <operator>set_color</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>projective_trans_region.hdev</name>
      <desc>Anwenden projektiver Transformationen auf Regionen</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.visual</method>
      <operator>clear_window</operator>
      <operator>close_window</operator>
      <operator>copy_rectangle</operator>
      <operator>disp_obj</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_project</operator>
      <operator>hom_mat3d_rotate</operator>
      <operator>hom_mat3d_translate</operator>
      <operator>open_window</operator>
      <operator>projective_trans_region</operator>
      <operator>set_color</operator>
      <operator>set_part</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>protect_ocr_trainf.hdev</name>
      <desc>Verwenden von Passwort-geschützten OCR-Trainingsdateien</desc>
      <path>hdevelop/OCR/Training-Files/</path>
      <industry>industry.general</industry>
      <industry>industry.pack</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <operator>protect_ocr_trainf</operator>
      <operator>read_ocr_trainf_names_protected</operator>
      <operator>trainf_ocr_class_mlp_protected</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>pylon.hdev</name>
      <desc>Verwenden des pylon-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>gen_struct_elements</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>pylon_2cameras.hdev</name>
      <desc>Verwenden des pylon-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>pylon_crop.hdev</name>
      <desc>Verwenden des pylon-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>pylon_parameters.hdev</name>
      <desc>Verwenden des pylon-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>pylon_simple.hdev</name>
      <desc>Verwenden des pylon-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.1.2</newinversion>
   </example>
   <example>
      <name>qrcode_deformed.hdev</name>
      <desc>Lesen perspektivisch verzerrter und lokal deformierter QR Code Symbole</desc>
      <path>hdevelop/Identification/Data-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>real_to_vector_field</operator>
      <operator>set_data_code_2d_param</operator>
      <operator>unwarp_image_vector_field</operator>
      <operator>vector_field_to_real</operator>
      <operator>vector_to_proj_hom_mat2d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>qrcode_optimized_settings.hdev</name>
      <desc>Optimieren von Parametern zum Lesen eines Datacodes vom Typ QR Code</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <operator>set_data_code_2d_param</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>qrcode_simple.hdev</name>
      <desc>Lesen von Datacodes vom Typ QR Code</desc>
      <path>hdevelop/Applications/Data-Codes/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.datacode</applarea>
      <method>method.datacode</method>
      <operator>clear_data_code_2d_model</operator>
      <operator>create_data_code_2d_model</operator>
      <operator>find_data_code_2d</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>query_aop_info.hdev</name>
      <desc>Abfragen von Informationen zur automatischen Operatorparallelisierung (aop)</desc>
      <path>hdevelop/System/Parallelization/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>get_aop_info</operator>
      <operator>optimize_aop</operator>
      <operator>query_aop_info</operator>
      <operator>set_aop_info</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>query_system_parameters.hdev</name>
      <desc>Abfragen von Systemparametern</desc>
      <path>hdevelop/System/Parameters/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <operator>fwrite_string</operator>
      <operator>get_compute_device_info</operator>
      <operator>get_param_info</operator>
      <operator>get_system</operator>
      <operator>get_system_time</operator>
      <operator>info_framegrabber</operator>
      <operator>open_file</operator>
      <operator>query_available_compute_devices</operator>
      <operator>tuple_environment</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>radial_distortion.hdev</name>
      <desc>Eliminieren radialer Verzeichnungen</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.edgeextr</method>
      <method>method.trafo.rectif</method>
      <method>method.xld</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_contours_xld</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>gen_radial_distortion_map</operator>
      <operator>map_image</operator>
      <operator>rgb1_to_gray</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>radial_distortion_comparison.hdev</name>
      <desc>Vergleichen der Ergebnisse der Kamerakalibrierung und der Selbstkalibrierung der radialen Verzeichnung</desc>
      <path>hdevelop/Calibration/Self-Calibration/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.funct1d</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>calibrate_cameras</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data</operator>
      <operator>radial_distortion_self_calibration</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>radial_distortion_self_calibration.hdev</name>
      <desc>Kalibrieren der Koeffizienten für die radiale Verzeichnung und des Zentrums der Verzeichnung</desc>
      <path>hdevelop/Calibration/Self-Calibration/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.edgeextr</method>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>change_radial_distortion_image</operator>
      <operator>radial_distortion_self_calibration</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>radiometric_self_calibration.hdev</name>
      <desc>Ausführen einer radiometrischen Selbstkalibrierung zweier unterschiedlicher Kameras</desc>
      <path>hdevelop/Calibration/Self-Calibration/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib.radiom</method>
      <operator>dev_set_lut</operator>
      <operator>histo_2dim</operator>
      <operator>radiometric_self_calibration</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>rank_image.hdev</name>
      <desc>Glätten eines Bildes mit einer beliebigen Rangmaske</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <operator>rank_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>rank_n.hdev</name>
      <desc>Verwenden von rank_n zum Berechnen eines Hintergrundbildes für eine Szene mit bewegten Objekten</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <method>method.filter.general</method>
      <operator>mean_n</operator>
      <operator>rank_n</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>rank_rect.hdev</name>
      <desc>Verwenden einer Rangfilterung mit rechteckigen Rangmasken für eine robustere Grauwertmorphologie</desc>
      <path>hdevelop/Filters/Smoothing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <operator>gray_opening_rect</operator>
      <operator>rank_rect</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>rank_region.hdev</name>
      <desc>Anwenden des rank Operators für Regionen</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.filter.general</method>
      <operator>rank_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>read_braille_photometric_stereo.hdev</name>
      <desc>Lesen und dekodieren von Braille-Schrift auf einer pharmazeutischen Verpackung</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.pharm</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.stereo.phot</method>
      <operator>derivate_vector_field</operator>
      <operator>partition_dynamic</operator>
      <operator>photometric_stereo</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>read_region.hdev</name>
      <desc>Lesen von Regionendaten aus einer Regionendatei oder einem Binärbild</desc>
      <path>hdevelop/File/Region/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <method>method.regionproc</method>
      <operator>read_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>read_string.hdev</name>
      <desc>Auffordern zu einer Eingabe des Nutzers in einem Textfenster</desc>
      <path>hdevelop/Graphics/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>disp_arrow</operator>
      <operator>read_string</operator>
      <operator>set_tposition</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>real_time_grabbing.hdev</name>
      <desc>Ermitteln der erreichbaren Bildwiederholrate für das Einziehen und Bearbeiten von Bildern</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <method>method.filter.general</method>
      <operator>close_framegrabber</operator>
      <operator>count_seconds</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>new_line</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>sub_image</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>receive_serialized_item.hdev</name>
      <desc>Empfangen (und Senden) von serialisierten Tupeln und ikonischen Objekten über Sockets</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.comm</method>
      <method>method.match.shape</method>
      <operator>clear_serialized_item</operator>
      <operator>close_socket</operator>
      <operator>deserialize_shape_model</operator>
      <operator>deserialize_tuple</operator>
      <operator>open_socket_accept</operator>
      <operator>receive_serialized_item</operator>
      <operator>send_serialized_item</operator>
      <operator>serialize_object</operator>
      <operator>serialize_tuple</operator>
      <operator>socket_accept_connect</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>reconstruct_3d_object_model_for_matching.hdev</name>
      <desc>Rekonstruktion eines 3D-Objektmodells aus mehreren Ansichten mit 3D-Registrierung für Matching</desc>
      <path>hdevelop/Applications/Robot-Vision/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.measure.3D</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.match3d.surface</method>
      <method>method.object3d</method>
      <operator>affine_trans_object_model_3d</operator>
      <operator>connection_object_model_3d</operator>
      <operator>copy_object_model_3d</operator>
      <operator>create_stereo_model</operator>
      <operator>create_surface_model</operator>
      <operator>distance_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>reconstruct_surface_stereo</operator>
      <operator>register_object_model_3d_global</operator>
      <operator>register_object_model_3d_pair</operator>
      <operator>sample_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <operator>set_stereo_model_image_pairs</operator>
      <operator>set_stereo_model_param</operator>
      <operator>smooth_object_model_3d</operator>
      <operator>triangulate_object_model_3d</operator>
      <operator>union_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>reconstruct_connection_rod_calib.hdev</name>
      <desc>Messen von 3D-Objekten mit kalibriertem Lichtschnittverfahren</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <method>method.laser</method>
      <operator>clear_sheet_of_light_model</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>get_sheet_of_light_result</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>measure_profile_sheet_of_light</operator>
      <operator>set_sheet_of_light_param</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>reconstruct_connection_rod_uncalib.hdev</name>
      <desc>Messen von 3D-Objekten mit unkalibriertem Lichtschnittverfahren</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.laser</method>
      <operator>clear_sheet_of_light_model</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>get_sheet_of_light_result</operator>
      <operator>measure_profile_sheet_of_light</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>reconstruct_points_stereo.hdev</name>
      <desc>Rekonstruieren von 3D-Punkten mit Multi-View Stereo</desc>
      <path>hdevelop/3D-Reconstruction/Multi-View/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.stereo.multi</method>
      <operator>clear_camera_setup_model</operator>
      <operator>clear_object_model_3d</operator>
      <operator>create_calib_data</operator>
      <operator>create_camera_setup_model</operator>
      <operator>create_stereo_model</operator>
      <operator>find_calib_object</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>get_camera_setup_param</operator>
      <operator>query_color</operator>
      <operator>read_camera_setup_model</operator>
      <operator>reconstruct_points_stereo</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_camera_setup_cam_param</operator>
      <operator>tuple_gen_sequence</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>rectangularity.hdev</name>
      <desc>Berechnen der Rechtwinkligkeit von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <industry>industry.electr</industry>
      <industry>industry.semicon</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>affine_trans_region</operator>
      <operator>auto_threshold</operator>
      <operator>fill_up</operator>
      <operator>gen_image_const</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>move_region</operator>
      <operator>overpaint_region</operator>
      <operator>rectangularity</operator>
      <operator>union2</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>rectify_results.hdev</name>
      <desc>Rektifizieren eines Bildes aufgrund von Matchingergebnissen</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.trafo.align</method>
      <method>method.trafo.rectif</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>crop_rectangle1</operator>
      <operator>disp_rectangle1</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>inspect_shape_model</operator>
      <operator>smallest_rectangle1</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>reduce_object_model_3d_by_view.hdev</name>
      <desc>Entfernen von Teilen eines 3D-Objektmodells nach Ansicht</desc>
      <path>hdevelop/3D-Object-Model/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>reduce_object_model_3d_by_view</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>regiongrowing.hdev</name>
      <desc>Segmentieren eines Bildes mit Flächenwachstum</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.regionproc</method>
      <method>method.segm</method>
      <method>method.morphol</method>
      <method>method.visual</method>
      <operator>closing_circle</operator>
      <operator>fill_up_shape</operator>
      <operator>median_image</operator>
      <operator>regiongrowing</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>regiongrowing_mean.hdev</name>
      <desc>Anwenden eines Flächenwachstums mit Mittelwertbildung</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.regionproc</method>
      <method>method.segm</method>
      <operator>median_image</operator>
      <operator>regiongrowing</operator>
      <operator>regiongrowing_mean</operator>
      <operator>shape_trans</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>regiongrowing_n.hdev</name>
      <desc>Anwenden eines Flächenwachstums für mehrkanalige Bilder</desc>
      <path>hdevelop/Segmentation/Region-Growing/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <method>method.color</method>
      <method>method.texture</method>
      <operator>compose3</operator>
      <operator>median_image</operator>
      <operator>regiongrowing_n</operator>
      <operator>texture_laws</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>regression.hdev</name>
      <desc>Approximieren einer Funktion mit MLP</desc>
      <path>hdevelop/Classification/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.classif</method>
      <method>method.visual</method>
      <method>method.numeric</method>
      <method>method.functions</method>
      <operator>add_sample_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>create_class_mlp</operator>
      <operator>disp_cross</operator>
      <operator>disp_line</operator>
      <operator>evaluate_class_mlp</operator>
      <operator>train_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>regularized_ocr_mlp.hdev</name>
      <desc>Vergleich der Generalisierungseigenschaften von unregularisierten und regularisierten OCR-Klassifikatoren</desc>
      <path>hdevelop/OCR/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.classif</method>
      <operator>add_image</operator>
      <operator>add_noise_white</operator>
      <operator>affine_trans_image</operator>
      <operator>append_ocr_trainf</operator>
      <operator>binary_threshold</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>count_seconds</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>delete_file</operator>
      <operator>do_ocr_single_class_mlp</operator>
      <operator>expand_domain_gray</operator>
      <operator>file_exists</operator>
      <operator>full_domain</operator>
      <operator>gen_image_proto</operator>
      <operator>get_regularization_params_ocr_class_mlp</operator>
      <operator>gray_dilation_shape</operator>
      <operator>gray_erosion_shape</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>intersection</operator>
      <operator>read_ocr_trainf</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>rotate_image</operator>
      <operator>scale_image</operator>
      <operator>set_regularization_params_ocr_class_mlp</operator>
      <operator>smooth_image</operator>
      <operator>sort_region</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>remove_noise_region.hdev</name>
      <desc>Entfernen von Rauschen aus einer Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.filter.general</method>
      <operator>hamming_change_region</operator>
      <operator>hamming_distance</operator>
      <operator>remove_noise_region</operator>
      <operator>union1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>remove_texture_fft.hdev</name>
      <desc>Entfernen von Textur aus einem Bild</desc>
      <path>hdevelop/Applications/Texture-Inspection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.texture</applarea>
      <method>method.trafo.geom</method>
      <method>method.fft</method>
      <method>method.morphol</method>
      <method>method.filter.general</method>
      <operator>binomial_filter</operator>
      <operator>fft_generic</operator>
      <operator>optimize_fft_speed</operator>
      <operator>power_real</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>resistor.hdev</name>
      <desc>Extrahieren von Lötpunkten unter Verwendung von multiplen Fokusebenen</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.dff</method>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <operator>access_channel</operator>
      <operator>channels_to_image</operator>
      <operator>connection</operator>
      <operator>depth_from_focus</operator>
      <operator>fill_up</operator>
      <operator>mean_image</operator>
      <operator>scale_image_max</operator>
      <operator>select_shape_std</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>reuse_model.hdev</name>
      <desc>Speichern und Wiederverwenden eines Formmodells</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.metal</industry>
      <industry>industry.machine</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.roi</method>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <operator>clear_shape_model</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>difference</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>gen_circle</operator>
      <operator>get_domain</operator>
      <operator>get_shape_model_contours</operator>
      <operator>get_shape_model_origin</operator>
      <operator>get_shape_model_params</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>inspect_shape_model</operator>
      <operator>read_shape_model</operator>
      <operator>write_image</operator>
      <operator>write_shape_model</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>rft_generic.hdev</name>
      <desc>Filtern von Bildern mit einer reellen FFT</desc>
      <path>hdevelop/Filters/FFT/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.fft</method>
      <method>method.filter.general</method>
      <operator>convert_image_type</operator>
      <operator>convol_fft</operator>
      <operator>derivate_gauss</operator>
      <operator>gen_derivative_filter</operator>
      <operator>gen_gauss_filter</operator>
      <operator>intensity</operator>
      <operator>min_max_gray</operator>
      <operator>mult_image</operator>
      <operator>optimize_rft_speed</operator>
      <operator>rft_generic</operator>
      <operator>sub_image</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>rigid_trans_object_model_3d.hdev</name>
      <desc>Anwenden einer rigiden Transformationen auf ein 3D-Objektmodell</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.general</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>gen_cylinder_object_model_3d</operator>
      <operator>rigid_trans_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>rim.hdev</name>
      <desc>Untersuchen von Löchern und Schriftzeichen auf einer Felge</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.filter.general</method>
      <method>method.functions</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.align</method>
      <method>method.visual</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>closing_circle</operator>
      <operator>dev_set_part</operator>
      <operator>difference</operator>
      <operator>disp_ellipse</operator>
      <operator>dyn_threshold</operator>
      <operator>edges_sub_pix</operator>
      <operator>erosion_circle</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gauss_filter</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>intersection</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape</operator>
      <operator>set_tposition</operator>
      <operator>smallest_rectangle1</operator>
      <operator>smallest_rectangle2</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>rim_simple.hdev</name>
      <desc>Extrahieren von Löchern in einer Felge</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>boundary</operator>
      <operator>connection</operator>
      <operator>disp_arrow</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape</operator>
      <operator>set_tposition</operator>
      <operator>sort_contours_xld</operator>
      <operator>threshold</operator>
      <operator>union1</operator>
      <operator>write_string</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>roads.hdev</name>
      <desc>Extrahieren von Straßen aus Luftbildern</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.filter.edge</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>clip_contours_xld</operator>
      <operator>clip_region</operator>
      <operator>combine_roads_xld</operator>
      <operator>dev_display</operator>
      <operator>dev_set_line_width</operator>
      <operator>dev_set_part</operator>
      <operator>dev_set_window</operator>
      <operator>edges_image</operator>
      <operator>gen_contours_skeleton_xld</operator>
      <operator>gen_parallels_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>lines_gauss</operator>
      <operator>mod_parallels_xld</operator>
      <operator>reduce_domain</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>roberts.hdev</name>
      <desc>Extrahieren von Kanten mit dem Roberts Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>roberts</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>robinson_amp.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude) mit dem Robinson Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>robinson_amp</operator>
      <operator>skeleton</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>robinson_dir.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit dem Robinson Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>nonmax_suppression_dir</operator>
      <operator>robinson_dir</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>rotation_from_optical_flow.hdev</name>
      <desc>Schätzen des Rotationszentrums zwischen aufeinanderfolgenden Bildern</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.motion</method>
      <method>method.filter.general</method>
      <method>method.regionproc</method>
      <method>method.trafo.geom</method>
      <operator>gen_grid_region</operator>
      <operator>hom_mat2d_to_affine_par</operator>
      <operator>optical_flow_mg</operator>
      <operator>sobel_amp</operator>
      <operator>vector_field_to_real</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>rotchar.hdev</name>
      <desc>Schätzen kleiner Neigungswinkel von Textlinien</desc>
      <path>hdevelop/Applications/OCR/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.trafo.align</method>
      <method>method.visual</method>
      <method>method.morphol</method>
      <method>method.ocr</method>
      <operator>binary_threshold</operator>
      <operator>elliptic_axis</operator>
      <operator>rotate_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>roundness.hdev</name>
      <desc>Berechnen der Rundheit von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>roundness</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>runlength_distribution.hdev</name>
      <desc>Analysieren der Lauflängenkodierung von Regionen (Metadaten)</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <operator>runlength_distribution</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>runlength_features.hdev</name>
      <desc>Analysieren der Lauflängenkodierung von Regionen (Metadaten)</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <operator>runlength_features</operator>
      <operator>set_tposition</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>saddle_points_sub_pix.hdev</name>
      <desc>Erkennen von Sattelpunkten mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <industry>industry.auto</industry>
      <industry>industry.secure</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.segm</method>
      <operator>gen_cross_contour_xld</operator>
      <operator>rgb1_to_gray</operator>
      <operator>saddle_points_sub_pix</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>saperalt.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_2boards.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (zwei Boards)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_2cameras.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_crop.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_gio.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (GIO)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>saperalt_lut.hdev</name>
      <desc>Setzen einer Look-Up Tabelle für das SaperaLT-Interface</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_lut</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_lut</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_parameters.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>saperalt_simple.hdev</name>
      <desc>Verwenden des SaperaLT-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>7.0.3</newinversion>
   </example>
   <example>
      <name>scale_image_max.hdev</name>
      <desc>Maximales Streuen von Grauwerten auf den Wertebereich 0-255 (nur Byte Bilder)</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.visual</method>
      <operator>scale_image_max</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>scene_flow_globe.hdev</name>
      <desc>Berechnen des 3D Szenenflusses zwischen zwei Stereobildpaaren um die Bewegung eines Objekts in 3D zu bestimmen</desc>
      <path>hdevelop/Filters/Scene-Flow/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.geom</method>
      <method>method.motion</method>
      <method>method.stereo</method>
      <operator>affine_trans_point_3d</operator>
      <operator>binocular_disparity</operator>
      <operator>disparity_image_to_xyz</operator>
      <operator>distance_object_model_3d</operator>
      <operator>fit_primitives_object_model_3d</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>sample_object_model_3d</operator>
      <operator>scene_flow_calib</operator>
      <operator>scene_flow_uncalib</operator>
      <operator>unwarp_image_vector_field</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>segment_ball_bond_lead_frame.hdev</name>
      <desc>Untersuchen von Ball-Bondierungen</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.segm</method>
      <method>method.regionproc</method>
      <operator>shape_trans</operator>
      <operator>skeleton</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>segment_citrus_fruits.hdev</name>
      <desc>Segmentieren von Orangen und Zitronen aus Bildern mit MLP-basierter Farbklassifikation</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.food</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.classif</method>
      <method>method.roi</method>
      <method>method.segm</method>
      <operator>add_samples_image_class_mlp</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>clear_class_mlp</operator>
      <operator>create_class_mlp</operator>
      <operator>gen_empty_region</operator>
      <operator>train_class_mlp</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>segment_object_model_3d.hdev</name>
      <desc>Segmentieren von 2.5D Daten in zylindrische oder kugelförmige Teile</desc>
      <path>hdevelop/3D-Object-Model/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object3d</applarea>
      <applarea>applarea.recog.pos3d</applarea>
      <method>method.fitting3d</method>
      <method>method.object3d</method>
      <operator>copy_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>object_model_3d_to_xyz</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>segment_object_model_3d</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>segment_wedge_bonds.hdev</name>
      <desc>Untersuchen von Wedge-Bonds</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.morphol</method>
      <method>method.trafo.geom</method>
      <method>method.match.shape</method>
      <method>method.xld</method>
      <operator>clip_end_points_contours_xld</operator>
      <operator>create_shape_model_xld</operator>
      <operator>elliptic_axis</operator>
      <operator>find_shape_model</operator>
      <operator>set_shape_model_metric</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>select_characters.hdev</name>
      <desc>Segmentieren und Auswählen von Schriftzeichen</desc>
      <path>hdevelop/OCR/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <operator>rotate_image</operator>
      <operator>segment_characters</operator>
      <operator>select_characters</operator>
      <operator>text_line_orientation</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>select_contours_xld.hdev</name>
      <desc>Auswählen von XLD Konturen aufgrund verschiedener Merkmale</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.edgeextr</method>
      <method>method.io</method>
      <method>method.xld</method>
      <operator>disp_arrow</operator>
      <operator>disp_line</operator>
      <operator>draw_rectangle2</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>gen_rectangle2</operator>
      <operator>regress_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>split_contours_xld</operator>
      <operator>union_straight_contours_xld</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_object_model_3d.hdev</name>
      <desc>Auswählen von 3D-Objektmodellen aufgrund von Volumen und Durchmesser</desc>
      <path>hdevelop/3D-Object-Model/Features/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>connection_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>max_diameter_object_model_3d</operator>
      <operator>prepare_object_model_3d</operator>
      <operator>select_object_model_3d</operator>
      <operator>volume_object_model_3d_relative_to_plane</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>select_points_object_model_3d.hdev</name>
      <desc>Entfernen von Teilen eines 3D-Objektmodells mit einem Schwellwert</desc>
      <path>hdevelop/3D-Object-Model/Segmentation/</path>
      <industry>industry.metal</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.object3d</method>
      <method>method.visual</method>
      <operator>clear_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>read_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>select_region_point.hdev</name>
      <desc>Auswählen von Regionen, die ein vorgegebenes Pixel enthalten</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>get_mbutton</operator>
      <operator>select_region_point</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_region_spatial.hdev</name>
      <desc>Auswählen von Regionen, die links (rechts, über, unter) einer Referenzregion liegen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>gauss_filter</operator>
      <operator>select_region_spatial</operator>
      <operator>select_shape</operator>
      <operator>watersheds</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_shape.hdev</name>
      <desc>Auswählen von Regionen aufgrund von Formmerkmalen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>select_shape</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_shape_proto.hdev</name>
      <desc>Auswählen von Regionen, die in einer bestimmten Relation zu einer Referenzregion stehen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>select_shape_proto</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_shape_std.hdev</name>
      <desc>Auswählen der größten Region oder von Regionen, die einem Rechteck ähneln</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>select_shape_std</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>select_shape_xld.hdev</name>
      <desc>Auswählen von XLD Konturen aufgrund verschiedener Merkmale</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>crop_part</operator>
      <operator>select_shape_xld</operator>
      <operator>threshold_sub_pix</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>select_xld_point.hdev</name>
      <desc>Auswählen von Regionen, die einen vorgegebenen Punkt enthalten</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>select_xld_point</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>send_serialized_item.hdev</name>
      <desc>Senden (und empfangen) von serialisierten Tupeln und ikonischen Objekten über Sockets</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.comm</method>
      <method>method.match.shape</method>
      <operator>clear_serialized_item</operator>
      <operator>close_socket</operator>
      <operator>deserialize_object</operator>
      <operator>deserialize_tuple</operator>
      <operator>open_socket_connect</operator>
      <operator>receive_serialized_item</operator>
      <operator>send_serialized_item</operator>
      <operator>serialize_shape_model</operator>
      <operator>serialize_tuple</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>sentech.hdev</name>
      <desc>Verwenden des Sentech-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>sentech_2cameras.hdev</name>
      <desc>Verwenden des Sentech-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>sentech_parameters.hdev</name>
      <desc>Verwenden des Sentech-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>sentech_simple.hdev</name>
      <desc>Verwenden des Sentech-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>sentech_trigger.hdev</name>
      <desc>Verwenden des Sentech-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.4</newinversion>
   </example>
   <example>
      <name>sequence_diff.hdev</name>
      <desc>Überwachen von Verkehr durch Vergleichen zweier aufeinanderfolgender Bilder</desc>
      <path>hdevelop/Applications/Position-Recognition-2D/</path>
      <industry>industry.secure</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.morphol</method>
      <method>method.blob</method>
      <method>method.motion</method>
      <operator>dyn_threshold</operator>
      <operator>read_image</operator>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>serial.hdev</name>
      <desc>Verwenden von seriellen Anschlüssen in HALCON</desc>
      <path>hdevelop/System/Serial/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_serial</operator>
      <operator>open_serial</operator>
      <operator>read_serial</operator>
      <operator>set_serial_param</operator>
      <operator>write_serial</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>set_bar_code_param_specific.hdev</name>
      <desc>Setzen und Abfragen von Parametern für bestimmte Barcodetypen</desc>
      <path>hdevelop/Identification/Bar-Code/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.barcode</applarea>
      <method>method.barcode</method>
      <operator>get_bar_code_param_specific</operator>
      <operator>set_bar_code_param_specific</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>set_grayval.hdev</name>
      <desc>Einzeichnen einzelner Pixel in ein Bild</desc>
      <path>hdevelop/Image/Manipulation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>set_grayval</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>set_object_model_3d_attrib.hdev</name>
      <desc>Setzen von Attributen für 3D-Objektmodelle</desc>
      <path>hdevelop/3D-Object-Model/Creation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.object3d</method>
      <operator>clear_object_model_3d</operator>
      <operator>distance_object_model_3d</operator>
      <operator>gen_empty_object_model_3d</operator>
      <operator>gen_plane_object_model_3d</operator>
      <operator>set_object_model_3d_attrib</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>set_offset_template.hdev</name>
      <desc>Anpassen an Beleuchtungsänderungen durch Addieren eines Grauwertoffsets zu einem Template</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <operator>best_match_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template</operator>
      <operator>fill_interlace</operator>
      <operator>scale_image</operator>
      <operator>set_offset_template</operator>
      <operator>set_reference_template</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>set_paint_3d_plot.hdev</name>
      <desc>Verwenden des Operators set_paint im '3d_plot' Modus</desc>
      <path>hdevelop/Graphics/Parameters/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.dff</method>
      <method>method.visual</method>
      <operator>access_channel</operator>
      <operator>channels_to_image</operator>
      <operator>compose2</operator>
      <operator>depth_from_focus</operator>
      <operator>get_mposition_sub_pix</operator>
      <operator>get_window_param</operator>
      <operator>select_grayvalues_from_channels</operator>
      <operator>set_paint</operator>
      <operator>set_window_param</operator>
      <operator>tuple_find</operator>
      <operator>unproject_coordinates</operator>
      <operator>update_window_pose</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>set_params_class_knn.hdev</name>
      <desc>Verwenden des k-NN-Klassifikators und seiner Parameter</desc>
      <path>hdevelop/Classification/k-Nearest-Neighbor/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.classif</method>
      <operator>add_sample_class_knn</operator>
      <operator>classify_class_knn</operator>
      <operator>clear_class_knn</operator>
      <operator>create_class_knn</operator>
      <operator>get_params_class_knn</operator>
      <operator>get_sample_class_knn</operator>
      <operator>set_params_class_knn</operator>
      <operator>test_region_point</operator>
      <operator>train_class_knn</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>set_reference_template.hdev</name>
      <desc>Definieren der Referenzposition für ein Grauwerttemplate</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template</operator>
      <operator>fill_interlace</operator>
      <operator>gnuplot_close</operator>
      <operator>gnuplot_open_file</operator>
      <operator>gnuplot_plot_ctrl</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>set_reference_template</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>set_rejection_params_class_mlp.hdev</name>
      <desc>Definieren einer Rückweisungsklasse für einen MLP-Klassifikator</desc>
      <path>hdevelop/Classification/Neural-Nets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.classif</method>
      <method>method.segm</method>
      <operator>add_sample_class_mlp</operator>
      <operator>classify_class_mlp</operator>
      <operator>create_class_mlp</operator>
      <operator>evaluate_class_mlp</operator>
      <operator>get_sample_num_class_mlp</operator>
      <operator>set_rejection_params_class_mlp</operator>
      <operator>train_class_mlp</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>set_shape_model_min_contrast.hdev</name>
      <desc>Ändern des minimal benötigten Kontrasts für formbasiertes Matching</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>add_noise_white</operator>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>determine_shape_model_params</operator>
      <operator>edges_image</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>set_shape_model_param</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>set_shape_model_timeout.hdev</name>
      <desc>Verwenden des formbasierten Matchings im timeout Modus</desc>
      <path>hdevelop/Matching/Shape-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.morphol</method>
      <method>method.roi</method>
      <method>method.visual</method>
      <operator>catch</operator>
      <operator>clear_shape_model</operator>
      <operator>create_shape_model</operator>
      <operator>dev_get_exception_data</operator>
      <operator>endtry</operator>
      <operator>find_shape_model</operator>
      <operator>get_shape_model_contours</operator>
      <operator>set_shape_model_param</operator>
      <operator>throw</operator>
      <operator>try</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>set_tposition.hdev</name>
      <desc>Setzen der Position für den Textcursor im Ausgabefenster</desc>
      <path>hdevelop/Graphics/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>disp_arrow</operator>
      <operator>set_tposition</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>shape_trans.hdev</name>
      <desc>Transformieren der Form einer Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>shape_trans_xld.hdev</name>
      <desc>Transformieren von Konturen in verschiedene Standardformen</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <method>method.regionproc</method>
      <method>method.xld</method>
      <operator>crop_part</operator>
      <operator>shape_trans_xld</operator>
      <operator>threshold_sub_pix</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>shapedrive_objectmodel3d.hdev</name>
      <desc>Verwenden des ShapeDrive-Interfaces, um ein 3D-Objektmodell zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>shapedrive_parameters.hdev</name>
      <desc>Verwenden des ShapeDrive-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>shapedrive_simple.hdev</name>
      <desc>Verwenden des ShapeDrive-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <newinversion>11.0.2</newinversion>
   </example>
   <example>
      <name>shock_filter.hdev</name>
      <desc>Schärfen eines defokussierten Bildes mit einem Shockfilter</desc>
      <path>hdevelop/Filters/Enhancement/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <operator>fill_interlace</operator>
      <operator>shock_filter</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>show_coordinate_systems_hand_eye.hdev</name>
      <desc>Stelle die Objektpose relativ zum Welt-, Kamera- und Roboter-Koordinatensystem dar</desc>
      <path>hdevelop/Transformations/Poses/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.calib.handeye</method>
      <operator>create_pose</operator>
      <operator>pose_compose</operator>
      <operator>pose_invert</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>sick-3dcamera.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_buffer_queue.hdev</name>
      <desc>Verwenden des SICK-3DCamera Interfaces (Evaluierung der internen Buffer-Queue)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data_async</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.4</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_calibration.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (Kalibrierung und Entzerrung)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_components.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (verschiedene Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>count_channels</operator>
      <operator>grab_data</operator>
      <operator>grab_data_async</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>scale_image_max</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_grabbing_modes.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (verschiedene Bildeinzugs-Modi)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <newinversion>10.0.4</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_objectmodel3d.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces, um ein 3D-Objektmodell aus SICK-Ranger-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>gen_image_surface_first_order</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>mirror_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_parameters.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>sick-3dcamera_simple.hdev</name>
      <desc>Verwenden des SICK-3DCamera-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>scale_image_max</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>sick-scanningruler_objectmodel3d.hdev</name>
      <desc>Verwenden des SICK-ScanningRuler-Interfaces, um ein 3D-Objektmodell aus SICK-Ranger-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.io</method>
      <operator>clear_object_model_3d</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>grab_data</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>set_object_model_3d_attrib_mod</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>sick-scanningruler_parameters.hdev</name>
      <desc>Verwenden des SICK-ScanningRuler-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.io</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>sick-scanningruler_simple.hdev</name>
      <desc>Verwenden des SICK-ScanningRuler-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.io</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>siliconsoftware.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>siliconsoftware_continuous.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (kontinuierlicher Bildeinzug)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>siliconsoftware_fieldparameter.hdev</name>
      <desc>Verwenden des SiliconSoftware Interfaces (Visual Applets Feldparameter)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.4</newinversion>
   </example>
   <example>
      <name>siliconsoftware_gige_vision.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (GigE Vision)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>siliconsoftware_multiroi.hdev</name>
      <desc>Verwenden des SiliconSoftware Interfaces (Visual Applets ROI-Modul)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.4</newinversion>
   </example>
   <example>
      <name>siliconsoftware_objectmodel3d.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces, um ein 3D-Objektmodell zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>apply_sheet_of_light_calibration</operator>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>create_sheet_of_light_model</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>get_sheet_of_light_result_object_model_3d</operator>
      <operator>grab_data</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>set_sheet_of_light_param</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>siliconsoftware_parameters.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>siliconsoftware_simple.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>9.0.2</newinversion>
   </example>
   <example>
      <name>siliconsoftware_smartapplets.hdev</name>
      <desc>Verwenden des SiliconSoftware-Interfaces (SmartApplets)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_data_async</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>simple_reading.hdev</name>
      <desc>Lesen von Schriftzeichen mit einem vortrainierten Font</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.blob</method>
      <method>method.ocr</method>
      <method>method.visual</method>
      <operator>clear_text_model</operator>
      <operator>clear_text_result</operator>
      <operator>create_text_model_reader</operator>
      <operator>find_text</operator>
      <operator>get_text_object</operator>
      <operator>get_text_result</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>simple_training.hdev</name>
      <desc>Trainieren eines OCR Fonts aus einer Trainingsdatei</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.classif</method>
      <method>method.ocr</method>
      <operator>clear_ocr_class_mlp</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>trainf_ocr_class_mlp</operator>
      <operator>write_ocr_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>simplify_object_model_3d.hdev</name>
      <desc>Vereinfachen eines komplexen 3D Objektmodells</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <method>method.object3d</method>
      <operator>get_object_model_3d_params</operator>
      <operator>simplify_object_model_3d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>simultaneous_grabbing.hdev</name>
      <desc>Gleichzeitiges Bild einziehen von mehreren Kameras</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>count_channels</operator>
      <operator>decompose2</operator>
      <operator>grab_image</operator>
      <operator>image_to_channels</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_concat</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>sine.hdev</name>
      <desc>Berechnen und Zeichnen der Sinuskurve von 0 bis 3*Pi</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.functions</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>assign</operator>
      <operator>disp_line</operator>
   </example>
   <example>
      <name>skeleton.hdev</name>
      <desc>Berechnen des Skeletts einer Region</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>skeleton</operator>
      <operator>sobel_amp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>smallest_bounding_box_object_model_3d.hdev</name>
      <desc>Berechnen der umschliessenden Quader für 3D-Objektmodelle</desc>
      <path>hdevelop/3D-Object-Model/Features/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <method>method.visual</method>
      <method>method.object3d</method>
      <operator>smallest_bounding_box_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>smallest_circle.hdev</name>
      <desc>Berechnen der kleinsten umgebenden Kreise von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>gen_circle</operator>
      <operator>smallest_circle</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>smallest_rectangle1.hdev</name>
      <desc>Berechnen der kleinsten umgebenden achsenparallelen Rechtecke von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>gen_rectangle1</operator>
      <operator>smallest_rectangle1</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>smallest_rectangle2.hdev</name>
      <desc>Berechnen der kleinsten umgebenden Rechtecke von Regionen</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>gen_rectangle2</operator>
      <operator>smallest_rectangle2</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>sobel_amp.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude) mit dem Sobel Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>skeleton</operator>
      <operator>sobel_amp</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>sobel_dir.hdev</name>
      <desc>Extrahieren von Kanten (Amplitude und Richtung) mit dem Sobel Operator</desc>
      <path>hdevelop/Filters/Edges/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.edge</method>
      <operator>nonmax_suppression_dir</operator>
      <operator>sobel_dir</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>sock_recv.hdev</name>
      <desc>Empfangen von Bild- und Tupeldaten über eine Socketverbindung</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.error</method>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>convert_image_type</operator>
      <operator>dev_error_var</operator>
      <operator>dev_set_check</operator>
      <operator>get_next_socket_data_type</operator>
      <operator>open_socket_accept</operator>
      <operator>receive_image</operator>
      <operator>receive_region</operator>
      <operator>receive_tuple</operator>
      <operator>send_image</operator>
      <operator>send_region</operator>
      <operator>send_tuple</operator>
      <operator>socket_accept_connect</operator>
      <operator>wait_seconds</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>sock_send.hdev</name>
      <desc>Senden von Bild- und Tupeldaten über eine Socketverbindung</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>convert_image_type</operator>
      <operator>open_socket_connect</operator>
      <operator>query_all_colors</operator>
      <operator>receive_image</operator>
      <operator>receive_region</operator>
      <operator>receive_tuple</operator>
      <operator>send_image</operator>
      <operator>send_region</operator>
      <operator>send_tuple</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>solve_linear_equation.hdev</name>
      <desc>Verwenden von Matrizen zum Lösen linearer Gleichungen</desc>
      <path>hdevelop/Matrix/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.numeric</method>
      <operator>clear_matrix</operator>
      <operator>create_matrix</operator>
      <operator>set_sub_matrix</operator>
      <operator>solve_matrix</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>sort_contours_xld.hdev</name>
      <desc>Sortieren von XLD Konturen nach ihrer räumlichen Position</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>select_contours_xld</operator>
      <operator>set_line_style</operator>
      <operator>sort_contours_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>sort_region.hdev</name>
      <desc>Sortieren von Regionen nach ihrer räumlichen Position</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.regionproc</method>
      <operator>area_center</operator>
      <operator>connection</operator>
      <operator>dyn_threshold</operator>
      <operator>mean_image</operator>
      <operator>sort_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>spatial_relation.hdev</name>
      <desc>Berechnen der Lage von Regionen relativ zueinander (links, rechts, über, unter)</desc>
      <path>hdevelop/Regions/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.feat</method>
      <operator>spatial_relation</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>split_skeleton_lines.hdev</name>
      <desc>Aufspalten und Approximieren von nicht verzweigten Regionen, die 1 Pixel breit sind</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>connection</operator>
      <operator>difference</operator>
      <operator>disp_line</operator>
      <operator>junctions_skeleton</operator>
      <operator>skeleton</operator>
      <operator>split_skeleton_lines</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>split_skeleton_lines2.hdev</name>
      <desc>Aufspalten und Approximieren von nicht verzweigten Regionen, die 1 Pixel breit sind</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>edges_image</operator>
      <operator>junctions_skeleton</operator>
      <operator>skeleton</operator>
      <operator>split_skeleton_lines</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>split_skeleton_region.hdev</name>
      <desc>Aufspalten von nicht verzweigten Regionen, die 1 Pixel breit sind</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>junctions_skeleton</operator>
      <operator>skeleton</operator>
      <operator>split_skeleton_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>split_skeleton_region2.hdev</name>
      <desc>Aufspalten von nicht verzweigten Regionen, die 1 Pixel breit sind</desc>
      <path>hdevelop/Regions/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regionproc</method>
      <method>method.morphol</method>
      <operator>edges_image</operator>
      <operator>junctions_skeleton</operator>
      <operator>skeleton</operator>
      <operator>split_skeleton_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>stamp_catalogue.hdev</name>
      <desc>Segmentieren und Gruppieren von Schriftzeichen auf einer Seite mit Stördaten</desc>
      <path>hdevelop/Applications/Print-Inspection/</path>
      <industry>industry.print</industry>
      <applarea>applarea.ident.ocr</applarea>
      <applarea>applarea.inspect.print</applarea>
      <method>method.visual</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>dev_open_window</operator>
      <operator>read_image</operator>
      <operator>shape_trans</operator>
      <operator>top_hat</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>stationary_camera_self_calibration.hdev</name>
      <desc>Ausführen einer Selbstkalibrierung einer Kamera</desc>
      <path>hdevelop/Calibration/Self-Calibration/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.match.point</method>
      <method>method.mosaic</method>
      <method>method.filter.points</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.align</method>
      <operator>calibrate_cameras</operator>
      <operator>cam_mat_to_cam_par</operator>
      <operator>change_radial_distortion_cam_par</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>gen_bundle_adjusted_mosaic</operator>
      <operator>gen_radial_distortion_map</operator>
      <operator>gen_spherical_mosaic</operator>
      <operator>hom_mat2d_compose</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>map_image</operator>
      <operator>points_foerstner</operator>
      <operator>proj_match_points_ransac</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>stationary_camera_self_calibration</operator>
      <operator>tile_images_offset</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>statistics_points_xld.hdev</name>
      <desc>Analysieren von statistischen 2D Daten mit *_points_xld Operatoren</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.roi</method>
      <method>method.ocr</method>
      <method>method.visual</method>
      <operator>area_center_points_xld</operator>
      <operator>clear_ocr_class_mlp</operator>
      <operator>connection</operator>
      <operator>create_ocr_class_mlp</operator>
      <operator>dilation_circle</operator>
      <operator>disp_arrow</operator>
      <operator>disp_line</operator>
      <operator>elliptic_axis_points_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_features_ocr_class_mlp</operator>
      <operator>intersection</operator>
      <operator>moments_points_xld</operator>
      <operator>read_ocr_trainf_names</operator>
      <operator>reduce_domain</operator>
      <operator>smallest_rectangle1_xld</operator>
      <operator>sort_region</operator>
      <operator>tuple_concat</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>stereo_calibration.hdev</name>
      <desc>Kalibrieren eines Stereoaufbaus</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.calib</method>
      <method>method.stereo</method>
      <method>method.trafo.rectif</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>calibrate_cameras</operator>
      <operator>clear_calib_data</operator>
      <operator>create_calib_data</operator>
      <operator>find_calib_object</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>get_calib_data</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>map_image</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>write_cam_par</operator>
      <operator>write_camera_setup_model</operator>
      <operator>write_pose</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>stop.hdev</name>
      <desc>Abbrechen der Ausführung innerhalb einer Schleife zum Sichten von Zwischenergebnissen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>regiongrowing</operator>
      <operator>stop</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>string.hdev</name>
      <desc>Formatieren von Zeichenketten und Zahlen</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.string</method>
      <method>method.io</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>sub_image.hdev</name>
      <desc>Subtrahieren zweier Bilder</desc>
      <path>hdevelop/Filters/Arithmetic/</path>
      <industry>industry.general</industry>
      <industry>industry.auto</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.filter.general</method>
      <method>method.motion</method>
      <operator>convert_image_type</operator>
      <operator>sub_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>surface_scratch.hdev</name>
      <desc>Erkennen von Kratzern auf einer Oberfläche mit einem lokalen Schwellwertverfahren und Morphologie</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.auto</industry>
      <industry>industry.metal</industry>
      <industry>industry.optic</industry>
      <applarea>applarea.inspect.surface</applarea>
      <method>method.filter.edge</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <operator>connection</operator>
      <operator>dilation_circle</operator>
      <operator>dyn_threshold</operator>
      <operator>mean_image</operator>
      <operator>select_shape</operator>
      <operator>skeleton</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>swissranger_objectmodel3d.hdev</name>
      <desc>Verwenden des SwissRanger-Interfaces, um ein 3D-Objektmodell aus SwissRanger-MESA-Imaging-SR4000-Sensordaten zu erstellen</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>clear_object_model_3d</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>11.0.1</newinversion>
   </example>
   <example>
      <name>swissranger_parameters.hdev</name>
      <desc>Verwenden des SwissRanger-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>swissranger_simple.hdev</name>
      <desc>Verwenden des SwissRanger-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>xyz_to_object_model_3d</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>switch_case.hdev</name>
      <desc>Verwenden einer Switch/Case-Anweisung für Mehrfachverzweigungen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>break</operator>
      <operator>case</operator>
      <operator>default</operator>
      <operator>dev_inspect_ctrl</operator>
      <operator>endswitch</operator>
      <operator>switch</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>symm_difference_closed_contours_xld.hdev</name>
      <desc>Verwenden von symm_difference_closed_contours_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>symm_difference_closed_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>symm_difference_closed_polygons_xld.hdev</name>
      <desc>Verwenden von symm_difference_closed_polygons_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>symm_difference_closed_polygons_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>symmetry.hdev</name>
      <desc>Analysieren der Symmetrie in horizontaler Richtung</desc>
      <path>hdevelop/Filters/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.color</method>
      <method>method.morphol</method>
      <operator>clip_region</operator>
      <operator>closing_circle</operator>
      <operator>decompose3</operator>
      <operator>expand_line</operator>
      <operator>gauss_filter</operator>
      <operator>opening_rectangle1</operator>
      <operator>rank_region</operator>
      <operator>smallest_rectangle1</operator>
      <operator>symmetry</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>synthetic_circle.hdev</name>
      <desc>Verwenden eines synthetischen Modells (Kreis) für die Suche nach einem Kondensator auf einer Platine</desc>
      <path>solution_guide/matching/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.shape</method>
      <method>method.visual</method>
      <operator>clear_shape_model</operator>
      <operator>close_framegrabber</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_image_const</operator>
      <operator>get_shape_model_contours</operator>
      <operator>grab_image</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>inspect_shape_model</operator>
      <operator>open_framegrabber</operator>
      <operator>paint_xld</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>test_closed_xld.hdev</name>
      <desc>Testen, ob XLD-Konturen geschlossen sind</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>test_closed_xld</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>test_jit_speedup.hdev</name>
      <desc>Berechnen des Speedups von JIT-kompilierten Prozeduren</desc>
      <path>hdevelop/Develop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.general</method>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>test_self_intersection_xld.hdev</name>
      <desc>Testen, ob sich eine Kontur selbst überschneidet</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>close_contours_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>test_self_intersection_xld</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>test_xld_point.hdev</name>
      <desc>Testen, ob eine Kontur einen bestimmten Punkt enthält</desc>
      <path>hdevelop/XLD/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>test_xld_point</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>text_line_orientation.hdev</name>
      <desc>Erkennen und Korrigieren der Orientierung aus text_lines</desc>
      <path>hdevelop/OCR/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.visual</method>
      <method>method.regionproc</method>
      <operator>closing_circle</operator>
      <operator>connection</operator>
      <operator>dilation_rectangle1</operator>
      <operator>dots_image</operator>
      <operator>gen_rectangle1</operator>
      <operator>intensity</operator>
      <operator>intersection</operator>
      <operator>rotate_image</operator>
      <operator>scale_image_max</operator>
      <operator>select_shape</operator>
      <operator>smallest_rectangle1</operator>
      <operator>text_line_orientation</operator>
      <operator>threshold</operator>
      <operator>union1</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>text_line_slant.hdev</name>
      <desc>Korrigieren von verkippten Schriftzeichen für die OCR Segmentierung</desc>
      <path>hdevelop/OCR/Segmentation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.ocr</method>
      <method>method.visual</method>
      <method>method.regionproc</method>
      <operator>affine_trans_image</operator>
      <operator>connection</operator>
      <operator>copy_obj</operator>
      <operator>dilation_rectangle1</operator>
      <operator>erosion_circle</operator>
      <operator>gen_rectangle1</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_slant</operator>
      <operator>intersection</operator>
      <operator>partition_dynamic</operator>
      <operator>smallest_rectangle1</operator>
      <operator>text_line_slant</operator>
      <operator>threshold</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>texture.hdev</name>
      <desc>Finden texturierter Gebiete (Bäume und Büsche)</desc>
      <path>hdevelop/Applications/Object-Recognition-2D/</path>
      <industry>industry.photo</industry>
      <applarea>applarea.recog.object2d</applarea>
      <method>method.texture</method>
      <method>method.classif</method>
      <method>method.morphol</method>
      <method>method.blob</method>
      <operator>class_2dim_sup</operator>
      <operator>closing_circle</operator>
      <operator>dilation_circle</operator>
      <operator>draw_region</operator>
      <operator>fill_up</operator>
      <operator>gen_rectangle1</operator>
      <operator>histo_2dim</operator>
      <operator>median_separate</operator>
      <operator>opening_circle</operator>
      <operator>texture_laws</operator>
      <operator>threshold</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>texture_laws.hdev</name>
      <desc>Filtern eines Bildes mit einem Laws-Texturfilter</desc>
      <path>hdevelop/Filters/Texture/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.texture</method>
      <method>method.filter.general</method>
      <method>method.classif</method>
      <method>method.io</method>
      <method>method.morphol</method>
      <operator>class_2dim_sup</operator>
      <operator>dilation_circle</operator>
      <operator>draw_region</operator>
      <operator>fill_up</operator>
      <operator>histo_2dim</operator>
      <operator>median_separate</operator>
      <operator>opening_circle</operator>
      <operator>texture_laws</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>texture_laws_mlp.hdev</name>
      <desc>Segmentieren eines Bildes aufgrund von Textur mit MLP-basierter Pixelklassifikation</desc>
      <path>hdevelop/Filters/Texture/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.texture</method>
      <method>method.filter.general</method>
      <method>method.classif</method>
      <operator>add_samples_image_class_mlp</operator>
      <operator>classify_image_class_lut</operator>
      <operator>classify_image_class_mlp</operator>
      <operator>clear_class_lut</operator>
      <operator>clear_class_mlp</operator>
      <operator>compose6</operator>
      <operator>create_class_lut_mlp</operator>
      <operator>create_class_mlp</operator>
      <operator>mean_image</operator>
      <operator>texture_laws</operator>
      <operator>train_class_mlp</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>threshold.hdev</name>
      <desc>Auswählen von Grauwerten, die in einem Intervall liegen</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.blob</method>
      <method>method.feat</method>
      <method>method.segm</method>
      <operator>connection</operator>
      <operator>fill_interlace</operator>
      <operator>select_shape</operator>
      <operator>threshold</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>threshold_sub_pix.hdev</name>
      <desc>Extrahieren von Grauwerthöhenlinien in einem Bild mit Subpixelgenauigkeit</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>fit_circle_contour_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>threshold_sub_pix</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>tile_channels.hdev</name>
      <desc>Kacheln von mehreren Bildkanälen zu einem großen Bild</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>append_channel</operator>
      <operator>tile_channels</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>tile_channels_reduced.hdev</name>
      <desc>Kacheln von Regionen mehrerer Bildkanäle zu einem großen Bild</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>append_channel</operator>
      <operator>tile_channels</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>tile_images.hdev</name>
      <desc>Kacheln von mehreren Bildern zu einem großen Bild</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <method>method.filter.general</method>
      <operator>mirror_image</operator>
      <operator>scale_image</operator>
      <operator>tile_images</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>tile_images_offset.hdev</name>
      <desc>Kacheln von mehreren Bildern zu einem großen Bild mit spezifischen Positionsangaben</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>crop_rectangle1</operator>
      <operator>sub_image</operator>
      <operator>tile_images_offset</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>tile_images_reduced.hdev</name>
      <desc>Kacheln von Regionen mehrerer Bilder zu einem großen Bild</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <method>method.filter.general</method>
      <operator>mirror_image</operator>
      <operator>rectangle1_domain</operator>
      <operator>scale_image</operator>
      <operator>tile_images</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>tile_images_size.hdev</name>
      <desc>Kacheln von Regionen mehrerer Bilder zu einem großen Bild</desc>
      <path>hdevelop/Image/Format/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.image</method>
      <operator>crop_rectangle1</operator>
      <operator>tile_images</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>track_engine_part.hdev</name>
      <desc>Verfolgen eines Motorteils mit perspektivisch deformierbarem Matching</desc>
      <path>hdevelop/Applications/Robot-Vision/</path>
      <industry>industry.auto</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.match.deform</method>
      <method>method.trafo.geom</method>
      <method>method.trafo.wcoord</method>
      <operator>clear_deformable_model</operator>
      <operator>create_planar_uncalib_deformable_model</operator>
      <operator>find_planar_uncalib_deformable_model</operator>
      <operator>get_deformable_model_contours</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>projective_trans_contour_xld</operator>
      <operator>projective_trans_image</operator>
      <operator>projective_trans_pixel</operator>
      <operator>set_deformable_model_origin</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>track_wires_on_chip.hdev</name>
      <desc>Verfolgen von Wire-Bondings auf einem Chip</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.xld</method>
      <operator>crop_contours_xld</operator>
      <operator>length_xld</operator>
      <operator>orientation_points_xld</operator>
      <operator>smooth_contours_xld</operator>
      <operator>union_collinear_contours_ext_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>train_characters_ocr.hdev</name>
      <desc>Trainieren eines neuen SVM Fonts für einen kleinen Zeichensatz</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.ident.ocr</applarea>
      <method>method.classif</method>
      <method>method.ocr</method>
      <method>method.blob</method>
      <operator>append_ocr_trainf</operator>
      <operator>clear_ocr_class_svm</operator>
      <operator>create_ocr_class_svm</operator>
      <operator>read_ocr_trainf</operator>
      <operator>reduce_ocr_class_svm</operator>
      <operator>trainf_ocr_class_svm</operator>
      <operator>write_ocr_class_svm</operator>
      <operator>write_ocr_trainf</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>transform_image_into_wcs.hdev</name>
      <desc>Bestimmen der Pose und Skalierung für ein rektifiziertes Bild</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.rectif</method>
      <method>method.visual</method>
      <operator>contour_to_world_plane_xld</operator>
      <operator>distance_pp</operator>
      <operator>full_domain</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>get_domain</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>image_to_world_plane</operator>
      <operator>map_image</operator>
      <operator>set_origin_pose</operator>
      <operator>smallest_rectangle1_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>transpose_region.hdev</name>
      <desc>Spiegeln von Regionen an einem Punkt</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>draw_region</operator>
      <operator>transpose_region</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>triangulate_object_model_3d_greedy.hdev</name>
      <desc>Triangulieren eines 3D-Objektmodells (greedy)</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.general</method>
      <method>method.object3d</method>
      <operator>read_object_model_3d</operator>
      <operator>triangulate_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>triangulate_object_model_3d_implicit.hdev</name>
      <desc>Triangulieren eines 3D-Objektmodells (implizit)</desc>
      <path>hdevelop/3D-Object-Model/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.robotvis</applarea>
      <method>method.general</method>
      <method>method.object3d</method>
      <operator>copy_object_model_3d</operator>
      <operator>read_object_model_3d</operator>
      <operator>triangulate_object_model_3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>try_catch.hdev</name>
      <desc>Verwenden der Fehlerbehandlung in HDevelop</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>catch</operator>
      <operator>continue</operator>
      <operator>dev_get_exception_data</operator>
      <operator>dev_set_preferences</operator>
      <operator>endtry</operator>
      <operator>throw</operator>
      <operator>try</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>tuple.hdev</name>
      <desc>Arbeiten mit Tupeln</desc>
      <path>hdevelop/Manuals/HDevelop/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>assign</operator>
   </example>
   <example>
      <name>tuple_compare_elem.hdev</name>
      <desc>Tupel elementweise vergleichen</desc>
      <path>hdevelop/Tuple/Comparison/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>assign</operator>
      <operator>dev_open_tool</operator>
      <operator>tuple_equal_elem</operator>
      <operator>tuple_greater_elem</operator>
      <operator>tuple_greater_equal_elem</operator>
      <operator>tuple_less_elem</operator>
      <operator>tuple_less_equal_elem</operator>
      <operator>tuple_not_equal_elem</operator>
      <operator>tuple_select_mask</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>tuple_find.hdev</name>
      <desc>Elemente in Tupeln finden</desc>
      <path>hdevelop/Tuple/Selection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>tuple_equal_elem</operator>
      <operator>tuple_find</operator>
      <operator>tuple_find_first</operator>
      <operator>tuple_find_last</operator>
      <operator>tuple_select_mask</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>tuple_histo_range.hdev</name>
      <desc>Berechnen der Werteverteilung eines Tupels in einem benutzerdefinierten Wertebereich</desc>
      <path>hdevelop/Tuple/Features/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>tuple_histo_range</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>tuple_insert.hdev</name>
      <desc>Elemente in ein Tupel einfügen</desc>
      <path>hdevelop/Tuple/Manipulation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>assign</operator>
      <operator>dev_open_tool</operator>
      <operator>tuple_insert</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>tuple_regexp.hdev</name>
      <desc>Verwenden von regulären Ausdrücken</desc>
      <path>hdevelop/Tuple/String-Operations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.regexp</method>
      <operator>list_files</operator>
      <operator>tuple_regexp_match</operator>
      <operator>tuple_regexp_replace</operator>
      <operator>tuple_regexp_select</operator>
      <operator>tuple_regexp_test</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>tuple_replace.hdev</name>
      <desc>Elemente eines Tupels ersetzen</desc>
      <path>hdevelop/Tuple/Manipulation/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>assign</operator>
      <operator>dev_open_tool</operator>
      <operator>tuple_replace</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>tuple_select_mask.hdev</name>
      <desc>Durch eine Maske vorgegebene Elemente eines Tupels auswählen</desc>
      <path>hdevelop/Tuple/Selection/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>dev_open_tool</operator>
      <operator>tuple_select_mask</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>tuple_sets.hdev</name>
      <desc>Ausführen von Mengenoperationen auf Tupeln</desc>
      <path>hdevelop/Tuple/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>assign</operator>
      <operator>tuple_difference</operator>
      <operator>tuple_intersection</operator>
      <operator>tuple_symmdiff</operator>
      <operator>tuple_union</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>tuple_substr.hdev</name>
      <desc>Zeichen aus einem String-Tupel ausschneiden</desc>
      <path>hdevelop/Tuple/String-Operations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.string</method>
      <method>method.tuple</method>
      <operator>dev_open_tool</operator>
      <operator>tuple_substr</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>tuple_type.hdev</name>
      <desc>Bestimmen der Datentypen von Tupelelementen</desc>
      <path>hdevelop/Tuple/Type/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.tuple</method>
      <operator>dev_inspect_ctrl</operator>
      <operator>tuple_is_int</operator>
      <operator>tuple_is_int_elem</operator>
      <operator>tuple_is_mixed</operator>
      <operator>tuple_is_real</operator>
      <operator>tuple_is_real_elem</operator>
      <operator>tuple_is_string</operator>
      <operator>tuple_is_string_elem</operator>
      <operator>tuple_type</operator>
      <operator>tuple_type_elem</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>twain_automatic_document_feeder.hdev</name>
      <desc>Verwenden des HALCON TWAIN-Interfaces mit der Automatic-Document-Feeder-Funktionalität</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>twain_interactive.hdev</name>
      <desc>Verwenden des HALCON TWAIN-Interfaces im interaktiven Modus</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>twain_manual.hdev</name>
      <desc>Verwenden des HALCON TWAIN-Interfaces mit einem Scanner im manuellen Modus</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.0</newinversion>
   </example>
   <example>
      <name>two_camera_calibration.hdev</name>
      <desc>Ausführen eines hochpräzisen Mosaickings mit einem speziellen Kalibrierkörper</desc>
      <path>solution_guide/3d_vision/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.calib</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.filter.general</method>
      <method>method.morphol</method>
      <method>method.metrol</method>
      <method>method.xld</method>
      <method>method.visual</method>
      <operator>break</operator>
      <operator>close_measure</operator>
      <operator>closing</operator>
      <operator>create_calib_data</operator>
      <operator>dyn_threshold</operator>
      <operator>elliptic_axis</operator>
      <operator>find_calib_object</operator>
      <operator>full_domain</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>get_calib_data_observ_contours</operator>
      <operator>get_calib_data_observ_points</operator>
      <operator>hom_mat3d_compose</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>hom_mat3d_translate_local</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>map_image</operator>
      <operator>mean_image</operator>
      <operator>measure_pairs</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>select_shape</operator>
      <operator>select_shape_std</operator>
      <operator>set_calib_data_calib_object</operator>
      <operator>set_calib_data_cam_param</operator>
      <operator>set_origin_pose</operator>
      <operator>smallest_rectangle2</operator>
      <operator>tile_images</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>ueye.hdev</name>
      <desc>Verwenden des uEye-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>ueye_2cameras.hdev</name>
      <desc>Verwenden des uEye-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>ueye_crop.hdev</name>
      <desc>Verwenden des uEye-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>ueye_parameters.hdev</name>
      <desc>Verwenden des uEye-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>tuple_sort</operator>
      <operator>wait_seconds</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>ueye_simple.hdev</name>
      <desc>Verwenden des uEye-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>ueye_timestamp.hdev</name>
      <desc>Verwenden des uEye-Interfaces (Zeitstempel)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>ueye_trigger.hdev</name>
      <desc>Verwenden des uEye-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>6.1.4</newinversion>
   </example>
   <example>
      <name>uncalib_stereo_boxes.hdev</name>
      <desc>Bestimmen der Oberflächen von Schachteln mit unkalibriertem binokularem Stereo</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>affine_trans_point_3d</operator>
      <operator>binocular_distance</operator>
      <operator>gen_binocular_rectification_map</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>get_domain</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>map_image</operator>
      <operator>match_rel_pose_ransac</operator>
      <operator>opening</operator>
      <operator>points_foerstner</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>test_xld_point</operator>
      <operator>tuple_find</operator>
      <operator>tuple_sort_index</operator>
      <operator>vector_to_rel_pose</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>union2_closed_contours_xld.hdev</name>
      <desc>Verwenden von union2_closed_contours_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_global_attrib_xld</operator>
      <operator>union2_closed_contours_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>union2_closed_polygons_xld.hdev</name>
      <desc>Verwenden von union2_closed_polygons_xld</desc>
      <path>hdevelop/XLD/Sets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.xld</method>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>gen_polygons_xld</operator>
      <operator>union2_closed_polygons_xld</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>union_cocircular_contours_xld.hdev</name>
      <desc>Vereinen von Konturen, die zum gleichen Kreis gehören</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>edges_sub_pix</operator>
      <operator>select_contours_xld</operator>
      <operator>union_cocircular_contours_xld</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>union_contours_xld.hdev</name>
      <desc>Finden von Pads auf einem Die durch die Verbindung kollinearer Liniensegmente</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.semicon</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>edges_sub_pix</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_rectangle2</operator>
      <operator>rectangle1_domain</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>smallest_rectangle2_xld</operator>
      <operator>union_adjacent_contours_xld</operator>
      <operator>union_collinear_contours_xld</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>union_cotangential_contours_xld.hdev</name>
      <desc>Vereinen von Konturen aufgrund ihrer lokalen Krümmung</desc>
      <path>hdevelop/XLD/Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <operator>gen_contour_nurbs_xld</operator>
      <operator>union_cotangential_contours_xld</operator>
      <newinversion>10.0</newinversion>
   </example>
   <example>
      <name>usb3vision_install_driver.hdev</name>
      <desc>Installieren des Gerätetreibers für das USB3-Vision-Interface</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>usb3vision_parameters.hdev</name>
      <desc>Verwenden des USB3-Vision-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>usb3vision_simple.hdev</name>
      <desc>Verwenden des USB3-Vision-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>11.0.3</newinversion>
   </example>
   <example>
      <name>var_threshold.hdev</name>
      <desc>Segmentieren eines Bildes mit einem lokalen Schwellwert, der aus dem lokalen Mittel und der Standardabweichung berechnet wird</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.feat</method>
      <method>method.segm</method>
      <operator>close_framegrabber</operator>
      <operator>connection</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>var_threshold</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>variation_model_illumination.hdev</name>
      <desc>Überprüfen des Druckbildes mit einem Variationsmodell mit variabler Beleuchtung</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.match.shape</method>
      <method>method.varmodel</method>
      <method>method.trafo.align</method>
      <operator>affine_trans_image</operator>
      <operator>affine_trans_region</operator>
      <operator>area_center</operator>
      <operator>binary_threshold</operator>
      <operator>clear_shape_model</operator>
      <operator>clear_variation_model</operator>
      <operator>closing_circle</operator>
      <operator>compare_ext_variation_model</operator>
      <operator>create_scaled_shape_model</operator>
      <operator>create_variation_model</operator>
      <operator>elliptic_axis</operator>
      <operator>find_scaled_shape_model</operator>
      <operator>gen_circle</operator>
      <operator>gen_ellipse</operator>
      <operator>gen_rectangle1</operator>
      <operator>get_shape_model_contours</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>intensity</operator>
      <operator>intersection</operator>
      <operator>opening_circle</operator>
      <operator>prepare_direct_variation_model</operator>
      <operator>scale_image</operator>
      <operator>smallest_circle</operator>
      <operator>smallest_rectangle1</operator>
      <operator>sobel_amp</operator>
      <operator>union1</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>variation_model_single.hdev</name>
      <desc>Überprüfen des Druckbildes mit einem Variationsmodell mit einem einzelnen Referenzbild</desc>
      <path>solution_guide/basics/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.match.shape</method>
      <method>method.varmodel</method>
      <method>method.filter.general</method>
      <method>method.trafo.align</method>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_image</operator>
      <operator>area_center</operator>
      <operator>binomial_filter</operator>
      <operator>clear_shape_model</operator>
      <operator>clear_variation_model</operator>
      <operator>compare_ext_variation_model</operator>
      <operator>connection</operator>
      <operator>create_shape_model</operator>
      <operator>create_variation_model</operator>
      <operator>difference</operator>
      <operator>dilation_circle</operator>
      <operator>edges_sub_pix</operator>
      <operator>fill_up</operator>
      <operator>find_shape_model</operator>
      <operator>gen_image_const</operator>
      <operator>gen_region_polygon</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>paint_region</operator>
      <operator>prepare_direct_variation_model</operator>
      <operator>shape_trans</operator>
      <operator>threshold</operator>
      <operator>vector_angle_to_rigid</operator>
      <operator>zoom_image_size</operator>
      <newinversion>8.0</newinversion>
   </example>
   <example>
      <name>vector_angle_to_rigid.hdev</name>
      <desc>Finden eines Musters und Anzeigen des normalisierten Bildes</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.io</method>
      <method>method.roi</method>
      <method>method.trafo.align</method>
      <method>method.trafo.rectif</method>
      <method>method.match.gray</method>
      <method>method.error</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>close_framegrabber</operator>
      <operator>copy_obj</operator>
      <operator>create_template_rot</operator>
      <operator>disp_image</operator>
      <operator>disp_region</operator>
      <operator>draw_rectangle2</operator>
      <operator>full_domain</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_mbutton</operator>
      <operator>get_mposition</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>info_framegrabber</operator>
      <operator>intensity</operator>
      <operator>open_framegrabber</operator>
      <operator>set_offset_template</operator>
      <operator>vector_angle_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>vector_to_aniso.hdev</name>
      <desc>Approximieren einer anisotropen Ähnlichkeitstransformation aus Punktkorrespondenzen</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>add_noise_white_contour_xld</operator>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_point_2d</operator>
      <operator>gen_contour_polygon_rounded_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_invert</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>hom_mat2d_translate_local</operator>
      <operator>vector_to_aniso</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>vector_to_fundamental_matrix_distortion.hdev</name>
      <desc>Demonstrieren von Ergebnissen aus unkalibriertem Stereo</desc>
      <path>hdevelop/3D-Reconstruction/Binocular-Stereo/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.3D</applarea>
      <method>method.stereo</method>
      <operator>cam_par_pose_to_hom_mat3d</operator>
      <operator>convert_point_3d_cart_to_spher</operator>
      <operator>convert_point_3d_spher_to_cart</operator>
      <operator>copy_rectangle</operator>
      <operator>create_cam_pose_look_at_point</operator>
      <operator>create_pose</operator>
      <operator>hom_mat3d_invert</operator>
      <operator>project_3d_point</operator>
      <operator>project_point_hom_mat3d</operator>
      <operator>projective_trans_point_3d</operator>
      <operator>vector_to_fundamental_matrix_distortion</operator>
      <operator>vector_to_hom_mat3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>vector_to_hom_mat3d.hdev</name>
      <desc>Approximieren verschiedener affiner 3D-Transformationen aus Punktkorrespondenzen</desc>
      <path>hdevelop/Transformations/3D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>affine_trans_object_model_3d</operator>
      <operator>clear_object_model_3d</operator>
      <operator>get_object_model_3d_params</operator>
      <operator>hom_mat3d_identity</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_scale_local</operator>
      <operator>hom_mat3d_translate_local</operator>
      <operator>read_object_model_3d</operator>
      <operator>vector_to_hom_mat3d</operator>
      <newinversion>11.0</newinversion>
   </example>
   <example>
      <name>vector_to_proj_hom_mat2d.hdev</name>
      <desc>Rektifizieren des Bildes eines Stadions zum Simulieren einer Ansicht von oben</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.color</method>
      <method>method.segm</method>
      <method>method.roi</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.geom</method>
      <method>method.visual</method>
      <operator>boundary</operator>
      <operator>decompose3</operator>
      <operator>dev_set_window_extents</operator>
      <operator>dilation_rectangle1</operator>
      <operator>edges_color_sub_pix</operator>
      <operator>fit_line_contour_xld</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>projective_trans_contour_xld</operator>
      <operator>projective_trans_image_size</operator>
      <operator>regress_contours_xld</operator>
      <operator>segment_contours_xld</operator>
      <operator>select_contours_xld</operator>
      <operator>select_shape_std</operator>
      <operator>select_shape_xld</operator>
      <operator>shape_trans</operator>
      <operator>trans_from_rgb</operator>
      <operator>union_collinear_contours_xld</operator>
      <operator>vector_to_proj_hom_mat2d</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>vector_to_rigid.hdev</name>
      <desc>Approximieren einer starren Transformation aus Punktkorrespondenzen</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>add_noise_white_contour_xld</operator>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_point_2d</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>hom_mat2d_translate_local</operator>
      <operator>vector_to_rigid</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>vector_to_similarity.hdev</name>
      <desc>Approximieren einer Ähnlichkeitstransformation aus Punktkorrespondenzen</desc>
      <path>hdevelop/Transformations/2D-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.numeric</method>
      <method>method.visual</method>
      <operator>add_noise_white_contour_xld</operator>
      <operator>affine_trans_contour_xld</operator>
      <operator>affine_trans_point_2d</operator>
      <operator>gen_contour_polygon_xld</operator>
      <operator>gen_ellipse_contour_xld</operator>
      <operator>get_contour_xld</operator>
      <operator>hom_mat2d_identity</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>hom_mat2d_scale</operator>
      <operator>hom_mat2d_translate</operator>
      <operator>hom_mat2d_translate_local</operator>
      <operator>vector_to_similarity</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>vector_variables.hdev</name>
      <desc>Verwenden von Vektorvariablen</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <method>method.general</method>
      <operator>convert_vector_to_tuple</operator>
      <operator>convert_tuple_to_vector_1d</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>vessel.hdev</name>
      <desc>Extrahieren und Vermessen eines Blutgefäßes</desc>
      <path>hdevelop/Applications/Measuring-2D/</path>
      <industry>industry.health</industry>
      <applarea>applarea.measure.2D</applarea>
      <method>method.texture</method>
      <method>method.visual</method>
      <method>method.filter.general</method>
      <method>method.blob</method>
      <method>method.functions</method>
      <method>method.numeric</method>
      <operator>binary_threshold</operator>
      <operator>clip_region</operator>
      <operator>dev_display</operator>
      <operator>gen_region_line</operator>
      <operator>gen_region_points</operator>
      <operator>get_region_contour</operator>
      <operator>get_region_points</operator>
      <operator>intersection</operator>
      <operator>mean_image</operator>
      <operator>smallest_rectangle1</operator>
      <operator>texture_laws</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>video4linux2.hdev</name>
      <desc>Verwenden des Video4Linux2-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>video4linux2_2cameras.hdev</name>
      <desc>Verwenden des Video4Linux2-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>video4linux2_parameters.hdev</name>
      <desc>Verwenden des Video4Linux2-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>video4linux2_simple.hdev</name>
      <desc>Verwenden des Video4Linux2-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>10.0.1</newinversion>
   </example>
   <example>
      <name>visualize_3d_feature_space.hdev</name>
      <desc>Interaktives Visualisieren eines 3D-Merkmalsraums</desc>
      <path>solution_guide/classification/</path>
      <industry>industry.general</industry>
      <applarea>applarea.inspect.texture</applarea>
      <applarea>applarea.general</applarea>
      <method>method.texture</method>
      <method>method.visual</method>
      <method>method.trafo.geom</method>
      <operator>affine_trans_point_3d</operator>
      <operator>compose6</operator>
      <operator>principal_comp</operator>
      <operator>project_3d_point</operator>
      <operator>texture_laws</operator>
      <newinversion>9.0</newinversion>
   </example>
   <example>
      <name>volatile_grabbing.hdev</name>
      <desc>Demonstrieren der Auswirkung des 'volatile grabbings'</desc>
      <path>solution_guide/image_acquisition/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>grab_image</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>10.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (Evaluierung der Performance)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>access_channel</operator>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>grab_image_async</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam_2cameras.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (zwei Kameras)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>grab_image_start</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam_crop.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (Bildausschnitt)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <operator>wait_seconds</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam_parameters.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (Abfragen von Parametereinstellungen)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>get_framegrabber_param</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>tuple_sort</operator>
      <operator>tuple_uniq</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam_simple.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (einfach)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>vrmusbcam_trigger.hdev</name>
      <desc>Verwenden des VRmUsbCam-Interfaces (externer Trigger)</desc>
      <path>hdevelop/Image/Acquisition/</path>
      <method>method.acqu</method>
      <operator>close_framegrabber</operator>
      <operator>get_framegrabber_param</operator>
      <operator>grab_image_async</operator>
      <operator>info_framegrabber</operator>
      <operator>open_framegrabber</operator>
      <operator>set_framegrabber_param</operator>
      <newinversion>8.0.2</newinversion>
   </example>
   <example>
      <name>watersheds.hdev</name>
      <desc>Extrahieren von Wasserscheiden und 'dunklen Becken' aus einem Bild</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>invert_image</operator>
      <operator>watersheds</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>watersheds_threshold.hdev</name>
      <desc>Extrahieren der 'dunklen Becken' zwischen Wasserscheiden mit einem Schwellwert</desc>
      <path>hdevelop/Segmentation/Topography/</path>
      <industry>industry.general</industry>
      <industry>industry.health</industry>
      <industry>industry.pharm</industry>
      <industry>industry.print</industry>
      <applarea>applarea.general</applarea>
      <method>method.segm</method>
      <operator>class_2dim_sup</operator>
      <operator>convert_image_type</operator>
      <operator>decompose3</operator>
      <operator>dev_set_lut</operator>
      <operator>distance_transform</operator>
      <operator>gauss_filter</operator>
      <operator>histo_2dim</operator>
      <operator>intersection</operator>
      <operator>invert_image</operator>
      <operator>mean_image</operator>
      <operator>scale_image_max</operator>
      <operator>trans_from_rgb</operator>
      <operator>watersheds</operator>
      <operator>watersheds_threshold</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>while.hdev</name>
      <desc>Verwenden einer while-Schleife zur Unterstützung von Interaktion bis zum nächsten rechten Mausklick</desc>
      <path>hdevelop/Control/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.controlstruct</method>
      <operator>endwhile</operator>
      <operator>while</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>world_coordinates_line_scan.hdev</name>
      <desc>Messen der Abstände zwischen den Teilstrichen einer Schieblehre in einem Zeilenkamerabild mit Kamerakalibrierung</desc>
      <path>hdevelop/Applications/Measuring-3D/</path>
      <industry>industry.general</industry>
      <applarea>applarea.measure.2D</applarea>
      <applarea>applarea.measure.3D</applarea>
      <method>method.calib</method>
      <method>method.io</method>
      <method>method.edgeextr</method>
      <method>method.xld</method>
      <method>method.tuple</method>
      <method>method.metrol</method>
      <method>method.roi</method>
      <method>method.trafo.rectif</method>
      <method>method.trafo.wcoord</method>
      <method>method.visual</method>
      <operator>affine_trans_point_3d</operator>
      <operator>close_measure</operator>
      <operator>contour_to_world_plane_xld</operator>
      <operator>disp_arrow</operator>
      <operator>distance_pp</operator>
      <operator>draw_rectangle2</operator>
      <operator>edges_sub_pix</operator>
      <operator>fit_circle_contour_xld</operator>
      <operator>fit_ellipse_contour_xld</operator>
      <operator>full_domain</operator>
      <operator>gen_contour_region_xld</operator>
      <operator>gen_cross_contour_xld</operator>
      <operator>gen_image_to_world_plane_map</operator>
      <operator>gen_measure_rectangle2</operator>
      <operator>gen_rectangle2</operator>
      <operator>get_domain</operator>
      <operator>hom_mat3d_rotate_local</operator>
      <operator>hom_mat3d_to_pose</operator>
      <operator>hom_mat3d_translate_local</operator>
      <operator>image_points_to_world_plane</operator>
      <operator>image_to_world_plane</operator>
      <operator>map_image</operator>
      <operator>measure_pairs</operator>
      <operator>pose_to_hom_mat3d</operator>
      <operator>project_3d_point</operator>
      <operator>reduce_domain</operator>
      <operator>select_shape_xld</operator>
      <operator>set_origin_pose</operator>
      <operator>sim_caltab</operator>
      <operator>smallest_rectangle1_xld</operator>
      <operator>tuple_sort_index</operator>
      <newinversion>7.1</newinversion>
   </example>
   <example>
      <name>write_image.hdev</name>
      <desc>Schreiben eines Bildes in eine Datei</desc>
      <path>hdevelop/File/Images/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>sobel_amp</operator>
      <operator>write_image</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>write_image_benchmark.hdev</name>
      <desc>Vergleichen der Schreibgeschwindigkeit von unterschiedlichen Bild-Datei-Formaten</desc>
      <path>hdevelop/File/Images/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>delete_file</operator>
      <operator>get_current_dir</operator>
      <operator>set_current_dir</operator>
      <operator>write_image</operator>
      <operator>write_object</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>write_object.hdev</name>
      <desc>Schreiben und Wiedereinlesen von ikonischen Objekten in eine Datei</desc>
      <path>hdevelop/File/Misc/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <operator>read_image</operator>
      <operator>read_object</operator>
      <operator>read_region</operator>
      <operator>write_image</operator>
      <operator>write_object</operator>
      <operator>write_region</operator>
      <newinversion>12.0</newinversion>
   </example>
   <example>
      <name>write_ocv.hdev</name>
      <desc>Schreiben von OCV Daten in eine Datei (und Lesen aus der Datei)</desc>
      <path>hdevelop/Inspection/OCV/</path>
      <industry>industry.print</industry>
      <applarea>applarea.inspect.print</applarea>
      <method>method.ocv</method>
      <operator>close_ocv</operator>
      <operator>create_ocv_proj</operator>
      <operator>read_ocv</operator>
      <operator>shape_trans</operator>
      <operator>traind_ocv_proj</operator>
      <operator>write_ocv</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>write_region.hdev</name>
      <desc>Schreiben von Regionendaten in eine Datei</desc>
      <path>hdevelop/File/Region/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.file</method>
      <method>method.regionproc</method>
      <operator>write_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>write_string.hdev</name>
      <desc>Schreiben von Text in eine Datei</desc>
      <path>hdevelop/Graphics/Text/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.visual</method>
      <method>method.io</method>
      <operator>new_line</operator>
      <operator>set_tposition</operator>
      <operator>write_string</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>write_template.hdev</name>
      <desc>Lesen und Schreiben von Grauwerttemplatedateien</desc>
      <path>hdevelop/Matching/Gray-Value-Based/</path>
      <industry>industry.general</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <method>method.match.gray</method>
      <method>method.trafo.geom</method>
      <method>method.file</method>
      <operator>affine_trans_image</operator>
      <operator>best_match_rot_mg</operator>
      <operator>clear_template</operator>
      <operator>create_template_rot</operator>
      <operator>disp_arrow</operator>
      <operator>fill_interlace</operator>
      <operator>hom_mat2d_rotate</operator>
      <operator>read_template</operator>
      <operator>write_template</operator>
      <newinversion>6.1</newinversion>
   </example>
   <example>
      <name>xing.hdev</name>
      <desc>Überwachen von Verkehr mit einem Hintergrundschätzer und Nachbearbeitung</desc>
      <path>hdevelop/Applications/Security-Systems/</path>
      <industry>industry.transp</industry>
      <industry>industry.secure</industry>
      <applarea>applarea.recog.object2d</applarea>
      <applarea>applarea.security</applarea>
      <method>method.visual</method>
      <method>method.blob</method>
      <method>method.morphol</method>
      <method>method.motion</method>
      <operator>clip_region</operator>
      <operator>close_bg_esti</operator>
      <operator>complement</operator>
      <operator>create_bg_esti</operator>
      <operator>dilation_rectangle1</operator>
      <operator>give_bg_esti</operator>
      <operator>read_region</operator>
      <operator>run_bg_esti</operator>
      <operator>select_gray</operator>
      <operator>shape_trans</operator>
      <operator>update_bg_esti</operator>
      <operator>zoom_image_factor</operator>
      <operator>zoom_region</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>xing_simple.hdev</name>
      <desc>Überwachen von Verkehr mit einem Hintergrundschätzer</desc>
      <path>hdevelop/Applications/Security-Systems/</path>
      <industry>industry.transp</industry>
      <industry>industry.secure</industry>
      <applarea>applarea.recog.pos2d</applarea>
      <applarea>applarea.security</applarea>
      <method>method.visual</method>
      <method>method.blob</method>
      <method>method.motion</method>
      <operator>close_bg_esti</operator>
      <operator>connection</operator>
      <operator>create_bg_esti</operator>
      <operator>give_bg_esti</operator>
      <operator>intersection</operator>
      <operator>read_region</operator>
      <operator>run_bg_esti</operator>
      <operator>shape_trans</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>xld_recv.hdev</name>
      <desc>Empfangen einer XLD Kontur über eine Socketverbindung</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>gen_parallels_xld</operator>
      <operator>get_next_socket_data_type</operator>
      <operator>open_socket_accept</operator>
      <operator>receive_image</operator>
      <operator>receive_xld</operator>
      <operator>send_xld</operator>
      <operator>socket_accept_connect</operator>
      <operator>split_contours_xld</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>xld_send.hdev</name>
      <desc>Senden einer XLD Kontur über eine Socketverbindung</desc>
      <path>hdevelop/System/Sockets/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.comm</method>
      <operator>close_socket</operator>
      <operator>gen_polygons_xld</operator>
      <operator>mod_parallels_xld</operator>
      <operator>open_socket_connect</operator>
      <operator>receive_xld</operator>
      <operator>send_image</operator>
      <operator>send_xld</operator>
      <operator>split_contours_xld</operator>
      <newinversion>5.2.3</newinversion>
   </example>
   <example>
      <name>zero_crossing.hdev</name>
      <desc>Extrahieren von Nulldurchgängen in einem Bild</desc>
      <path>hdevelop/Segmentation/Threshold/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.filter.general</method>
      <method>method.segm</method>
      <operator>diff_of_gauss</operator>
      <operator>zero_crossing</operator>
      <newinversion>7.0</newinversion>
   </example>
   <example>
      <name>zoom_region.hdev</name>
      <desc>Skalieren von Regionen</desc>
      <path>hdevelop/Regions/Geometric-Transformations/</path>
      <industry>industry.general</industry>
      <applarea>applarea.general</applarea>
      <method>method.trafo.geom</method>
      <method>method.regionproc</method>
      <method>method.io</method>
      <operator>draw_region</operator>
      <operator>zoom_region</operator>
      <newinversion>7.0</newinversion>
   </example>
</examples>