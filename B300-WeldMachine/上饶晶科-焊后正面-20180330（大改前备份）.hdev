<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>close_all_framegrabbers ()</l>
<l>ImagePath:='F:/A01 三厂五车间A区/2018年04月16日 夜班/焊后正面识别'</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="1">list_files (ImagePath+'/OK', ['files','follow_links'], ImageFiles)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,3]" as_ord="1">tuple_regexp_select (ImageFiles, ['\\.(bmp|jpg)$','ignore_case'], ImageFiles)</l>
<c></c>
<l>read_image (Image, ImagePath+'/PP')</l>
<c></c>
<l>* dev_set_color ('red')</l>
<l>get_image_size (Image, Width, Height)</l>
<c>*新建窗口</c>
<l>dev_open_window (0, 0, Width*0.5, Height*0.5, 'black', WindowID)</l>
<l>dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<c>*设置字体大小</c>
<l>set_display_font (WindowID, 24, 'mono', 'true', 'false')</l>
<c></c>
<l>dev_display (Image)</l>
<c>*设置区域显示模式（轮廓）</c>
<l>dev_set_draw ('margin')</l>
<c>*建立模板之前先做图像角度矫正</c>
<l>* rotate_image (Image, Image_Rotate_X, rad(-65), 'constant')</l>
<l>Star_AffineTransImage (Image, ImageGauss1_AffinTrans, Height, Width)</l>
<c></c>
<l>dev_display (ImageGauss1_AffinTrans)</l>
<c>*模板位置 06</c>
<l>* draw_rectangle2 (WindowID, Row3, Column3, Phi, Length1, Length2)</l>
<l>gen_rectangle2 (Rectangle, 605, 1310, 0, 495, 382)</l>
<l>reduce_domain (ImageGauss1_AffinTrans, Rectangle, ImageReduced)</l>
<l>crop_domain (ImageReduced, ImagePart)</l>
<l>zoom_image_factor (ImagePart, ImageZoomed, 0.5, 0.5, 'constant')</l>
<c>*建立模板</c>
<l>pi := acos(0.0) * 2</l>
<l>create_template_rot (ImageZoomed, 4, -pi, 2 * pi, pi / 45, 'sort', 'original', TemplateID)  </l>
<c>*NG数量统计</c>
<l>error:=0</l>
<l>for Index :=3 to |ImageFiles| - 1 by 1   </l>
<l>    read_image (Image, ImageFiles[Index])</l>
<l>    rgb1_to_gray (Image, Image)</l>
<l>    parse_filename(ImageFiles[Index],afileBaseName,afileExt,afileDir) </l>
<c>    * Image Acquisition 01: Do something</c>
<l>    dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<l>    dev_set_color ('red')</l>
<c>        *创建一个通过时间的变量开始</c>
<l>    count_seconds (S1)</l>
<c>    </c>
<c>    </c>
<l>    get_image_size (Image, Width, Height)</l>
<l>    Star_AffineTransImage (Image, Image_AffinTrans, Height, Width)</l>
<l>    zoom_image_factor (Image_AffinTrans, ImageZoomed1, 0.5, 0.5, 'constant')</l>
<c>    *匹配位置</c>
<l>    best_match_rot_mg (ImageZoomed1, TemplateID, -pi, 2 * pi, 40, 'true', 4, Row, Column, Angle, Error)</l>
<l>*     best_match_mg (ImageZoomed1, TemplateID, 30, 'false', 4, 2, Row, Column, Error)</l>
<l>    dev_display (Image_AffinTrans)</l>
<l>    disp_arrow (WindowID, Row*2, Column*2, Row*2 - cos(Angle) * 50, Column*2 - sin(Angle) * 50, 15)</l>
<c>    *</c>
<l>    if (Error&lt;35)</l>
<c>                </c>
<l>        dev_display (Image_AffinTrans)</l>
<l>        row_2:=Row*2</l>
<l>        column_2:=Column*2</l>
<l>        str_Welding_recognition (Image, Image_AffinTrans, out_EO_error_region, Img, row_2, column_2, WindowID, out_temp_error)</l>
<l>*         stop ()</l>
<l>        dev_display (Image_AffinTrans)</l>
<l>        dev_display (out_EO_error_region)</l>
<l>*         stop ()      </l>
<l>        if (out_temp_error&gt;0)</l>
<l>            error:=error+1</l>
<c>            *创建一个通过时间的变量结束。</c>
<l>            count_seconds (S2)</l>
<l>            Time := 1000.0*(S2-S1)</l>
<l>            disp_message (WindowID, Time+' ms', 'window', 25, 5, 'red', 'false')</l>
<l>        else</l>
<c>            *创建一个通过时间的变量结束。</c>
<l>            count_seconds (S2)</l>
<l>            Time := 1000.0*(S2-S1)</l>
<l>            disp_message (WindowID, Time+' ms', 'window', 25, 5, 'green', 'false')</l>
<l>        endif</l>
<l>    endif</l>
<l>    dev_display (Img)</l>
<l>        write_image (Img, 'bmp', 0, ImagePath+'/ResultOK/'+Index+'序号'+afileBaseName)   </l>
<l>        stop ()</l>
<l>endfor</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="str_Welding_recognition">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Image_AffinTrans" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="out_EO_error_region" base_type="iconic" dimension="0"/>
<par name="Img" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row_2" base_type="ctrl" dimension="0"/>
<par name="column_2" base_type="ctrl" dimension="0"/>
<par name="WindowID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="out_temp_error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*==========================================================*</c>
<c>*====++++++++++++++++++++++++++++++++++++++++++++++++++====*</c>
<c>*==========================================================*</c>
<c>*NG区域记录</c>
<l>gen_empty_obj (out_EO_error_region)</l>
<l>* dev_display (Image_AffinTrans)</l>
<c>*1：翘起的数量</c>
<c>*最大允许长度</c>
<l>h_ERROR_Number:=0</l>
<c>* 数量</c>
<l>h_erNumber:=0</l>
<l>gen_empty_obj(EmptyObject_her)</l>
<c>*2：穿孔附近链接的严重翘起</c>
<l>h_erNumberX:=0</l>
<l>gen_empty_obj(EmptyObject_herX)</l>
<c></c>
<c>*3：无包裹为NG</c>
<l>dw_erNumber:=0</l>
<l>gen_empty_obj(Rectangle1)</l>
<c></c>
<c>*4：包裹不完整，上、左右、却2边</c>
<l>LR_erNumberX:=0</l>
<l>gen_empty_obj(LR_SRegionsX)</l>
<c></c>
<c>*5：判断焊锡包裹密度</c>
<l>area_erNumber:=0</l>
<l>gen_empty_obj(area_erSRegions)</l>
<c>*</c>
<l>out_temp_error := 0</l>
<c>*起始位置R</c>
<l>Q_row:=570</l>
<c>*起始位置W</c>
<l>Q_column:=-540</l>
<c>*每个焊接位置的间距</c>
<l>Q_HJ_spacing:=360</l>
<c>*每次偏移位置累加</c>
<l>Q_PY_temp_spacing:=Q_column+0</l>
<l>dev_display (Image_AffinTrans)</l>
<l>for Index2 := 0 to 3 by 1</l>
<c>    *</c>
<l>    gen_rectangle2 (Rectangle1, row_2+(Q_row), column_2+(Q_PY_temp_spacing), \
                    0, 88, 70)    </l>
<c>    *测试位置   </c>
<l>    reduce_domain (Image_AffinTrans, Rectangle1, ImageReduced1)</l>
<c>    *</c>
<l>    smallest_rectangle1 (Rectangle1, Row1, Column1, Row2, Column2)</l>
<l>    h_row:=Row2-Row1</l>
<l>    cr_w:=Column2-Column1</l>
<l>*     stop ()</l>
<l>    gen_rectangle1 (Rectangle7_t, Row1, Column1+(cr_w*0.03), Row2+Row2*0.01, Column2-(cr_w*0.03))</l>
<l>    reduce_domain (Image_AffinTrans, Rectangle7_t, ImageReduced_t)</l>
<c>    *==========================================================*</c>
<c>    *====++++++++++++++++++++++++++++++++++++++++++++++++++====*</c>
<c>    *==========================================================*</c>
<c>    * 1.汇流条左右边界翘起的数量</c>
<l>    mean_image (ImageReduced_t, ImageMean, 1, 30)</l>
<l>    mean_image (ImageMean, ImageMean1, 13, 1)</l>
<c>    ******xxxxxxx******20180116上</c>
<c>    * 最大单个边界A01</c>
<l>    Z2_L_height_max:=70</l>
<c>    * 出现2条边界的允许长度A02</c>
<l>    Z2_L_height_min_:=40</l>
<c>    * 汇流条边界识别阈值A03</c>
<l>    Z2_L_dyn_threshold_:=12</l>
<c>    ******xxxxxxx******20180116下</c>
<l>    dyn_threshold (ImageMean, ImageMean1, RegionDynThresh, Z2_L_dyn_threshold_, 'dark')</l>
<l>    dilation_rectangle1 (RegionDynThresh, RegionDilation, 1, 15)</l>
<l>    closing_circle (RegionDilation, RegionClosing1, 2.5)</l>
<l>    erosion_rectangle1 (RegionClosing1, RegionErosion, 1, 15)//15改8 20180330</l>
<c>    *</c>
<c>    *超过设定长度，汇流条有翘起</c>
<l>    connection (RegionErosion, ConnectedRegions)</l>
<c>    *最大允许长度</c>
<l>    select_shape (ConnectedRegions, h_ER_sRegions, 'height', 'and', h_row*(Z2_L_height_max*0.01), 99999)</l>
<c>    *判断2条特征线的距离宽度</c>
<l>    count_obj (h_ER_sRegions, h_ERROR_Number)     </l>
<l>    select_shape (ConnectedRegions, h_sRegions, 'height', 'and', h_row*(Z2_L_height_min_*0.01), 99999)</l>
<c>    *判断2条特征线的距离宽度</c>
<l>    count_obj (h_sRegions, tempNumber)</l>
<l>*     stop ()</l>
<c>    *==========================================================*</c>
<c>    *====++++++++++++++++++++++++++++++++++++++++++++++++++====*</c>
<c>    *==========================================================*</c>
<c>    * 2. 漏焊等情况下对汇流条宽度进行判断</c>
<c>    *汇流条宽度</c>
<l>    Electrode_L:=cr_w*0.363</l>
<c>    *判断2个区域的间距</c>
<l>    LherX:=cr_w*0.5</l>
<c>    *缺陷区域</c>
<l>    if (tempNumber&gt;1)</l>
<c>        </c>
<l>        smallest_rectangle1 (h_sRegions, Row1_temp, Column1_temp, Row2_temp, Column2_temp)</l>
<l>        temp_L:=Row2_temp-Row1_temp</l>
<c>        *删选最长的2个</c>
<c>        * 够叼：提取高度最高的和次高的特征</c>
<l>        gen_empty_obj (EmptyObject_l)</l>
<l>        for Index_temp := 1 to 2 by 1</l>
<l>            try</l>
<l>                tuple_max (temp_L, TEMP_Lmax)</l>
<c>                *获取最大值的位置</c>
<l>                tuple_find (temp_L, TEMP_Lmax, Indices)</l>
<c>                *删除索引位置的值</c>
<l>                tuple_remove (temp_L, Indices, temp_L)</l>
<c>                *</c>
<l>                select_shape (h_sRegions, SelectedRegions, 'height', 'and', TEMP_Lmax, 9999)</l>
<l>                union2 (EmptyObject_l, SelectedRegions, EmptyObject_l)</l>
<l>            catch (Exception)</l>
<c>                * 2个一样长时可能报错，不用处理</c>
<l>            endtry </l>
<l>        endfor</l>
<l>        union1 (EmptyObject_l, RegionUnion1)</l>
<l>        closing_rectangle1 (RegionUnion1, RegionClosing_er, cr_w*0.5, 1)</l>
<c>        *获取中间部分区域计算</c>
<l>        smallest_rectangle1 (RegionClosing_er, Row18, Column18, Row28, Column28)</l>
<l>        smallest_rectangle2 (RegionClosing_er, Row7, Column7, Phi, Length1, Length2)</l>
<l>        gen_rectangle2 (Rectangle3, Row7, Column7, rad(90), 0.1, (Column28-Column18)/2)</l>
<l>        smallest_rectangle2 (Rectangle3, Row8, Column8, Phi1, Length11, Length21)</l>
<l>        w_lenght:=Length11*2</l>
<l>        if (w_lenght&gt;Electrode_L and w_lenght&lt;LherX)</l>
<l>            h_erNumber:=2</l>
<l>            copy_obj (RegionClosing_er, EmptyObject_her, 1, 1)</l>
<l>        else</l>
<l>            h_erNumber:=1</l>
<l>        endif</l>
<l>    else</l>
<l>        h_erNumber:=tempNumber    </l>
<l>    endif</l>
<c>    *==========================================================*</c>
<c>    *====++++++++++++++++++++++++++++++++++++++++++++++++++====*</c>
<c>    *==========================================================*</c>
<c>    * 3.U型穿孔处和汇流条边界有交集的情况 </c>
<c>    *链接穿孔处有超过设定长度，认为是较严重汇流条翘起</c>
<l>    smallest_rectangle1 (Rectangle1, Row11, Column11, Row21, Column21)</l>
<l>    gen_rectangle1 (Rectangle2, Row21-20, Column11, Row21, Column21)</l>
<l>    dilation_rectangle1 (RegionErosion, RegionDilation1, 1, 11)</l>
<c>    *</c>
<l>    union2 (RegionDilation1, Rectangle2, RegionUnion)</l>
<l>    connection (RegionUnion, ConnectedRegions3)</l>
<l>    area_center (ConnectedRegions3, Area2, Row5, Column5)</l>
<l>    tuple_max (Area2, Max2)</l>
<l>    select_shape (ConnectedRegions3, SelectedRegions2, 'area', 'and', Max2, 99999999)</l>
<c>    *获取穿孔处特征</c>
<l>    intersection (SelectedRegions2, RegionClosing1, RegionDifference2)</l>
<l>    connection (RegionDifference2, ConnectedRegions4)</l>
<c>    ******xxxxxxx******20180127上</c>
<c>    * 链接穿孔位置的边界长度B01</c>
<l>    Z2_L_perforation_length:=35</l>
<c>    ******xxxxxxx******20180127下    </c>
<l>    select_shape (ConnectedRegions4, EmptyObject_her2, 'height', 'and', h_row*(Z2_L_perforation_length*0.01), 99999999)</l>
<l>    count_obj (EmptyObject_her2, h_erNumber2)</l>
<c>    *==========================================================*</c>
<c>    *====++++++++++++++++++++++++++++++++++++++++++++++++++====*</c>
<c>    *==========================================================*</c>
<c>    * 4.判断汇流条2个区域的宽度 </c>
<l>*     stop ()</l>
<c>    *判断2个区域的宽度</c>
<l>    union1 (EmptyObject_her2, RegionUnion13)</l>
<l>    smallest_rectangle1 (RegionUnion13, Row14, Column14, Row24, Column24)</l>
<l>    w_column:=Column24-Column14</l>
<c>    *有短的情况下，要有长的才可以判定为NG EmptyObject_herX</c>
<l>    h_erNumberX:=0</l>
<c>    *参数1：2个区域</c>
<c>    *参数2：大于汇流条设定宽度</c>
<c>    *参数3：接近汇流条设定宽度</c>
<l>    if (h_erNumber2&gt;1 and w_column&gt;Electrode_L and w_column&lt;LherX)</l>
<l>        smallest_rectangle1 (EmptyObject_her2, Row16, Column16, Row26, Column26)</l>
<l>        temo_h:=Row26-Row16</l>
<l>        tuple_min (temo_h, h_Min)</l>
<c>        * 判断最长的长度</c>
<l>        hmin_row:=h_Min*1.35</l>
<l>        select_shape (EmptyObject_her2, herX_region, 'height', 'and', hmin_row, 99999999)</l>
<l>        count_obj (herX_region, temper_herX)</l>
<l>        if (temper_herX&gt;0)</l>
<l>            union1 (EmptyObject_her2, RegionUnion12)</l>
<l>            copy_obj (RegionUnion12, EmptyObject_herX, 1, 1)</l>
<l>            h_erNumberX:=1</l>
<l>        endif</l>
<l>    else</l>
<l>        h_erNumberX:=0</l>
<l>    endif</l>
<c>    </c>
<l>*     stop ()</l>
<c>    </c>
<l>    h_ERROR_Number2:=0</l>
<l>    gen_empty_obj (h_ERROR_SRegions2)</l>
<l>    if (h_ERROR_Number&gt;0 or h_erNumber&gt;0 or h_erNumber2&gt;0)</l>
<c>        </c>
<c>        *计算90°∟直角特征</c>
<l>        union2 (h_ER_sRegions, EmptyObject_her2, RegionUnion4)</l>
<l>        union2 (h_sRegions, RegionUnion4, RegionUnion6)</l>
<l>        union1 (RegionUnion6, RegionUnion7)</l>
<l>        smallest_rectangle1 (RegionUnion7, Row13, Column13, Row23, Column23)</l>
<l>        gen_rectangle2 (Rectangle8, Row13, Column13, 0, 500, 23)</l>
<l>        intersection (Rectangle8, Rectangle1, RegionDifference4)</l>
<l>        erosion_rectangle1 (RegionDifference4, RegionErosion3, 29, 1)</l>
<l>        reduce_domain (Image_AffinTrans, RegionErosion3, ImageReduced)</l>
<l>        mean_image (ImageReduced, ImageMean5, 30, 1)</l>
<l>        mean_image (ImageMean5, ImageMean6, 1, 13)</l>
<c>        ******xxxxxxx******20180127上</c>
<c>        * 链接穿孔位置的边界长度B04</c>
<l>        Z2_L_AfewLines_dyn_threshold_:=12</l>
<c>        ******xxxxxxx******20180127下</c>
<l>        dyn_threshold (ImageMean5, ImageMean6, RegionDynThresh2, Z2_L_AfewLines_dyn_threshold_, 'dark')</l>
<l>        closing_circle (RegionDynThresh2, RegionClosing4, 1.5)</l>
<l>        connection (RegionClosing4, ConnectedRegions8)</l>
<c>        *判断90°∟直角特征的位置，</c>
<c>        *如果靠下面则判断长度超过40%（默认）</c>
<c>        ******xxxxxxx******20180127上</c>
<c>        * 链接穿孔位置的边界长度B05</c>
<l>        Z2_L_AfewLines_height_:=60</l>
<c>        ******xxxxxxx******20180127下</c>
<l>        gen_rectangle1 (Rectangle4, Row2-((Row2-Row1)*(Z2_L_AfewLines_height_*0.01)), Column1, Row2, Column2)</l>
<l>        smallest_rectangle1 (Rectangle4, Row17, Column17, Row27, Column27)</l>
<c>        ******xxxxxxx******20180127上</c>
<c>        * 行区域获取长度B02</c>
<l>        Z2_L_AfewLines_length_:=27</l>
<c>        ******xxxxxxx******20180127下</c>
<l>        ocrw:=cr_w*(Z2_L_AfewLines_length_*0.01)</l>
<l>        select_shape (ConnectedRegions8, SelectedRegions3, \
                      ['row','width'], 'and', [Row17,ocrw], [Row27,99999])</l>
<l>        dilation_rectangle1 (SelectedRegions3, RegionDilation2, 15, 1)</l>
<l>        dilation_rectangle1 (RegionUnion6, RegionDilation3, 1, 15)       </l>
<l>        union2 (RegionDilation2, RegionDilation3, RegionUnion5)</l>
<l>        closing_rectangle1 (RegionUnion5, RegionClosing7, 3, 1)</l>
<l>        connection (RegionClosing7, ConnectedRegions7)</l>
<c>        ******xxxxxxx******20180127上</c>
<c>        * 90°缺陷高度B03</c>
<l>        Z2_L_height_90_:=35</l>
<c>        ******xxxxxxx******20180127下</c>
<l>        hrow_e:=h_row*(Z2_L_height_90_*0.01)</l>
<l>        select_shape (ConnectedRegions7, h_ERROR_SRegions2, \
                      ['width','height'], 'and', [ocrw,hrow_e], [9999,9999])</l>
<l>        count_obj (h_ERROR_SRegions2, h_ERROR_Number2)</l>
<l>*         h_ERROR_Number2:=0      </l>
<l>    else</l>
<l>        h_ERROR_Number2:=0     </l>
<l>    endif   </l>
<c></c>
<c>    </c>
<c>    */////////////////////////////////</c>
<c>    */////////////////////////////////</c>
<c>    *CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</c>
<l>    mean_image (ImageReduced1, ImageMean2, 5, 5)</l>
<l>    invert_image (ImageMean2, ImageInvert)</l>
<l>    intensity (Rectangle1, ImageInvert, Mean, Deviation)</l>
<l>    m_threshold:=Mean-Deviation</l>
<l>    dyn_threshold (ImageMean2, ImageInvert, RegionDynThresh1, m_threshold, 'dark')</l>
<l>    closing_circle (RegionDynThresh1, RegionClosing, 3.5)</l>
<c>    *拟合下面的区域 Row11, Column11, Row21, Column21</c>
<l>    gen_rectangle1 (Rectangle7, Row11-7, Column11, Row21, Column21)</l>
<l>    intersection (Rectangle7, RegionClosing, RegionIntersection1)</l>
<l>    closing_rectangle1 (RegionIntersection1, RegionClosing3_w, cr_w*0.1, 1)</l>
<l>    union2 (RegionClosing, RegionClosing3_w, RegionUnion3_w)</l>
<c>    *</c>
<c>    *获取分析区域，面积10%</c>
<l>    area_center (Rectangle1, Area4, Row9, Column9)</l>
<l>    r1areaa:=Area4*0.06</l>
<c>    *检查包裹度</c>
<l>    connection (RegionUnion3_w, ConnectedRegions5)</l>
<l>    select_shape (ConnectedRegions5, dw_SRegions, \
                  ['area','height'], 'and', [r1areaa, 50], [999999999,9999])</l>
<l>    count_obj (dw_SRegions, dw_erNumber)</l>
<c>    </c>
<c>    ******xxxxxxx******20180328上</c>
<c>    *C</c>
<c>    * 小矩形框面积的百分数</c>
<l>    Z2_r1area:=0.23</l>
<c>    * 判断左右黑色区域数量</c>
<l>    Z2_r1_number:=1</l>
<c>    * 左右矩形的高度</c>
<l>    Z2_r1_hrow:=0.8</l>
<c>    * 左右矩形的宽度</c>
<l>    Z2_r1_crw:=0.225</l>
<c>    ******xxxxxxx******20180328下  </c>
<c>    *判断宽度包裹宽度</c>
<l>    if (dw_erNumber&gt;0)</l>
<l>*         dev_display (Image_AffinTrans)</l>
<l>        gen_rectangle1 (Rectangle_left, Row21-h_row * Z2_r1_hrow, Column11, Row21, Column11+cr_w*Z2_r1_crw)</l>
<l>        gen_rectangle1 (Rectangle_right, Row21-h_row * Z2_r1_hrow, Column21-cr_w*Z2_r1_crw, Row21, Column21)</l>
<l>        union2 (Rectangle_left, Rectangle_right, RegionUnion2)</l>
<l>*         stop ()</l>
<c>        *上区域</c>
<l>        intersection (RegionUnion2, dw_SRegions, RegionDifference3)</l>
<l>        closing_rectangle1 (RegionDifference3, RegionClosing3, 1, h_row*0.21)</l>
<l>        fill_up (RegionClosing3, RegionFillUp2)</l>
<l>        connection (RegionFillUp2, ConnectedRegions6)</l>
<c>        *左右单个方块的面积</c>
<l>        area_center (Rectangle_left, Area, Row3, Column3)</l>
<l>        LR_erArea:=Area*Z2_r1area</l>
<l>        select_shape (ConnectedRegions6, lr_SRegions2, \
                      ['area','height'], 'and', [LR_erArea, h_row*0.23], [999999999,9999])</l>
<l>        count_obj (lr_SRegions2, lr_erNumber2)</l>
<c>        *判断左右黑色区域数量</c>
<l>        LR_erNumberX:=0</l>
<l>        if (lr_erNumber2&lt;Z2_r1_number)</l>
<l>            LR_erNumberX:=1</l>
<l>            union2 (Rectangle1, lr_SRegions2, LR_SRegionsX)  </l>
<l>        endif</l>
<l>    endif</l>
<c>   </c>
<l>    gen_rectangle1 (Rectangle9, Row11, Column11, Row11+29, Column21)</l>
<c>    *检查焊锡包裹密度</c>
<l>    union2 (RegionClosing, Rectangle9, RegionUnion11)  </l>
<l>    fill_up (RegionUnion11, RegionFillUp1)</l>
<l>    difference (RegionFillUp1, Rectangle9, RegionDifference5)</l>
<c>    </c>
<l>    _w:=cr_w*0.3</l>
<l>    _h:=h_row*0.6</l>
<l>    erosion_rectangle1 (Rectangle1, RegionErosion4, _w, _h)</l>
<c>    *获取中心部分未包裹区域，用于判断</c>
<l>    difference (RegionErosion4, RegionClosing, RegionDifference)</l>
<l>    difference (RegionDifference5, RegionClosing, RegionIntersection)</l>
<l>    union2 (RegionDifference, RegionIntersection, RegionUnion3) </l>
<l>    closing_circle (RegionUnion3, RegionClosing5, 1.5)</l>
<l>    fill_up (RegionClosing5, RegionFillUp3)</l>
<c>    *</c>
<l>    connection (RegionFillUp3, ConnectedRegions2)</l>
<l>    area_center (ConnectedRegions2, Area1, Row4, Column4)</l>
<l>    tuple_max (Area1, Max1)</l>
<c>    *存在两个区域，最小的区域必须大于最大的区域的50%才算NG</c>
<c>    * Max1*0.5 改 Max1*0.8 20180116</c>
<c>    ******xxxxxxx******20180116上</c>
<c>    *D</c>
<c>    * 上下面积的相识度</c>
<l>    Z2_r2area:=0.9</l>
<c>    * 相识度高度系数</c>
<l>    Z2_r2_aHeight:=0.41</l>
<c>    * 相识度宽度系数</c>
<l>    Z2_r2_awidth:=0.75</l>
<c>    ******xxxxxxx******20180116下</c>
<l>    select_shape (ConnectedRegions2, area_erSRegions, 'area', 'and', Max1*Z2_r2area, h_row*cr_w)</l>
<l>    count_obj (area_erSRegions, areaNumber1)</l>
<l>    union1 (area_erSRegions, RegionUnion10)</l>
<l>    smallest_rectangle1 (RegionUnion10, Row15, Column15, Row25, Column25)</l>
<l>    a_height:=Row25-Row15</l>
<l>    a_width:=Column25-Column15</l>
<l>    if (areaNumber1&gt;1 and a_height&gt;h_row*Z2_r2_aHeight)</l>
<l>        area_erNumber:=1</l>
<l>    elseif (areaNumber1&gt;1 and a_width&gt;cr_w*Z2_r2_awidth)</l>
<l>        area_erNumber:=1</l>
<l>    else</l>
<l>        area_erNumber:=0</l>
<l>    endif</l>
<l>    stop ()</l>
<l>    gen_rectangle1 (Rectangle_bkd, Row11, Column11, Row11+31, Column21)</l>
<c>    *判断焊锡包裹度</c>
<c>    *拟合上面的区域</c>
<l>    stop ()</l>
<l>    intersection (Rectangle_bkd, RegionClosing, RegionIntersection2)</l>
<l>    closing_rectangle1 (RegionIntersection2, RegionClosing6, cr_w*0.5, 1)</l>
<l>    union2 (RegionClosing6, dw_SRegions, RegionUnion8)</l>
<l>    fill_up (RegionUnion8, RegionFillUp)</l>
<l>    difference (RegionFillUp, RegionUnion8, RegionIntersection4)</l>
<l>    union1 (RegionIntersection4, RegionUnion9)</l>
<l>    connection (RegionUnion9, ConnectedRegions9)</l>
<c>    ******xxxxxxx******20180327上</c>
<c>    * E</c>
<c>    * 焊锡包裹面积</c>
<l>    Z2_r3area:=0.19</l>
<c>    * 焊锡包裹宽度系数</c>
<l>    Z2_r3_crw_min:=0.1</l>
<l>    Z2_r3_crw_max:=0.5</l>
<c>    * 焊锡包裹高度系数</c>
<l>    Z2_r3_hrow:=0.56</l>
<c>    ******xxxxxxx******20180327下</c>
<l>    select_shape (ConnectedRegions9, dh_Sregion, \
                  ['area','width','height'], 'and', \
                  [h_row*cr_w*Z2_r3area,cr_w*Z2_r3_crw_min,h_row*Z2_r3_hrow], [h_row*cr_w,cr_w*Z2_r3_crw_max,(h_row+1)])</l>
<l>    count_obj (dh_Sregion, dh_ErNumber)</l>
<c>    </c>
<c></c>
<c>    *翘起的数量       最大允许长度（超过设定最大比例也判定为NG）</c>
<l>    h_ERROR_Number:=0</l>
<c>    *1：翘起的数量       最大允许长度（超过设定最大比例也判定为NG）</c>
<c>    *2：穿孔附近链接的严重翘起</c>
<c>    *3：计算90°∟直角特征</c>
<c>    *4：无包裹为NG</c>
<c>    *5：包裹不完整，却一边</c>
<c>    *6：判断焊锡包裹密度</c>
<c>    *7：判断焊锡包裹圆度</c>
<l>*     stop ()</l>
<l>    if (h_erNumber&gt;1 or h_ERROR_Number&gt;0 or h_erNumberX&gt;0 or h_ERROR_Number2&gt;0 \
        or dw_erNumber&lt;1 or LR_erNumberX&gt;0 or area_erNumber&gt;0 or dh_ErNumber&gt;0)</l>
<c>        *1：翘起的数量       最大允许长度（超过设定最大比例也判定为NG）</c>
<l>        if (h_ERROR_Number&gt;0)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (h_ER_sRegions)</l>
<l>            union2 (out_EO_error_region, h_ER_sRegions, out_EO_error_region)</l>
<l>        elseif (h_erNumber&gt;1)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (EmptyObject_her)</l>
<l>            union2 (out_EO_error_region, EmptyObject_her, out_EO_error_region)</l>
<c>            *2：穿孔附近链接的严重翘起</c>
<l>        elseif (h_erNumberX&gt;0)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (EmptyObject_her2)</l>
<l>            union2 (out_EO_error_region, EmptyObject_herX, out_EO_error_region)</l>
<c>            *3：计算90°∟直角特征</c>
<l>        elseif (h_ERROR_Number2&gt;0)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (EmptyObject_her2)</l>
<l>            union2 (out_EO_error_region, h_ERROR_SRegions2, out_EO_error_region)</l>
<c>            *4：无包裹为NG</c>
<l>        elseif (dw_erNumber&lt;1)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (Rectangle1)</l>
<l>            union2 (out_EO_error_region, Rectangle1, out_EO_error_region)</l>
<c>            *5：包裹不完整，却一边</c>
<l>        elseif (LR_erNumberX&gt;0)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (Rectangle1)</l>
<l>            union2 (out_EO_error_region, LR_SRegionsX, out_EO_error_region)</l>
<c>            *6：判断焊锡包裹密度</c>
<l>        elseif (area_erNumber&gt;0)</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (area_erSRegions)</l>
<l>            union2 (out_EO_error_region, area_erSRegions, out_EO_error_region)</l>
<c>            *7：判断焊锡包裹圆度</c>
<l>        else</l>
<l>            dev_set_color ('red')</l>
<l>            dev_display (dh_Sregion)</l>
<l>            union2 (out_EO_error_region, dh_Sregion, out_EO_error_region)</l>
<l>        endif</l>
<l>        disp_message (WindowID, 'NG', 'image', \
                      row_2+(Q_row)-200, column_2+(Q_PY_temp_spacing), 'red', 'false')</l>
<l>        out_temp_error := out_temp_error+1</l>
<l>    else</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (Rectangle1)</l>
<l>        disp_message (WindowID, 'OK', 'image', \
                      row_2+(Q_row)-200, column_2+(Q_PY_temp_spacing), 'green', 'false')</l>
<l>    endif   </l>
<l>    Q_PY_temp_spacing:=Q_PY_temp_spacing+Q_HJ_spacing</l>
<l>    dump_window_image (Img, WindowID)</l>
<c>    </c>
<l>endfor</l>
<l>* stop ()</l>
<l>return ()</l>
</body>
<docu id="str_Welding_recognition">
<parameters>
<parameter id="Image"/>
<parameter id="Image_AffinTrans"/>
<parameter id="Img"/>
<parameter id="WindowID"/>
<parameter id="column_2"/>
<parameter id="out_EO_error_region"/>
<parameter id="out_temp_error"/>
<parameter id="row_2"/>
</parameters>
</docu>
</procedure>
<procedure name="Star_AffineTransImage">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageGauss1_AffinTrans" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>try</l>
<c>    *3X3模糊图像</c>
<l>*     dev_display (Image)</l>
<l>    gauss_image (Image, ImageGauss1, 2.5)</l>
<c>    </c>
<c>    </c>
<l>*     dev_display (ImageGauss1)</l>
<l>    threshold (ImageGauss1, Region, 0, 40)</l>
<l>    connection (Region, ConnectedRegions)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>*     area_center (ConnectedRegions, Area, Row2, Column2)</l>
<l>*     tuple_max (Area, Max)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 300000, 999999999)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    fill_up (SelectedRegions, RegionFillUp)</l>
<l>    union1 (RegionFillUp, RegionUnion)</l>
<c>    </c>
<l>    smallest_rectangle1 (RegionUnion, Row11, Column11, Row21, Column21)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    gen_rectangle1 (Rectangle2,  0, 0, Row21-(Row21*0.5), Width)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    intersection (Rectangle2, RegionFillUp, RegionIntersection1)</l>
<c>    </c>
<l>*     dev_display (ImageGauss1)</l>
<l>*     opening_rectangle1 (RegionIntersection1, RegionOpening, 300, 1)</l>
<l>    erosion_rectangle1 (RegionIntersection1, RegionErosion1, 251, 151)</l>
<l>    dilation_rectangle1 (RegionErosion1, RegionDilation, 251, 151)</l>
<c>    </c>
<l>*     dev_display (ImageGauss1)</l>
<l>    difference (RegionFillUp, Rectangle2, RegionDifference)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    erosion_rectangle1 (RegionDifference, RegionErosion2, 25, 25)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    dilation_rectangle1 (RegionErosion2, RegionDilation1, 25, 25)</l>
<l>*     dev_display (ImageGauss1)</l>
<l>    union2 (RegionDilation, RegionDilation1, RegionUnion1)</l>
<l>    union1 (RegionUnion1, RegionUnion2)</l>
<c>    </c>
<l>    smallest_rectangle2 (RegionUnion2, Row3, Column3, Phi1, Length11, Length21)</l>
<c>    </c>
<c>    </c>
<l>    if (Phi1&lt;-0.5 or Phi1&gt;0.5)</l>
<c>        *从点和角度计算一个僵化的仿射变换。</c>
<l>        vector_angle_to_rigid (Row3, Column3, Phi1, Row3, Column3, rad(180), HomMat2D)</l>
<l>    else</l>
<c>        *从点和角度计算一个僵化的仿射变换。</c>
<l>        vector_angle_to_rigid (Row3, Column3, Phi1, Row3, Column3, rad(0), HomMat2D)</l>
<l>    endif</l>
<c>    </c>
<l>*     dev_display (ImageGauss1)</l>
<l>    affine_trans_image (ImageGauss1, ImageGauss1_AffinTrans, HomMat2D, 'constant', 'false')</l>
<c>    </c>
<l>catch (Exception)</l>
<l>    copy_obj (ImageGauss1, ImageGauss1_AffinTrans, 1, 1)</l>
<c>    </c>
<l>endtry</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="Star_AffineTransImage">
<parameters>
<parameter id="Height"/>
<parameter id="Image"/>
<parameter id="ImageGauss1_AffinTrans"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
</hdevelop>
